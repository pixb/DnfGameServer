# 01_迁移流程

## 📋 概述

本文档详细说明从 JProtobuf 到标准 Protobuf 的 7 步迁移流程。每一步都有明确的输入、输出和验证标准。

## 🔄 完整流程图

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ 1. 分析阶段 │───▶│ 2. 生成Proto │───▶│ 3. 生成Go代码 │
└─────────────┘    └─────────────┘    └─────────────┘
                                              │
                                              ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ 7. 经验总结 │◀──│ 6. 运行测试 │◀──│ 5. 生成Java代码 │
└─────────────┘    └─────────────┘    └─────────────┘
                                              │
                                              ▼
┌─────────────┐    ┌─────────────┐
│ 4. 编写测试 │◀──│ 3. 生成Go代码 │
└─────────────┘    └─────────────┘
```

## 📝 详细步骤

### 步骤 1: 分析 Java 文件

**目标**：理解现有 JProtobuf 消息的结构和字段定义

**输入**：
- Java 消息类文件（例如：`src/main/java/com/dnfm/mina/protobuf/LOGIN.java`）

**操作**：
1. 打开 Java 消息类文件
2. 分析 `@Protobuf` 注解的字段定义
3. 记录每个字段的：
   - 字段名称
   - 字段类型（`FieldType`）
   - 字段序号（`order`）
   - 是否必填（`required`）
4. 检查 `@MessageMeta` 注解，获取 module ID 和 cmd ID
5. 分析嵌套消息和枚举类型

**输出**：
- 字段分析表格
- 类型映射计划

**验证**：
- ✅ 所有字段都有明确的类型和序号
- ✅ module ID 和 cmd ID 已确认

**示例**：
```java
@MessageMeta(module = 10000, cmd = 0)
public class REQ_LOGIN extends Message {
    @Protobuf(fieldType = FieldType.STRING, order = 1, required = false)
    public String openid;
    
    @Protobuf(fieldType = FieldType.INT32, order = 2, required = false)
    public Integer type;
}
```

---

### 步骤 2: 生成 Proto 文件

**目标**：创建标准 Protobuf 格式的消息定义

**输入**：
- 步骤 1 的字段分析结果

**操作**：
1. 在 `proto/dnf/v1/` 目录创建 proto 文件
2. 定义消息结构，保持字段序号和类型一致
3. 添加必要的导入语句
4. 添加包声明和版本信息
5. 添加Java代码生成选项（重要）：
   - `option java_multiple_files = true;` - 为每个消息生成独立的Java文件
   - `option java_package = "com.dnfm.mina.protobuf.generated";` - 指定Java包名
   - `option java_outer_classname = "XXXProto";` - 指定外层类名
6. 验证 proto 文件语法正确

**输出**：
- Proto 文件（例如：`proto/dnf/v1/auth_login.proto`）

**验证**：
- ✅ Proto 文件语法正确
- ✅ 字段序号与 Java 文件一致
- ✅ 字段类型正确映射

**示例**：
```protobuf
syntax = "proto3";

package dnf.v1;

option go_package = "dnf/proto/v1;authloginv1";
option java_multiple_files = true;
option java_package = "com.dnfm.mina.protobuf.generated";
option java_outer_classname = "AuthLoginProto";

message LoginRequest {
    string openid = 1;
    int32 type = 2;
    string token = 3;
}
```

---

### 步骤 3: 生成 Go 代码

**目标**：使用 Buf 工具生成 Go 代码

**输入**：
- Proto 文件（步骤 2 的输出）

**操作**：
1. 在 `proto` 目录执行 `buf generate` 命令
2. 指定生成路径参数（如果需要）
3. 检查生成的 Go 代码文件
4. 验证生成的代码结构

**输出**：
- Go 代码文件（例如：`dnf-go-client/gen/go/dnf/v1/auth_login.pb.go`）

**验证**：
- ✅ Go 代码生成成功
- ✅ Go 代码编译通过
- ✅ 消息结构正确

**命令**：
```bash
cd /home/pix/dev/code/java/DnfGameServer/proto
buf generate --path dnf/v1/auth_login.proto
```

---

### 步骤 4: 编写 Go 测试用例

**目标**：验证生成的 Go 代码功能正常

**输入**：
- 生成的 Go 代码（步骤 3 的输出）

**操作**：
1. 在 `dnf-go-client/test/` 目录创建测试文件
2. 编写序列化测试用例
3. 编写反序列化测试用例
4. 编写边界值测试用例
5. 运行测试，验证通过

**输出**：
- Go 测试文件（例如：`dnf-go-client/test/auth_login_test.go`）

**验证**：
- ✅ 所有测试用例通过
- ✅ 序列化/反序列化正确
- ✅ 边界值处理正确

**示例**：
```go
func TestLoginRequest_Serialization(t *testing.T) {
    req := &dnfv1.LoginRequest{
        Openid: "test_openid",
        Type:  1,
        Token:  "test_token",
    }
    
    data, err := proto.Marshal(req)
    if err != nil {
        t.Fatalf("序列化失败: %v", err)
    }
    
    var decoded dnfv1.LoginRequest
    err = proto.Unmarshal(data, &decoded)
    if err != nil {
        t.Fatalf("反序列化失败: %v", err)
    }
    
    if decoded.Openid != req.Openid {
        t.Errorf("openid 不匹配")
    }
}
```

---

### 步骤 5: 生成 Java 代码

**目标**：使用 Buf 工具生成 Java 代码

**输入**：
- Proto 文件（步骤 2 的输出）

**操作**：
1. 在 `proto` 目录执行 `buf generate` 命令
2. 检查生成的 Java 代码文件
3. 验证生成的代码结构
4. 集成到 Java 项目

**输出**：
- Java 代码文件（例如：`proto/gen/java/com/dnfm/mina/protobuf/generated/LoginRequest.java`）

**验证**：
- ✅ Java 代码生成成功
- ✅ Java 代码编译通过
- ✅ package 路径正确

**命令**：
```bash
cd /home/pix/dev/code/java/DnfGameServer/proto
buf generate --path dnf/v1/auth_login.proto
```

---

### 步骤 6: 调试 Java 服务端

**目标**：验证 Java 服务端能够正确使用新协议

**输入**：
- 生成的 Java 代码（步骤 5 的输出）
- Java 项目源代码

**操作**：
1. 修改 Java 代码使用新协议
2. 编译整个项目
3. 启动 Java 服务端
4. 检查启动日志
5. 验证服务端口可访问

**输出**：
- 运行中的 Java 服务端

**验证**：
- ✅ 项目编译成功
- ✅ 服务启动成功
- ✅ 无错误日志
- ✅ 端口可访问

**命令**：
```bash
cd /home/pix/dev/code/java/DnfGameServer
./mvnw clean compile
./mvnw spring-boot:run
```

---

### 步骤 7: 运行 Go 测试用例

**目标**：验证跨语言通信正常

**输入**：
- Go 测试用例（步骤 4 的输出）
- 运行中的 Java 服务端（步骤 6 的输出）

**操作**：
1. 运行 Go 测试用例
2. 检查测试输出
3. 验证跨语言通信
4. 记录测试结果
5. 总结迁移经验

**输出**：
- 测试结果报告
- 迁移经验总结

**验证**：
- ✅ 所有测试用例通过
- ✅ Go 客户端能连接 Java 服务端
- ✅ 消息序列化/反序列化正确
- ✅ 跨语言通信正常

**命令**：
```bash
cd /home/pix/dev/code/java/DnfGameServer/dnf-go-client/test
go test -v
```

---

## 📊 步骤依赖关系

| 步骤 | 前置步骤 | 后续步骤 |
| :--- | :--- | :--- |
| 1. 分析 Java 文件 | 无 | 2. 生成 Proto 文件 |
| 2. 生成 Proto 文件 | 1. 分析 Java 文件 | 3. 生成 Go 代码, 5. 生成 Java 代码 |
| 3. 生成 Go 代码 | 2. 生成 Proto 文件 | 4. 编写 Go 测试用例 |
| 4. 编写 Go 测试用例 | 3. 生成 Go 代码 | 7. 运行 Go 测试用例 |
| 5. 生成 Java 代码 | 2. 生成 Proto 文件 | 6. 调试 Java 服务端 |
| 6. 调试 Java 服务端 | 5. 生成 Java 代码 | 7. 运行 Go 测试用例 |
| 7. 运行 Go 测试用例 | 4. 编写 Go 测试用例, 6. 调试 Java 服务端 | 无 |

## ⚠️ 常见错误

### 错误 1: 字段序号不匹配

**现象**：生成的代码与 Java 代码行为不一致

**原因**：Proto 文件中的字段序号与 Java 文件不一致

**解决方案**：
- 检查 Java 文件中的 `order` 值
- 确保 Proto 文件中的字段序号一致
- 重新生成代码

### 错误 2: 类型映射错误

**现象**：编译错误或运行时类型不匹配

**原因**：字段类型映射不正确

**解决方案**：
- 参考 [02_类型映射.md](./02_类型映射.md) 中的类型映射表
- 确保类型映射正确
- 重新生成代码

### 错误 3: 生成代码编译失败

**现象**：生成的代码无法编译

**原因**：Proto 文件语法错误或依赖缺失

**解决方案**：
- 检查 Proto 文件语法
- 确保所有依赖正确
- 查看 [03_常见问题.md](./03_常见问题.md) 中的解决方案

## 📝 检查清单

每完成一个步骤，都应该验证以下检查项：

### 步骤 1 检查清单
- [ ] 所有字段都已分析
- [ ] 字段类型已记录
- [ ] 字段序号已确认
- [ ] module ID 和 cmd ID 已确认
- [ ] 嵌套消息已分析

### 步骤 2 检查清单
- [ ] Proto 文件已创建
- [ ] 字段序号与 Java 一致
- [ ] 字段类型正确映射
- [ ] Proto 文件语法正确
- [ ] 包声明正确

### 步骤 3 检查清单
- [ ] Go 代码已生成
- [ ] Go 代码编译通过
- [ ] 消息结构正确
- [ ] 生成路径正确

### 步骤 4 检查清单
- [ ] 测试文件已创建
- [ ] 序列化测试已编写
- [ ] 反序列化测试已编写
- [ ] 边界值测试已编写
- [ ] 所有测试通过

### 步骤 5 检查清单
- [ ] Java 代码已生成
- [ ] Java 代码编译通过
- [ ] package 路径正确
- [ ] 代码已集成到项目

### 步骤 6 检查清单
- [ ] Java 代码已修改
- [ ] 项目编译成功
- [ ] 服务启动成功
- [ ] 无错误日志
- [ ] 端口可访问

### 步骤 7 检查清单
- [ ] Go 测试已运行
- [ ] 所有测试通过
- [ ] 跨语言通信正常
- [ ] 测试结果已记录
- [ ] 迁移经验已总结

## 🎯 成功标准

完成所有 7 个步骤后，应该满足以下标准：

- ✅ Proto 文件语法正确
- ✅ Go 代码生成成功
- ✅ Java 代码生成成功
- ✅ 所有测试用例通过
- ✅ Java 服务端启动成功
- ✅ 跨语言通信正常
- ✅ 迁移经验已记录

## 📚 相关文档

- [02_类型映射.md](./02_类型映射.md) - JProtobuf 到标准 Protobuf 的类型映射
- [03_常见问题.md](./03_常见问题.md) - 常见问题与解决方案
- [04_双模式编解码器.md](./04_双模式编解码器.md) - 双模式编解码器实现
- [05_跨语言通信测试.md](./05_跨语言通信测试.md) - 跨语言通信测试指南
- [06_经验总结模板.md](./06_经验总结模板.md) - 经验总结模板
