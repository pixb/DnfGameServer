# 阶段一：框架搭建

## 目标

本阶段的目标是搭建 Go 游戏服务器的基础框架，包括项目结构、网络通信、数据库、配置管理、日志系统等核心基础设施。这些基础设施是后续所有业务功能开发的基础。

## 需求分析

### 1. 项目结构需求
- 建立清晰的 Go 项目目录结构
- 实现模块化设计
- 支持依赖管理
- 支持配置文件管理

### 2. 网络通信需求
- 实现 TCP 服务器
- 实现 Protobuf 消息编解码
- 实现消息路由机制
- 实现会话管理
- 实现心跳检测

### 3. 数据库需求
- 实现数据库连接池
- 实现 ORM 框架集成
- 实现多数据源支持
- 实现数据库事务

### 4. 配置管理需求
- 实现配置文件加载
- 实现配置热更新
- 实现配置缓存

### 5. 日志系统需求
- 实现日志记录
- 实现日志分类
- 实现日志级别控制
- 实现日志文件轮转

### 6. 定时任务需求
- 实现定时任务调度
- 实现任务执行器
- 实现任务监控

## 技术方案

### 1. 项目结构设计

采用标准的 Go 项目结构，遵循 Go 的最佳实践：

```
dnf-game-server/
├── cmd/                    # 命令行入口
│   └── server/            # 服务器启动
│       └── main.go        # 主入口
├── internal/              # 内部模块（不对外暴露）
│   ├── common/           # 公共模块
│   │   ├── config/      # 配置管理
│   │   ├── db/          # 数据库服务
│   │   ├── utils/       # 工具类
│   │   └── logger/      # 日志管理
│   ├── network/         # 网络通信
│   │   ├── codec/       # 编解码器
│   │   ├── handler/     # 消息处理器
│   │   ├── session/     # 会话管理
│   │   └── filter/      # 过滤器
│   └── game/            # 游戏业务（后续阶段实现）
├── pkg/                  # 公共包（可对外暴露）
│   ├── protobuf/        # Protobuf 生成代码
│   └── utils/           # 工具包
├── api/                  # HTTP 接口
│   └── game/            # 游戏接口
├── configs/              # 配置文件
│   ├── config.yaml       # 主配置文件
│   └── game.yaml        # 游戏配置文件
├── proto/                # Protobuf 定义
│   └── dnf/             # DNF 协议定义
└── docs/                 # 文档
```

**设计决策**：
- 使用 `internal` 目录存放内部模块，避免外部包直接引用
- 使用 `pkg` 目录存放可对外暴露的公共包
- 使用 `cmd` 目录存放命令行入口
- 使用 `configs` 目录存放配置文件
- 使用 `proto` 目录存放 Protobuf 定义

### 2. 网络通信方案

#### 2.1 框架选择
使用 Go 标准库 `net` 包实现 TCP 服务器，不依赖第三方网络框架。

**设计决策**：
- Go 标准库 `net` 包性能优秀，无需额外依赖
- 更容易控制和优化网络层
- 减少第三方依赖，降低维护成本

#### 2.2 消息编解码
使用 Protobuf 进行消息序列化和反序列化。

**设计决策**：
- Protobuf 是高效的二进制协议
- 与 Java 版本保持一致
- 支持跨语言通信

#### 2.3 消息路由
使用消息 ID 路由到对应的处理器。

**设计决策**：
- 消息 ID 与处理器映射
- 支持动态注册处理器
- 支持消息过滤器

#### 2.4 会话管理
使用 Session 结构管理客户端连接。

**设计决策**：
- 每个连接对应一个 Session
- Session 存储连接状态和用户信息
- 支持会话超时检测

#### 2.5 心跳检测
实现客户端与服务器的心跳检测机制。

**设计决策**：
- 定时发送心跳包
- 检测心跳超时
- 超时自动断开连接

### 3. 数据库方案

#### 3.1 ORM 框架选择
使用 GORM 作为 ORM 框架。

**设计决策**：
- GORM 是 Go 最流行的 ORM 框架
- 功能完善，文档丰富
- 支持多种数据库
- 与 Java 版本的 NutZ 类似

#### 3.2 数据库连接池
使用 GORM 的连接池功能。

**设计决策**：
- GORM 内置连接池
- 支持连接池配置
- 支持连接超时

#### 3.3 多数据源支持
实现多数据源管理器。

**设计决策**：
- 支持多个数据库实例
- 支持数据源切换
- 支持读写分离

#### 3.4 数据库事务
使用 GORM 的事务功能。

**设计决策**：
- 支持事务嵌套
- 支持事务回滚
- 支持事务传播

### 4. 配置管理方案

#### 4.1 配置文件格式
使用 YAML 格式的配置文件。

**设计决策**：
- YAML 格式易读易写
- 支持注释
- 支持复杂结构

#### 4.2 配置加载
使用 Viper 库加载配置文件。

**设计决策**：
- Viper 是 Go 最流行的配置管理库
- 支持多种配置格式
- 支持配置热更新

#### 4.3 配置热更新
实现配置文件监听和热更新。

**设计决策**：
- 监听配置文件变化
- 自动重新加载配置
- 通知配置变更

### 5. 日志系统方案

#### 5.1 日志库选择
使用 logrus 作为日志库。

**设计决策**：
- logrus 是 Go 最流行的日志库
- 功能完善，性能优秀
- 支持多种日志格式
- 支持日志钩子

#### 5.2 日志分类
按模块分类日志。

**设计决策**：
- 每个模块独立日志
- 支持日志级别控制
- 支持日志文件分离

#### 5.3 日志级别
支持多种日志级别。

**设计决策**：
- Debug：调试信息
- Info：一般信息
- Warn：警告信息
- Error：错误信息
- Fatal：致命错误

#### 5.4 日志文件轮转
使用 lumberjack 实现日志文件轮转。

**设计决策**：
- 支持按大小轮转
- 支持按时间轮转
- 支持日志文件保留

### 6. 定时任务方案

#### 6.1 定时任务库选择
使用 robfig/cron 库实现定时任务。

**设计决策**：
- robfig/cron 是 Go 最流行的定时任务库
- 支持 Cron 表达式
- 支持并发执行

#### 6.2 任务执行器
使用 goroutine 执行定时任务。

**设计决策**：
- 每个任务独立 goroutine
- 支持任务超时
- 支持任务重试

## 实现步骤

### 步骤 1：创建项目结构

#### 1.1 初始化 Go 模块
```bash
mkdir dnf-game-server
cd dnf-game-server
go mod init github.com/pixb/dnf-game-server
```

#### 1.2 创建目录结构
```bash
mkdir -p cmd/server
mkdir -p internal/common/{config,db,utils,logger}
mkdir -p internal/network/{codec,handler,session,filter}
mkdir -p pkg/{protobuf,utils}
mkdir -p api/game
mkdir -p configs
mkdir -p proto/dnf
mkdir -p docs
```

#### 1.3 创建主入口文件
创建 `cmd/server/main.go`：
```go
package main

import (
    "fmt"
    "log"
    "os"
    "os/signal"
    "syscall"

    "github.com/pixb/dnf-game-server/internal/common/config"
    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/pixb/dnf-game-server/internal/network"
)

func main() {
    // 加载配置
    cfg, err := config.Load("configs/config.yaml")
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }

    // 初始化日志
    logger.Init(cfg.Logger)

    // 启动网络服务器
    server := network.NewServer(cfg)
    if err := server.Start(); err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }

    // 等待退出信号
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    // 停止服务器
    server.Stop()
    fmt.Println("Server stopped")
}
```

### 步骤 2：实现配置管理

#### 2.1 定义配置结构
创建 `internal/common/config/config.go`：
```go
package config

import (
    "github.com/spf13/viper"
)

type Config struct {
    Server ServerConfig `mapstructure:"server"`
    Logger LoggerConfig `mapstructure:"logger"`
    DB     DBConfig     `mapstructure:"db"`
}

type ServerConfig struct {
    Host string `mapstructure:"host"`
    Port int    `mapstructure:"port"`
}

type LoggerConfig struct {
    Level      string `mapstructure:"level"`
    Format     string `mapstructure:"format"`
    Output     string `mapstructure:"output"`
    MaxSize    int    `mapstructure:"max_size"`
    MaxBackups int    `mapstructure:"max_backups"`
    MaxAge     int    `mapstructure:"max_age"`
}

type DBConfig struct {
    Host     string `mapstructure:"host"`
    Port     int    `mapstructure:"port"`
    User     string `mapstructure:"user"`
    Password string `mapstructure:"password"`
    Database string `mapstructure:"database"`
}

func Load(path string) (*Config, error) {
    v := viper.New()
    v.SetConfigFile(path)
    v.SetConfigType("yaml")

    if err := v.ReadInConfig(); err != nil {
        return nil, err
    }

    var cfg Config
    if err := v.Unmarshal(&cfg); err != nil {
        return nil, err
    }

    return &cfg, nil
}
```

#### 2.2 创建配置文件
创建 `configs/config.yaml`：
```yaml
server:
  host: "0.0.0.0"
  port: 8080

logger:
  level: "info"
  format: "json"
  output: "logs/server.log"
  max_size: 100
  max_backups: 3
  max_age: 7

db:
  host: "localhost"
  port: 3306
  user: "root"
  password: "password"
  database: "dnf_game"
```

### 步骤 3：实现日志系统

#### 3.1 初始化日志
创建 `internal/common/logger/logger.go`：
```go
package logger

import (
    "os"
    "path/filepath"

    "github.com/pixb/dnf-game-server/internal/common/config"
    "github.com/sirupsen/logrus"
    "gopkg.in/natefinch/lumberjack.v2"
)

var log *logrus.Logger

func Init(cfg config.LoggerConfig) {
    log = logrus.New()

    // 设置日志级别
    level, err := logrus.ParseLevel(cfg.Level)
    if err != nil {
        level = logrus.InfoLevel
    }
    log.SetLevel(level)

    // 设置日志格式
    if cfg.Format == "json" {
        log.SetFormatter(&logrus.JSONFormatter{})
    } else {
        log.SetFormatter(&logrus.TextFormatter{})
    }

    // 设置日志输出
    if cfg.Output != "" {
        dir := filepath.Dir(cfg.Output)
        if err := os.MkdirAll(dir, 0755); err != nil {
            log.Fatalf("Failed to create log directory: %v", err)
        }

        log.SetOutput(&lumberjack.Logger{
            Filename:   cfg.Output,
            MaxSize:    cfg.MaxSize,
            MaxBackups: cfg.MaxBackups,
            MaxAge:     cfg.MaxAge,
        })
    }
}

func GetLogger() *logrus.Logger {
    return log
}

func Info(args ...interface{}) {
    log.Info(args...)
}

func Infof(format string, args ...interface{}) {
    log.Infof(format, args...)
}

func Warn(args ...interface{}) {
    log.Warn(args...)
}

func Warnf(format string, args ...interface{}) {
    log.Warnf(format, args...)
}

func Error(args ...interface{}) {
    log.Error(args...)
}

func Errorf(format string, args ...interface{}) {
    log.Errorf(format, args...)
}

func Fatal(args ...interface{}) {
    log.Fatal(args...)
}

func Fatalf(format string, args ...interface{}) {
    log.Fatalf(format, args...)
}
```

### 步骤 4：实现数据库连接

#### 4.1 初始化数据库
创建 `internal/common/db/db.go`：
```go
package db

import (
    "fmt"
    "time"

    "github.com/pixb/dnf-game-server/internal/common/config"
    "github.com/pixb/dnf-game-server/internal/common/logger"
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
)

var DB *gorm.DB

func Init(cfg config.DBConfig) error {
    dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=True&loc=Local",
        cfg.User,
        cfg.Password,
        cfg.Host,
        cfg.Port,
        cfg.Database,
    )

    var err error
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        return fmt.Errorf("failed to connect database: %w", err)
    }

    sqlDB, err := DB.DB()
    if err != nil {
        return fmt.Errorf("failed to get database instance: %w", err)
    }

    // 设置连接池
    sqlDB.SetMaxIdleConns(10)
    sqlDB.SetMaxOpenConns(100)
    sqlDB.SetConnMaxLifetime(time.Hour)

    logger.Info("Database connected successfully")
    return nil
}

func GetDB() *gorm.DB {
    return DB
}
```

### 步骤 5：实现网络通信

#### 5.1 定义 Session 结构
创建 `internal/network/session/session.go`：
```go
package session

import (
    "net"
    "sync"
    "time"
)

type Session struct {
    ID        uint64
    Conn      net.Conn
    UserID    uint64
    LastHeartbeat time.Time
    mu        sync.RWMutex
}

func NewSession(id uint64, conn net.Conn) *Session {
    return &Session{
        ID:        id,
        Conn:      conn,
        LastHeartbeat: time.Now(),
    }
}

func (s *Session) Send(data []byte) error {
    s.mu.RLock()
    defer s.mu.RUnlock()
    _, err := s.Conn.Write(data)
    return err
}

func (s *Session) Close() error {
    s.mu.Lock()
    defer s.mu.Unlock()
    return s.Conn.Close()
}

func (s *Session) UpdateHeartbeat() {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.LastHeartbeat = time.Now()
}

func (s *Session) IsTimeout(timeout time.Duration) bool {
    s.mu.RLock()
    defer s.mu.RUnlock()
    return time.Since(s.LastHeartbeat) > timeout
}
```

#### 5.2 定义服务器结构
创建 `internal/network/server.go`：
```go
package network

import (
    "context"
    "fmt"
    "net"
    "sync"
    "time"

    "github.com/pixb/dnf-game-server/internal/common/config"
    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/pixb/dnf-game-server/internal/network/session"
)

type Server struct {
    cfg       *config.Config
    listener  net.Listener
    sessions  map[uint64]*session.Session
    sessionMu sync.RWMutex
    sessionID uint64
    ctx       context.Context
    cancel    context.CancelFunc
    wg        sync.WaitGroup
}

func NewServer(cfg *config.Config) *Server {
    ctx, cancel := context.WithCancel(context.Background())
    return &Server{
        cfg:      cfg,
        sessions: make(map[uint64]*session.Session),
        ctx:      ctx,
        cancel:   cancel,
    }
}

func (s *Server) Start() error {
    addr := fmt.Sprintf("%s:%d", s.cfg.Server.Host, s.cfg.Server.Port)
    listener, err := net.Listen("tcp", addr)
    if err != nil {
        return fmt.Errorf("failed to listen: %w", err)
    }
    s.listener = listener

    logger.Infof("Server started on %s", addr)

    // 启动心跳检测
    s.wg.Add(1)
    go s.heartbeatCheck()

    // 接受连接
    s.wg.Add(1)
    go s.acceptConnections()

    return nil
}

func (s *Server) Stop() {
    s.cancel()
    if s.listener != nil {
        s.listener.Close()
    }
    s.wg.Wait()
}

func (s *Server) acceptConnections() {
    defer s.wg.Done()

    for {
        select {
        case <-s.ctx.Done():
            return
        default:
            conn, err := s.listener.Accept()
            if err != nil {
                logger.Errorf("Failed to accept connection: %v", err)
                continue
            }

            s.sessionMu.Lock()
            s.sessionID++
            sessID := s.sessionID
            sess := session.NewSession(sessID, conn)
            s.sessions[sessID] = sess
            s.sessionMu.Unlock()

            s.wg.Add(1)
            go s.handleSession(sess)
        }
    }
}

func (s *Server) handleSession(sess *session.Session) {
    defer s.wg.Done()
    defer sess.Close()
    defer func() {
        s.sessionMu.Lock()
        delete(s.sessions, sess.ID)
        s.sessionMu.Unlock()
    }()

    logger.Infof("Session %d connected", sess.ID)

    buf := make([]byte, 4096)
    for {
        select {
        case <-s.ctx.Done():
            return
        default:
            n, err := sess.Conn.Read(buf)
            if err != nil {
                logger.Errorf("Session %d read error: %v", sess.ID, err)
                return
            }

            // 处理消息
            s.handleMessage(sess, buf[:n])
        }
    }
}

func (s *Server) handleMessage(sess *session.Session, data []byte) {
    // TODO: 实现消息处理逻辑
    logger.Infof("Session %d received %d bytes", sess.ID, len(data))
}

func (s *Server) heartbeatCheck() {
    defer s.wg.Done()

    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-s.ctx.Done():
            return
        case <-ticker.C:
            s.sessionMu.RLock()
            for id, sess := range s.sessions {
                if sess.IsTimeout(60 * time.Second) {
                    logger.Warnf("Session %d timeout, closing", id)
                    sess.Close()
                }
            }
            s.sessionMu.RUnlock()
        }
    }
}
```

### 步骤 6：实现定时任务

#### 6.1 创建定时任务管理器
创建 `internal/common/scheduler/scheduler.go`：
```go
package scheduler

import (
    "sync"

    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/robfig/cron/v3"
)

type Scheduler struct {
    cron *cron.Cron
    jobs map[string]cron.EntryID
    mu   sync.RWMutex
}

var instance *Scheduler
var once sync.Once

func GetInstance() *Scheduler {
    once.Do(func() {
        instance = &Scheduler{
            cron: cron.New(),
            jobs: make(map[string]cron.EntryID),
        }
    })
    return instance
}

func (s *Scheduler) Start() {
    s.cron.Start()
    logger.Info("Scheduler started")
}

func (s *Scheduler) Stop() {
    s.cron.Stop()
    logger.Info("Scheduler stopped")
}

func (s *Scheduler) AddJob(name string, spec string, job func()) error {
    s.mu.Lock()
    defer s.mu.Unlock()

    if _, exists := s.jobs[name]; exists {
        return fmt.Errorf("job %s already exists", name)
    }

    id, err := s.cron.AddFunc(spec, job)
    if err != nil {
        return fmt.Errorf("failed to add job %s: %w", name, err)
    }

    s.jobs[name] = id
    logger.Infof("Job %s added with spec: %s", name, spec)
    return nil
}

func (s *Scheduler) RemoveJob(name string) {
    s.mu.Lock()
    defer s.mu.Unlock()

    if id, exists := s.jobs[name]; exists {
        s.cron.Remove(id)
        delete(s.jobs, name)
        logger.Infof("Job %s removed", name)
    }
}
```

### 步骤 7：添加依赖

#### 7.1 添加 Go 依赖
```bash
go get github.com/spf13/viper
go get github.com/sirupsen/logrus
go get gopkg.in/natefinch/lumberjack.v2
go get gorm.io/gorm
go get gorm.io/driver/mysql
go get github.com/robfig/cron/v3
go get google.golang.org/protobuf
```

### 步骤 8：编译和运行

#### 8.1 编译项目
```bash
go build -o bin/server cmd/server/main.go
```

#### 8.2 运行项目
```bash
./bin/server
```

## 关键决策

### 1. 为什么使用 Go 标准库 net 包？
- Go 标准库性能优秀
- 无需额外依赖
- 更容易控制和优化

### 2. 为什么使用 GORM？
- Go 最流行的 ORM 框架
- 功能完善，文档丰富
- 与 Java 版本的 NutZ 类似

### 3. 为什么使用 Viper？
- Go 最流行的配置管理库
- 支持多种配置格式
- 支持配置热更新

### 4. 为什么使用 logrus？
- Go 最流行的日志库
- 功能完善，性能优秀
- 支持多种日志格式

### 5. 为什么使用 robfig/cron？
- Go 最流行的定时任务库
- 支持 Cron 表达式
- 支持并发执行

## 验证方法

### 1. 编译验证
```bash
go build -o bin/server cmd/server/main.go
```

### 2. 运行验证
```bash
./bin/server
```

### 3. 连接验证
使用 telnet 或 nc 连接服务器：
```bash
telnet localhost 8080
```

### 4. 日志验证
检查日志文件是否正常生成：
```bash
ls -la logs/
```

### 5. 数据库连接验证
检查数据库连接是否正常：
```bash
# 查看日志中的数据库连接信息
tail -f logs/server.log
```

## 阶段总结

本阶段完成了 Go 游戏服务器的基础框架搭建，包括：
- 项目结构建立
- 配置管理实现
- 日志系统实现
- 数据库连接实现
- 网络通信实现
- 定时任务实现

这些基础设施为后续的业务功能开发提供了坚实的基础。
