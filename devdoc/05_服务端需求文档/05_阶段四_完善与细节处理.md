# 阶段四：完善与细节处理

## 目标

本阶段的目标是完善游戏的细节功能，包括成就系统、排名系统、PK 系统、组队系统、聊天系统、跨服系统等，并对系统进行最终的完善和优化。

## 需求分析

### 1. 成就系统需求
- 支持成就列表查询
- 支持成就进度更新
- 支持成就奖励领取
- 支持成就统计

### 2. 排名系统需求
- 支持多种排行榜
- 支持实时排名更新
- 支持排名缓存
- 支持排名查询

### 3. PK 系统需求
- 支持 PK 请求
- 支持 PK 战斗
- 支持 PK 结算
- 支持 PK 记录

### 4. 组队系统需求
- 支持创建队伍
- 支持加入队伍
- 支持离开队伍
- 支持队伍管理

### 5. 聊天系统需求
- 支持多种聊天频道
- 支持敏感词过滤
- 支持聊天记录
- 支持聊天禁言

### 6. 跨服系统需求
- 支持跨服连接
- 支持跨服通信
- 支持跨服功能
- 支持跨服数据同步

### 7. 监控告警需求
- 支持性能监控
- 支持业务监控
- 支持异常告警
- 支持日志分析

## 技术方案

### 1. 成就系统实现

#### 1.1 成就模型
```go
type Achievement struct {
    ID          uint64    `gorm:"primaryKey;column:achievementId" json:"achievement_id"`
    RoleID      uint64    `gorm:"column:roleId" json:"role_id"`
    AchievementID uint32  `gorm:"column:achievementId" json:"achievement_id"`
    Progress    uint32    `gorm:"column:progress" json:"progress"`
    IsCompleted bool      `gorm:"column:isCompleted" json:"is_completed"`
    IsReward    bool      `gorm:"column:isReward" json:"is_reward"`
    CompleteTime time.Time `gorm:"column:completeTime" json:"complete_time"`
}

func (Achievement) TableName() string {
    return "t_achievement"
}
```

#### 1.2 成就服务
```go
type AchievementService struct {
    db    *gorm.DB
    cache *cache.Cache
}

func NewAchievementService() *AchievementService {
    return &AchievementService{
        db:    db.GetDB(),
        cache: cache.NewCache(),
    }
}

func (s *AchievementService) GetAchievements(ctx context.Context, roleID uint64) ([]*model.Achievement, error) {
    cacheKey := fmt.Sprintf("achievements:%d", roleID)
    var achievements []*model.Achievement
    if err := s.cache.Get(ctx, cacheKey, &achievements); err == nil {
        return achievements, nil
    }

    err := s.db.Where("roleId = ?", roleID).Find(&achievements).Error
    if err != nil {
        logger.Errorf("Failed to query achievements: %v", err)
        return nil, err
    }

    s.cache.Set(ctx, cacheKey, achievements, 5*time.Minute)
    return achievements, nil
}

func (s *AchievementService) UpdateProgress(ctx context.Context, roleID uint64, achievementID uint32, progress uint32) error {
    var achievement model.Achievement
    err := s.db.Where("roleId = ? AND achievementId = ?", roleID, achievementID).First(&achievement).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            achievement = model.Achievement{
                RoleID:        roleID,
                AchievementID: achievementID,
                Progress:      progress,
            }
            err = s.db.Create(&achievement).Error
        }
        if err != nil {
            logger.Errorf("Failed to update achievement progress: %v", err)
            return err
        }
    } else {
        achievement.Progress = progress
        err = s.db.Save(&achievement).Error
        if err != nil {
            logger.Errorf("Failed to update achievement progress: %v", err)
            return err
        }
    }

    // 清除缓存
    s.cache.Del(ctx, fmt.Sprintf("achievements:%d", roleID))
    return nil
}

func (s *AchievementService) ReceiveReward(ctx context.Context, roleID uint64, achievementID uint32) error {
    var achievement model.Achievement
    err := s.db.Where("roleId = ? AND achievementId = ?", roleID, achievementID).First(&achievement).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return errors.New("achievement not found")
        }
        logger.Errorf("Failed to query achievement: %v", err)
        return err
    }

    if !achievement.IsCompleted {
        return errors.New("achievement not completed")
    }

    if achievement.IsReward {
        return errors.New("reward already received")
    }

    achievement.IsReward = true
    err = s.db.Save(&achievement).Error
    if err != nil {
        logger.Errorf("Failed to update achievement: %v", err)
        return err
    }

    // 清除缓存
    s.cache.Del(ctx, fmt.Sprintf("achievements:%d", roleID))
    return nil
}
```

### 2. 排名系统实现

#### 2.1 排名服务
```go
type RankService struct {
    db    *gorm.DB
    cache *cache.Cache
}

func NewRankService() *RankService {
    return &RankService{
        db:    db.GetDB(),
        cache: cache.NewCache(),
    }
}

func (s *RankService) GetLevelRank(ctx context.Context, limit int) ([]*model.Role, error) {
    cacheKey := fmt.Sprintf("rank:level:%d", limit)
    var roles []*model.Role
    if err := s.cache.Get(ctx, cacheKey, &roles); err == nil {
        return roles, nil
    }

    err := s.db.Order("level DESC, exp DESC").Limit(limit).Find(&roles).Error
    if err != nil {
        logger.Errorf("Failed to query level rank: %v", err)
        return nil, err
    }

    s.cache.Set(ctx, cacheKey, roles, 5*time.Minute)
    return roles, nil
}

func (s *RankService) GetCombatRank(ctx context.Context, limit int) ([]*model.Role, error) {
    cacheKey := fmt.Sprintf("rank:combat:%d", limit)
    var roles []*model.Role
    if err := s.cache.Get(ctx, cacheKey, &roles); err == nil {
        return roles, nil
    }

    err := s.db.Order("combat DESC").Limit(limit).Find(&roles).Error
    if err != nil {
        logger.Errorf("Failed to query combat rank: %v", err)
        return nil, err
    }

    s.cache.Set(ctx, cacheKey, roles, 5*time.Minute)
    return roles, nil
}
```

### 3. PK 系统实现

#### 3.1 PK 模型
```go
type PKRecord struct {
    ID        uint64    `gorm:"primaryKey;column:pkId" json:"pk_id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    TargetID  uint64    `gorm:"column:targetId" json:"target_id"`
    Result    uint32    `gorm:"column:result" json:"result"`
    Score     int32     `gorm:"column:score" json:"score"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (PKRecord) TableName() string {
    return "t_pk_record"
}
```

#### 3.2 PK 服务
```go
type PKService struct {
    db    *gorm.DB
    cache *cache.Cache
}

func NewPKService() *PKService {
    return &PKService{
        db:    db.GetDB(),
        cache: cache.NewCache(),
    }
}

func (s *PKService) CreatePK(ctx context.Context, roleID, targetID uint64) error {
    pkRecord := &model.PKRecord{
        RoleID:   roleID,
        TargetID: targetID,
    }

    err := s.db.Create(pkRecord).Error
    if err != nil {
        logger.Errorf("Failed to create pk: %v", err)
        return err
    }

    return nil
}

func (s *PKService) GetPKRecords(ctx context.Context, roleID uint64) ([]*model.PKRecord, error) {
    cacheKey := fmt.Sprintf("pk_records:%d", roleID)
    var records []*model.PKRecord
    if err := s.cache.Get(ctx, cacheKey, &records); err == nil {
        return records, nil
    }

    err := s.db.Where("roleId = ?", roleID).Order("createTime DESC").Find(&records).Error
    if err != nil {
        logger.Errorf("Failed to query pk records: %v", err)
        return nil, err
    }

    s.cache.Set(ctx, cacheKey, records, 5*time.Minute)
    return records, nil
}
```

### 4. 组队系统实现

#### 4.1 组队模型
```go
type Party struct {
    ID        uint64    `gorm:"primaryKey;column:partyId" json:"party_id"`
    LeaderID  uint64    `gorm:"column:leaderId" json:"leader_id"`
    MaxCount  uint32    `gorm:"column:maxCount" json:"max_count"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (Party) TableName() string {
    return "t_party"
}

type PartyMember struct {
    ID        uint64    `gorm:"primaryKey;column:memberId" json:"member_id"`
    PartyID   uint64    `gorm:"column:partyId" json:"party_id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    JoinTime  time.Time `gorm:"column:joinTime" json:"join_time"`
}

func (PartyMember) TableName() string {
    return "t_party_member"
}
```

#### 4.2 组队服务
```go
type PartyService struct {
    db    *gorm.DB
    cache *cache.Cache
}

func NewPartyService() *PartyService {
    return &PartyService{
        db:    db.GetDB(),
        cache: cache.NewCache(),
    }
}

func (s *PartyService) CreateParty(ctx context.Context, leaderID uint64) (*model.Party, error) {
    party := &model.Party{
        LeaderID:  leaderID,
        MaxCount:  4,
    }

    err := s.db.Create(party).Error
    if err != nil {
        logger.Errorf("Failed to create party: %v", err)
        return nil, err
    }

    // 添加队长成员
    member := &model.PartyMember{
        PartyID: party.ID,
        RoleID:  leaderID,
    }
    err = s.db.Create(member).Error
    if err != nil {
        logger.Errorf("Failed to add party member: %v", err)
        return nil, err
    }

    return party, nil
}

func (s *PartyService) JoinParty(ctx context.Context, partyID, roleID uint64) error {
    var party model.Party
    err := s.db.Where("partyId = ?", partyID).First(&party).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return errors.New("party not found")
        }
        logger.Errorf("Failed to query party: %v", err)
        return err
    }

    // 检查队伍人数
    var memberCount int64
    err = s.db.Model(&model.PartyMember{}).Where("partyId = ?", partyID).Count(&memberCount).Error
    if err != nil {
        logger.Errorf("Failed to count party members: %v", err)
        return err
    }

    if memberCount >= int64(party.MaxCount) {
        return errors.New("party is full")
    }

    member := &model.PartyMember{
        PartyID: partyID,
        RoleID:  roleID,
    }
    err = s.db.Create(member).Error
    if err != nil {
        logger.Errorf("Failed to join party: %v", err)
        return err
    }

    // 清除缓存
    s.cache.Del(ctx, fmt.Sprintf("party:%d", partyID))
    return nil
}
```

### 5. 聊天系统实现

#### 5.1 聊天模型
```go
type ChatMessage struct {
    ID        uint64    `gorm:"primaryKey;column:messageId" json:"message_id"`
    SenderID  uint64    `gorm:"column:senderId" json:"sender_id"`
    ReceiverID uint64   `gorm:"column:receiverId" json:"receiver_id"`
    Channel   uint32    `gorm:"column:channel" json:"channel"`
    Content   string    `gorm:"column:content;size:500" json:"content"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (ChatMessage) TableName() string {
    return "t_chat_message"
}
```

#### 5.2 聊天服务
```go
type ChatService struct {
    db    *gorm.DB
    cache *cache.Cache
}

func NewChatService() *ChatService {
    return &ChatService{
        db:    db.GetDB(),
        cache: cache.NewCache(),
    }
}

func (s *ChatService) SendChat(ctx context.Context, senderID, receiverID uint64, channel uint32, content string) error {
    // 敏感词过滤
    if s.containsSensitiveWords(content) {
        return errors.New("content contains sensitive words")
    }

    message := &model.ChatMessage{
        SenderID:   senderID,
        ReceiverID: receiverID,
        Channel:    channel,
        Content:    content,
    }

    err := s.db.Create(message).Error
    if err != nil {
        logger.Errorf("Failed to send chat: %v", err)
        return err
    }

    return nil
}

func (s *ChatService) containsSensitiveWords(content string) bool {
    sensitiveWords := []string{"badword1", "badword2"}
    for _, word := range sensitiveWords {
        if strings.Contains(content, word) {
            return true
        }
    }
    return false
}
```

### 6. 跨服系统实现

#### 6.1 跨服连接
```go
type CrossServer struct {
    addr     string
    conn     net.Conn
    mu       sync.RWMutex
}

func NewCrossServer(addr string) *CrossServer {
    return &CrossServer{
        addr: addr,
    }
}

func (s *CrossServer) Connect() error {
    s.mu.Lock()
    defer s.mu.Unlock()

    conn, err := net.Dial("tcp", s.addr)
    if err != nil {
        return fmt.Errorf("failed to connect cross server: %w", err)
    }

    s.conn = conn
    logger.Infof("Connected to cross server: %s", s.addr)
    return nil
}

func (s *CrossServer) Send(data []byte) error {
    s.mu.RLock()
    defer s.mu.RUnlock()

    if s.conn == nil {
        return errors.New("not connected")
    }

    _, err := s.conn.Write(data)
    return err
}

func (s *CrossServer) Close() error {
    s.mu.Lock()
    defer s.mu.Unlock()

    if s.conn != nil {
        err := s.conn.Close()
        s.conn = nil
        return err
    }
    return nil
}
```

### 7. 监控告警实现

#### 7.1 性能监控
```go
type Monitor struct {
    metrics map[string]interface{}
    mu      sync.RWMutex
}

func NewMonitor() *Monitor {
    return &Monitor{
        metrics: make(map[string]interface{}),
    }
}

func (m *Monitor) SetMetric(key string, value interface{}) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.metrics[key] = value
}

func (m *Monitor) GetMetric(key string) (interface{}, bool) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    value, exists := m.metrics[key]
    return value, exists
}

func (m *Monitor) GetAllMetrics() map[string]interface{} {
    m.mu.RLock()
    defer m.mu.RUnlock()
    metrics := make(map[string]interface{})
    for k, v := range m.metrics {
        metrics[k] = v
    }
    return metrics
}
```

## 实现步骤

### 步骤 1：实现成就系统
1. 定义成就模型
2. 实现成就服务
3. 实现成就处理器
4. 注册消息路由

### 步骤 2：实现排名系统
1. 定义排名模型
2. 实现排名服务
3. 实现排名处理器
4. 注册消息路由

### 步骤 3：实现 PK 系统
1. 定义 PK 模型
2. 实现 PK 服务
3. 实现 PK 处理器
4. 注册消息路由

### 步骤 4：实现组队系统
1. 定义组队模型
2. 实现组队服务
3. 实现组队处理器
4. 注册消息路由

### 步骤 5：实现聊天系统
1. 定义聊天模型
2. 实现聊天服务
3. 实现聊天处理器
4. 注册消息路由

### 步骤 6：实现跨服系统
1. 定义跨服模型
2. 实现跨服服务
3. 实现跨服处理器
4. 注册消息路由

### 步骤 7：实现监控告警
1. 实现性能监控
2. 实现业务监控
3. 实现异常告警
4. 实现日志分析

## 关键决策

### 1. 为什么使用 Redis 排名？
- Redis 的 ZSET 数据结构天然支持排名
- 性能优秀，适合实时排名
- 支持范围查询

### 2. 为什么使用敏感词过滤？
- 保护游戏环境
- 避免不良信息传播
- 符合监管要求

### 3. 为什么使用跨服系统？
- 支持跨服功能
- 提高游戏可玩性
- 增加玩家互动

## 验证方法

### 1. 功能验证
- 测试成就系统功能
- 测试排名系统功能
- 测试 PK 系统功能
- 测试组队系统功能
- 测试聊天系统功能
- 测试跨服系统功能

### 2. 监控验证
- 测试性能监控
- 测试业务监控
- 测试异常告警
- 测试日志分析

## 阶段总结

本阶段完成了游戏的细节功能实现和系统完善，包括：
- 成就系统实现
- 排名系统实现
- PK 系统实现
- 组队系统实现
- 聊天系统实现
- 跨服系统实现
- 监控告警实现

这些细节功能和系统完善使游戏更加完整和稳定。
