# 阶段三：功能扩展与优化

## 目标

本阶段的目标是实现游戏的扩展功能，包括好友系统、公会系统、邮件系统、副本系统、商城系统等，并对系统进行性能优化。

## 需求分析

### 1. 好友系统需求
- 支持添加好友
- 支持删除好友
- 支持好友分组
- 支持在线状态查询
- 支持好友私聊

### 2. 公会系统需求
- 支持创建公会
- 支持加入公会
- 支持退出公会
- 支持公会管理
- 支持公会技能

### 3. 邮件系统需求
- 支持发送邮件
- 支持接收邮件
- 支持邮件附件
- 支持邮件删除

### 4. 副本系统需求
- 支持副本列表查询
- 支持进入副本
- 支持副本战斗
- 支持副本结算

### 5. 商城系统需求
- 支持商品列表查询
- 支持商品购买
- 支持拍卖行
- 支持交易记录

### 6. 性能优化需求
- 支持数据缓存
- 支持连接池优化
- 支持消息批处理
- 支持异步处理

## 技术方案

### 1. Redis 缓存集成

#### 1.1 Redis 客户端选择
使用 go-redis 作为 Redis 客户端。

#### 1.2 缓存策略
- 热点数据缓存
- 缓存过期策略
- 缓存更新策略

#### 1.3 缓存实现
```go
package cache

import (
    "context"
    "encoding/json"
    "time"

    "github.com/pixb/dnf-game-server/internal/common/config"
    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/redis/go-redis/v9"
)

var redisClient *redis.Client

func Init(cfg config.RedisConfig) {
    redisClient = redis.NewClient(&redis.Options{
        Addr:     cfg.Addr,
        Password: cfg.Password,
        DB:       cfg.DB,
    })

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := redisClient.Ping(ctx).Err(); err != nil {
        logger.Fatalf("Failed to connect redis: %v", err)
    }

    logger.Info("Redis connected successfully")
}

func GetClient() *redis.Client {
    return redisClient
}

func Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
    data, err := json.Marshal(value)
    if err != nil {
        return err
    }
    return redisClient.Set(ctx, key, data, expiration).Err()
}

func Get(ctx context.Context, key string, dest interface{}) error {
    data, err := redisClient.Get(ctx, key).Bytes()
    if err != nil {
        return err
    }
    return json.Unmarshal(data, dest)
}

func Del(ctx context.Context, keys ...string) error {
    return redisClient.Del(ctx, keys...).Err()
}
```

### 2. 好友系统实现

#### 2.1 好友模型
```go
type Friend struct {
    ID        uint64    `gorm:"primaryKey;column:friendId" json:"friend_id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    FriendID  uint64    `gorm:"column:friendId" json:"friend_id"`
    GroupID   uint32    `gorm:"column:groupId" json:"group_id"`
    Remark    string    `gorm:"column:remark;size:50" json:"remark"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (Friend) TableName() string {
    return "t_friend"
}
```

#### 2.2 好友服务
```go
type FriendService struct {
    db    *gorm.DB
    cache *cache.Cache
}

func NewFriendService() *FriendService {
    return &FriendService{
        db:    db.GetDB(),
        cache: cache.NewCache(),
    }
}

func (s *FriendService) AddFriend(ctx context.Context, roleID, friendID uint64) error {
    friend := &model.Friend{
        RoleID:   roleID,
        FriendID: friendID,
    }

    err := s.db.Create(friend).Error
    if err != nil {
        logger.Errorf("Failed to add friend: %v", err)
        return err
    }

    // 清除缓存
    s.cache.Del(ctx, fmt.Sprintf("friends:%d", roleID))
    return nil
}

func (s *FriendService) GetFriends(ctx context.Context, roleID uint64) ([]*model.Friend, error) {
    // 先从缓存获取
    cacheKey := fmt.Sprintf("friends:%d", roleID)
    var friends []*model.Friend
    if err := s.cache.Get(ctx, cacheKey, &friends); err == nil {
        return friends, nil
    }

    // 从数据库获取
    err := s.db.Where("roleId = ?", roleID).Find(&friends).Error
    if err != nil {
        logger.Errorf("Failed to query friends: %v", err)
        return nil, err
    }

    // 写入缓存
    s.cache.Set(ctx, cacheKey, friends, 5*time.Minute)
    return friends, nil
}
```

### 3. 公会系统实现

#### 3.1 公会模型
```go
type Guild struct {
    ID          uint64    `gorm:"primaryKey;column:guildId" json:"guild_id"`
    Name        string    `gorm:"column:name;size:50" json:"name"`
    Level       uint32    `gorm:"column:level" json:"level"`
    Exp         uint64    `gorm:"column:exp" json:"exp"`
    LeaderID    uint64    `gorm:"column:leaderId" json:"leader_id"`
    MemberCount uint32    `gorm:"column:memberCount" json:"member_count"`
    CreateTime  time.Time `gorm:"column:createTime" json:"create_time"`
}

func (Guild) TableName() string {
    return "t_guild"
}

type GuildMember struct {
    ID        uint64    `gorm:"primaryKey;column:memberId" json:"member_id"`
    GuildID   uint64    `gorm:"column:guildId" json:"guild_id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    RoleType  uint32    `gorm:"column:roleType" json:"role_type"`
    JoinTime  time.Time `gorm:"column:joinTime" json:"join_time"`
}

func (GuildMember) TableName() string {
    return "t_guild_member"
}
```

#### 3.2 公会服务
```go
type GuildService struct {
    db    *gorm.DB
    cache *cache.Cache
}

func NewGuildService() *GuildService {
    return &GuildService{
        db:    db.GetDB(),
        cache: cache.NewCache(),
    }
}

func (s *GuildService) CreateGuild(ctx context.Context, name string, leaderID uint64) (*model.Guild, error) {
    guild := &model.Guild{
        Name:        name,
        Level:       1,
        LeaderID:    leaderID,
        MemberCount: 1,
    }

    err := s.db.Create(guild).Error
    if err != nil {
        logger.Errorf("Failed to create guild: %v", err)
        return nil, err
    }

    // 添加会长成员
    member := &model.GuildMember{
        GuildID:  guild.ID,
        RoleID:   leaderID,
        RoleType: 1, // 会长
    }
    err = s.db.Create(member).Error
    if err != nil {
        logger.Errorf("Failed to add guild member: %v", err)
        return nil, err
    }

    return guild, nil
}

func (s *GuildService) JoinGuild(ctx context.Context, guildID, roleID uint64) error {
    member := &model.GuildMember{
        GuildID: guildID,
        RoleID:  roleID,
        RoleType: 2, // 普通成员
    }

    err := s.db.Create(member).Error
    if err != nil {
        logger.Errorf("Failed to join guild: %v", err)
        return err
    }

    // 更新公会成员数
    s.db.Model(&model.Guild{}).Where("guildId = ?", guildID).UpdateColumn("memberCount", gorm.Expr("memberCount + 1"))

    // 清除缓存
    s.cache.Del(ctx, fmt.Sprintf("guild:%d", guildID))
    return nil
}
```

### 4. 邮件系统实现

#### 4.1 邮件模型
```go
type Mail struct {
    ID         uint64    `gorm:"primaryKey;column:mailId" json:"mail_id"`
    SenderID   uint64    `gorm:"column:senderId" json:"sender_id"`
    ReceiverID uint64    `gorm:"column:receiverId" json:"receiver_id"`
    Title      string    `gorm:"column:title;size:100" json:"title"`
    Content    string    `gorm:"column:content;size:500" json:"content"`
    HasRead    bool      `gorm:"column:hasRead" json:"has_read"`
    HasGet     bool      `gorm:"column:hasGet" json:"has_get"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
    ExpireTime time.Time `gorm:"column:expireTime" json:"expire_time"`
}

func (Mail) TableName() string {
    return "t_mail"
}

type MailItem struct {
    ID      uint64 `gorm:"primaryKey;column:itemId" json:"item_id"`
    MailID  uint64 `gorm:"column:mailId" json:"mail_id"`
    ItemID  uint64 `gorm:"column:itemId" json:"item_id"`
    ItemNum uint32 `gorm:"column:itemNum" json:"item_num"`
}

func (MailItem) TableName() string {
    return "t_mail_item"
}
```

#### 4.2 邮件服务
```go
type MailService struct {
    db    *gorm.DB
    cache *cache.Cache
}

func NewMailService() *MailService {
    return &MailService{
        db:    db.GetDB(),
        cache: cache.NewCache(),
    }
}

func (s *MailService) SendMail(ctx context.Context, senderID, receiverID uint64, title, content string) (*model.Mail, error) {
    mail := &model.Mail{
        SenderID:   senderID,
        ReceiverID: receiverID,
        Title:      title,
        Content:    content,
        HasRead:    false,
        HasGet:     false,
        ExpireTime:  time.Now().Add(30 * 24 * time.Hour), // 30天过期
    }

    err := s.db.Create(mail).Error
    if err != nil {
        logger.Errorf("Failed to send mail: %v", err)
        return nil, err
    }

    // 清除缓存
    s.cache.Del(ctx, fmt.Sprintf("mails:%d", receiverID))
    return mail, nil
}

func (s *MailService) GetMails(ctx context.Context, receiverID uint64) ([]*model.Mail, error) {
    // 先从缓存获取
    cacheKey := fmt.Sprintf("mails:%d", receiverID)
    var mails []*model.Mail
    if err := s.cache.Get(ctx, cacheKey, &mails); err == nil {
        return mails, nil
    }

    // 从数据库获取
    err := s.db.Where("receiverId = ?", receiverID).Find(&mails).Error
    if err != nil {
        logger.Errorf("Failed to query mails: %v", err)
        return nil, err
    }

    // 写入缓存
    s.cache.Set(ctx, cacheKey, mails, 5*time.Minute)
    return mails, nil
}
```

### 5. 性能优化

#### 5.1 连接池优化
```go
// 优化数据库连接池配置
sqlDB.SetMaxIdleConns(50)
sqlDB.SetMaxOpenConns(200)
sqlDB.SetConnMaxLifetime(2 * time.Hour)
sqlDB.SetConnMaxIdleTime(30 * time.Minute)
```

#### 5.2 消息批处理
```go
type MessageBatch struct {
    messages []proto.Message
    mu       sync.Mutex
}

func (b *MessageBatch) Add(msg proto.Message) {
    b.mu.Lock()
    defer b.mu.Unlock()
    b.messages = append(b.messages, msg)
}

func (b *MessageBatch) Flush() []proto.Message {
    b.mu.Lock()
    defer b.mu.Unlock()
    messages := b.messages
    b.messages = nil
    return messages
}
```

#### 5.3 异步处理
```go
func (s *Service) ProcessAsync(ctx context.Context, data interface{}) {
    go func() {
        if err := s.Process(ctx, data); err != nil {
            logger.Errorf("Failed to process: %v", err)
        }
    }()
}
```

## 实现步骤

### 步骤 1：集成 Redis
1. 添加 Redis 配置
2. 实现 Redis 客户端
3. 实现缓存封装

### 步骤 2：实现好友系统
1. 定义好友模型
2. 实现好友服务
3. 实现好友处理器
4. 注册消息路由

### 步骤 3：实现公会系统
1. 定义公会模型
2. 实现公会服务
3. 实现公会处理器
4. 注册消息路由

### 步骤 4：实现邮件系统
1. 定义邮件模型
2. 实现邮件服务
3. 实现邮件处理器
4. 注册消息路由

### 步骤 5：实现副本系统
1. 定义副本模型
2. 实现副本服务
3. 实现副本处理器
4. 注册消息路由

### 步骤 6：实现商城系统
1. 定义商城模型
2. 实现商城服务
3. 实现商城处理器
4. 注册消息路由

### 步骤 7：性能优化
1. 优化连接池配置
2. 实现消息批处理
3. 实现异步处理
4. 添加性能监控

## 关键决策

### 1. 为什么使用 Redis？
- 高性能的内存数据库
- 支持多种数据结构
- 支持数据持久化
- 支持主从复制

### 2. 为什么使用缓存？
- 减少数据库查询
- 提高响应速度
- 降低数据库负载

### 3. 为什么使用异步处理？
- 提高并发处理能力
- 降低响应延迟
- 提高系统吞吐量

## 验证方法

### 1. 功能验证
- 测试好友系统功能
- 测试公会系统功能
- 测试邮件系统功能
- 测试副本系统功能
- 测试商城系统功能

### 2. 性能验证
- 测试并发连接数
- 测试消息处理速度
- 测试响应时间
- 测试内存使用

### 3. 缓存验证
- 测试缓存命中率
- 测试缓存更新
- 测试缓存过期

## 阶段总结

本阶段完成了游戏的扩展功能实现和性能优化，包括：
- 好友系统实现
- 公会系统实现
- 邮件系统实现
- 副本系统实现
- 商城系统实现
- Redis 缓存集成
- 性能优化

这些扩展功能和性能优化大大提升了游戏的可玩性和系统性能。
