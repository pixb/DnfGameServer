# 阶段二：核心功能实现

## 目标

本阶段的目标是实现游戏的核心业务功能，包括登录认证、角色管理、背包系统、装备系统、技能系统等。这些功能是游戏的基础，为后续的扩展功能提供支持。

## 需求分析

### 1. 登录认证需求
- 支持多种登录方式（openid、token 等）
- 支持角色列表查询
- 支持角色创建
- 支持角色删除
- 支持角色选择进入游戏

### 2. 角色管理需求
- 支持角色数据存储
- 支持角色属性管理
- 支持角色状态管理
- 支持角色数据缓存

### 3. 背包系统需求
- 支持背包格子管理
- 支持道具获取
- 支持道具使用
- 支持道具丢弃
- 支持道具合成

### 4. 装备系统需求
- 支持装备穿戴
- 支持装备卸下
- 支持装备强化
- 支持装备附魔
- 支持装备镶嵌

### 5. 技能系统需求
- 支持技能学习
- 支持技能升级
- 支持技能遗忘
- 支持技能冷却
- 支持技能释放

## 技术方案

### 1. Protobuf 消息定义

#### 1.1 登录相关消息
```protobuf
// 登录请求
message LoginRequest {
    string openid = 1;
    uint32 type = 2;
    string token = 3;
    uint32 plat_id = 4;
    string client_ip = 5;
    string version = 6;
}

// 登录响应
message LoginResponse {
    uint32 result = 1;
    string message = 2;
    uint64 uid = 3;
}

// 角色列表请求
message CharacterListRequest {
    uint64 uid = 1;
}

// 角色列表响应
message CharacterListResponse {
    repeated CharacterInfo characters = 1;
}

// 角色信息
message CharacterInfo {
    uint64 role_id = 1;
    string name = 2;
    uint32 job = 3;
    uint32 level = 4;
}
```

#### 1.2 背包相关消息
```protobuf
// 背包信息请求
message BagInfoRequest {
    uint64 role_id = 1;
}

// 背包信息响应
message BagInfoResponse {
    repeated ItemInfo items = 1;
}

// 道具信息
message ItemInfo {
    uint64 item_id = 1;
    uint32 item_code = 2;
    uint32 count = 3;
}

// 道具使用请求
message ItemUseRequest {
    uint64 item_id = 1;
    uint32 count = 2;
}

// 道具使用响应
message ItemUseResponse {
    uint32 result = 1;
    string message = 2;
}
```

#### 1.3 装备相关消息
```protobuf
// 装备信息请求
message EquipInfoRequest {
    uint64 role_id = 1;
}

// 装备信息响应
message EquipInfoResponse {
    repeated EquipInfo equips = 1;
}

// 装备信息
message EquipInfo {
    uint64 equip_id = 1;
    uint32 equip_code = 2;
    uint32 slot = 3;
    uint32 level = 4;
}

// 装备穿戴请求
message EquipWearRequest {
    uint64 equip_id = 1;
    uint32 slot = 2;
}

// 装备穿戴响应
message EquipWearResponse {
    uint32 result = 1;
    string message = 2;
}
```

#### 1.4 技能相关消息
```protobuf
// 技能列表请求
message SkillListRequest {
    uint64 role_id = 1;
}

// 技能列表响应
message SkillListResponse {
    repeated SkillInfo skills = 1;
}

// 技能信息
message SkillInfo {
    uint32 skill_id = 1;
    uint32 level = 2;
}

// 技能学习请求
message SkillLearnRequest {
    uint32 skill_id = 1;
}

// 技能学习响应
message SkillLearnResponse {
    uint32 result = 1;
    string message = 2;
}
```

### 2. 数据模型设计

#### 2.1 角色模型
```go
package model

import (
    "time"
    "gorm.io/gorm"
)

type Role struct {
    ID         uint64    `gorm:"primaryKey;column:roleId" json:"role_id"`
    UID        uint64    `gorm:"column:uid" json:"uid"`
    Name       string    `gorm:"column:name;size:50" json:"name"`
    Job        uint32    `gorm:"column:job" json:"job"`
    Level      uint32    `gorm:"column:level" json:"level"`
    Exp        uint64    `gorm:"column:exp" json:"exp"`
    HP         uint32    `gorm:"column:hp" json:"hp"`
    MP         uint32    `gorm:"column:mp" json:"mp"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (Role) TableName() string {
    return "t_role"
}
```

#### 2.2 道具模型
```go
type Item struct {
    ID        uint64    `gorm:"primaryKey;column:itemId" json:"item_id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    ItemCode  uint32    `gorm:"column:itemCode" json:"item_code"`
    Count     uint32    `gorm:"column:count" json:"count"`
    Slot      uint32    `gorm:"column:slot" json:"slot"`
    BindType  uint32    `gorm:"column:bindType" json:"bind_type"`
    ExpireTime time.Time `gorm:"column:expireTime" json:"expire_time"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (Item) TableName() string {
    return "t_item"
}
```

#### 2.3 装备模型
```go
type Equip struct {
    ID        uint64    `gorm:"primaryKey;column:equipId" json:"equip_id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    EquipCode uint32    `gorm:"column:equipCode" json:"equip_code"`
    Slot      uint32    `gorm:"column:slot" json:"slot"`
    Level     uint32    `gorm:"column:level" json:"level"`
    Quality   uint32    `gorm:"column:quality" json:"quality"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (Equip) TableName() string {
    return "t_equip"
}
```

#### 2.4 技能模型
```go
type Skill struct {
    ID        uint64    `gorm:"primaryKey;column:skillId" json:"skill_id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    SkillID   uint32    `gorm:"column:skillId" json:"skill_id"`
    Level     uint32    `gorm:"column:level" json:"level"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (Skill) TableName() string {
    return "t_skill"
}
```

### 3. 业务服务设计

#### 3.1 登录服务
```go
package service

import (
    "context"
    "errors"

    "github.com/pixb/dnf-game-server/internal/common/db"
    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/pixb/dnf-game-server/internal/game/model"
    "gorm.io/gorm"
)

type LoginService struct {
    db *gorm.DB
}

func NewLoginService() *LoginService {
    return &LoginService{
        db: db.GetDB(),
    }
}

func (s *LoginService) Login(ctx context.Context, openid, token string) (*model.Account, error) {
    var account model.Account
    err := s.db.Where("openid = ?", openid).First(&account).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("account not found")
        }
        logger.Errorf("Failed to query account: %v", err)
        return nil, err
    }

    if account.Token != token {
        return nil, errors.New("invalid token")
    }

    return &account, nil
}

func (s *LoginService) GetCharacterList(ctx context.Context, uid uint64) ([]*model.Role, error) {
    var roles []*model.Role
    err := s.db.Where("uid = ?", uid).Find(&roles).Error
    if err != nil {
        logger.Errorf("Failed to query roles: %v", err)
        return nil, err
    }

    return roles, nil
}

func (s *LoginService) CreateCharacter(ctx context.Context, uid uint64, name string, job uint32) (*model.Role, error) {
    role := &model.Role{
        UID:   uid,
        Name:  name,
        Job:   job,
        Level: 1,
        HP:    1000,
        MP:    500,
    }

    err := s.db.Create(role).Error
    if err != nil {
        logger.Errorf("Failed to create role: %v", err)
        return nil, err
    }

    return role, nil
}

func (s *LoginService) DeleteCharacter(ctx context.Context, roleID uint64) error {
    err := s.db.Where("roleId = ?", roleID).Delete(&model.Role{}).Error
    if err != nil {
        logger.Errorf("Failed to delete role: %v", err)
        return err
    }

    return nil
}
```

#### 3.2 背包服务
```go
package service

import (
    "context"
    "errors"

    "github.com/pixb/dnf-game-server/internal/common/db"
    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/pixb/dnf-game-server/internal/game/model"
    "gorm.io/gorm"
)

type BagService struct {
    db *gorm.DB
}

func NewBagService() *BagService {
    return &BagService{
        db: db.GetDB(),
    }
}

func (s *BagService) GetBagInfo(ctx context.Context, roleID uint64) ([]*model.Item, error) {
    var items []*model.Item
    err := s.db.Where("roleId = ?", roleID).Find(&items).Error
    if err != nil {
        logger.Errorf("Failed to query items: %v", err)
        return nil, err
    }

    return items, nil
}

func (s *BagService) AddItem(ctx context.Context, roleID uint64, itemCode uint32, count uint32) (*model.Item, error) {
    item := &model.Item{
        RoleID:   roleID,
        ItemCode: itemCode,
        Count:    count,
    }

    err := s.db.Create(item).Error
    if err != nil {
        logger.Errorf("Failed to add item: %v", err)
        return nil, err
    }

    return item, nil
}

func (s *BagService) UseItem(ctx context.Context, roleID uint64, itemID uint64, count uint32) error {
    var item model.Item
    err := s.db.Where("itemId = ? AND roleId = ?", itemID, roleID).First(&item).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return errors.New("item not found")
        }
        logger.Errorf("Failed to query item: %v", err)
        return err
    }

    if item.Count < count {
        return errors.New("not enough items")
    }

    item.Count -= count
    if item.Count == 0 {
        err = s.db.Delete(&item).Error
    } else {
        err = s.db.Save(&item).Error
    }

    if err != nil {
        logger.Errorf("Failed to update item: %v", err)
        return err
    }

    return nil
}

func (s *BagService) DeleteItem(ctx context.Context, roleID uint64, itemID uint64) error {
    err := s.db.Where("itemId = ? AND roleId = ?", itemID, roleID).Delete(&model.Item{}).Error
    if err != nil {
        logger.Errorf("Failed to delete item: %v", err)
        return err
    }

    return nil
}
```

#### 3.3 装备服务
```go
package service

import (
    "context"
    "errors"

    "github.com/pixb/dnf-game-server/internal/common/db"
    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/pixb/dnf-game-server/internal/game/model"
    "gorm.io/gorm"
)

type EquipService struct {
    db *gorm.DB
}

func NewEquipService() *EquipService {
    return &EquipService{
        db: db.GetDB(),
    }
}

func (s *EquipService) GetEquipInfo(ctx context.Context, roleID uint64) ([]*model.Equip, error) {
    var equips []*model.Equip
    err := s.db.Where("roleId = ?", roleID).Find(&equips).Error
    if err != nil {
        logger.Errorf("Failed to query equips: %v", err)
        return nil, err
    }

    return equips, nil
}

func (s *EquipService) WearEquip(ctx context.Context, roleID uint64, equipID uint64, slot uint32) error {
    var equip model.Equip
    err := s.db.Where("equipId = ? AND roleId = ?", equipID, roleID).First(&equip).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return errors.New("equip not found")
        }
        logger.Errorf("Failed to query equip: %v", err)
        return err
    }

    equip.Slot = slot
    err = s.db.Save(&equip).Error
    if err != nil {
        logger.Errorf("Failed to update equip: %v", err)
        return err
    }

    return nil
}

func (s *EquipService) TakeOffEquip(ctx context.Context, roleID uint64, slot uint32) error {
    var equip model.Equip
    err := s.db.Where("roleId = ? AND slot = ?", roleID, slot).First(&equip).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return errors.New("equip not found")
        }
        logger.Errorf("Failed to query equip: %v", err)
        return err
    }

    equip.Slot = 0
    err = s.db.Save(&equip).Error
    if err != nil {
        logger.Errorf("Failed to update equip: %v", err)
        return err
    }

    return nil
}

func (s *EquipService) UpgradeEquip(ctx context.Context, roleID uint64, equipID uint64) error {
    var equip model.Equip
    err := s.db.Where("equipId = ? AND roleId = ?", equipID, roleID).First(&equip).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return errors.New("equip not found")
        }
        logger.Errorf("Failed to query equip: %v", err)
        return err
    }

    equip.Level++
    err = s.db.Save(&equip).Error
    if err != nil {
        logger.Errorf("Failed to update equip: %v", err)
        return err
    }

    return nil
}
```

#### 3.4 技能服务
```go
package service

import (
    "context"
    "errors"

    "github.com/pixb/dnf-game-server/internal/common/db"
    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/pixb/dnf-game-server/internal/game/model"
    "gorm.io/gorm"
)

type SkillService struct {
    db *gorm.DB
}

func NewSkillService() *SkillService {
    return &SkillService{
        db: db.GetDB(),
    }
}

func (s *SkillService) GetSkillList(ctx context.Context, roleID uint64) ([]*model.Skill, error) {
    var skills []*model.Skill
    err := s.db.Where("roleId = ?", roleID).Find(&skills).Error
    if err != nil {
        logger.Errorf("Failed to query skills: %v", err)
        return nil, err
    }

    return skills, nil
}

func (s *SkillService) LearnSkill(ctx context.Context, roleID uint64, skillID uint32) error {
    var skill model.Skill
    err := s.db.Where("roleId = ? AND skillId = ?", roleID, skillID).First(&skill).Error
    if err == nil {
        return errors.New("skill already learned")
    }

    if !errors.Is(err, gorm.ErrRecordNotFound) {
        logger.Errorf("Failed to query skill: %v", err)
        return err
    }

    skill = model.Skill{
        RoleID:  roleID,
        SkillID: skillID,
        Level:   1,
    }

    err = s.db.Create(&skill).Error
    if err != nil {
        logger.Errorf("Failed to learn skill: %v", err)
        return err
    }

    return nil
}

func (s *SkillService) UpgradeSkill(ctx context.Context, roleID uint64, skillID uint32) error {
    var skill model.Skill
    err := s.db.Where("roleId = ? AND skillId = ?", roleID, skillID).First(&skill).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return errors.New("skill not learned")
        }
        logger.Errorf("Failed to query skill: %v", err)
        return err
    }

    skill.Level++
    err = s.db.Save(&skill).Error
    if err != nil {
        logger.Errorf("Failed to upgrade skill: %v", err)
        return err
    }

    return nil
}

func (s *SkillService) ForgetSkill(ctx context.Context, roleID uint64, skillID uint32) error {
    err := s.db.Where("roleId = ? AND skillId = ?", roleID, skillID).Delete(&model.Skill{}).Error
    if err != nil {
        logger.Errorf("Failed to forget skill: %v", err)
        return err
    }

    return nil
}
```

### 4. 消息处理器设计

#### 4.1 登录处理器
```go
package handler

import (
    "context"

    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/pixb/dnf-game-server/internal/game/service"
    "github.com/pixb/dnf-game-server/internal/network/session"
    pb "github.com/pixb/dnf-game-server/pkg/protobuf"
    "google.golang.org/protobuf/proto"
)

type LoginHandler struct {
    loginService *service.LoginService
}

func NewLoginHandler() *LoginHandler {
    return &LoginHandler{
        loginService: service.NewLoginService(),
    }
}

func (h *LoginHandler) HandleLogin(sess *session.Session, msg proto.Message) {
    req, ok := msg.(*pb.LoginRequest)
    if !ok {
        logger.Errorf("Invalid message type")
        return
    }

    account, err := h.loginService.Login(context.Background(), req.Openid, req.Token)
    if err != nil {
        resp := &pb.LoginResponse{
            Result:  1,
            Message: err.Error(),
        }
        sess.Send(resp)
        return
    }

    sess.UserID = account.UID

    resp := &pb.LoginResponse{
        Result:  0,
        Message: "success",
        Uid:     account.UID,
    }
    sess.Send(resp)
}

func (h *LoginHandler) HandleCharacterList(sess *session.Session, msg proto.Message) {
    req, ok := msg.(*pb.CharacterListRequest)
    if !ok {
        logger.Errorf("Invalid message type")
        return
    }

    roles, err := h.loginService.GetCharacterList(context.Background(), req.Uid)
    if err != nil {
        logger.Errorf("Failed to get character list: %v", err)
        return
    }

    characterInfos := make([]*pb.CharacterInfo, 0, len(roles))
    for _, role := range roles {
        characterInfos = append(characterInfos, &pb.CharacterInfo{
            RoleId: role.ID,
            Name:   role.Name,
            Job:    role.Job,
            Level:  role.Level,
        })
    }

    resp := &pb.CharacterListResponse{
        Characters: characterInfos,
    }
    sess.Send(resp)
}
```

#### 4.2 背包处理器
```go
package handler

import (
    "context"

    "github.com/pixb/dnf-game-server/internal/common/logger"
    "github.com/pixb/dnf-game-server/internal/game/service"
    "github.com/pixb/dnf-game-server/internal/network/session"
    pb "github.com/pixb/dnf-game-server/pkg/protobuf"
    "google.golang.org/protobuf/proto"
)

type BagHandler struct {
    bagService *service.BagService
}

func NewBagHandler() *BagHandler {
    return &BagHandler{
        bagService: service.NewBagService(),
    }
}

func (h *BagHandler) HandleBagInfo(sess *session.Session, msg proto.Message) {
    req, ok := msg.(*pb.BagInfoRequest)
    if !ok {
        logger.Errorf("Invalid message type")
        return
    }

    items, err := h.bagService.GetBagInfo(context.Background(), req.RoleId)
    if err != nil {
        logger.Errorf("Failed to get bag info: %v", err)
        return
    }

    itemInfos := make([]*pb.ItemInfo, 0, len(items))
    for _, item := range items {
        itemInfos = append(itemInfos, &pb.ItemInfo{
            ItemId:   item.ID,
            ItemCode: item.ItemCode,
            Count:    item.Count,
        })
    }

    resp := &pb.BagInfoResponse{
        Items: itemInfos,
    }
    sess.Send(resp)
}

func (h *BagHandler) HandleItemUse(sess *session.Session, msg proto.Message) {
    req, ok := msg.(*pb.ItemUseRequest)
    if !ok {
        logger.Errorf("Invalid message type")
        return
    }

    err := h.bagService.UseItem(context.Background(), sess.UserID, req.ItemId, req.Count)
    if err != nil {
        resp := &pb.ItemUseResponse{
            Result:  1,
            Message: err.Error(),
        }
        sess.Send(resp)
        return
    }

    resp := &pb.ItemUseResponse{
        Result:  0,
        Message: "success",
    }
    sess.Send(resp)
}
```

## 实现步骤

### 步骤 1：定义 Protobuf 消息
1. 创建 `proto/dnf/login.proto` 文件
2. 创建 `proto/dnf/bag.proto` 文件
3. 创建 `proto/dnf/equip.proto` 文件
4. 创建 `proto/dnf/skill.proto` 文件
5. 使用 protoc 生成 Go 代码

### 步骤 2：实现数据模型
1. 创建 `internal/game/model/role.go` 文件
2. 创建 `internal/game/model/item.go` 文件
3. 创建 `internal/game/model/equip.go` 文件
4. 创建 `internal/game/model/skill.go` 文件

### 步骤 3：实现业务服务
1. 创建 `internal/game/service/login_service.go` 文件
2. 创建 `internal/game/service/bag_service.go` 文件
3. 创建 `internal/game/service/equip_service.go` 文件
4. 创建 `internal/game/service/skill_service.go` 文件

### 步骤 4：实现消息处理器
1. 创建 `internal/game/handler/login_handler.go` 文件
2. 创建 `internal/game/handler/bag_handler.go` 文件
3. 创建 `internal/game/handler/equip_handler.go` 文件
4. 创建 `internal/game/handler/skill_handler.go` 文件

### 步骤 5：注册消息处理器
1. 修改 `internal/network/server.go` 文件
2. 注册所有消息处理器
3. 实现消息路由

### 步骤 6：测试功能
1. 编译项目
2. 运行服务器
3. 使用客户端测试各个功能

## 关键决策

### 1. 为什么使用 Protobuf？
- 高效的二进制协议
- 与 Java 版本保持一致
- 支持跨语言通信

### 2. 为什么使用 GORM？
- Go 最流行的 ORM 框架
- 功能完善，文档丰富
- 与 Java 版本的 NutZ 类似

### 3. 为什么使用 Service 层？
- 分离业务逻辑
- 提高代码复用性
- 便于单元测试

### 4. 为什么使用 Handler 层？
- 分离消息处理逻辑
- 提高代码可读性
- 便于消息路由

## 验证方法

### 1. 编译验证
```bash
go build -o bin/server cmd/server/main.go
```

### 2. 运行验证
```bash
./bin/server
```

### 3. 功能验证
使用客户端测试各个功能：
- 登录功能
- 角色列表查询
- 角色创建
- 背包查询
- 道具使用
- 装备穿戴
- 技能学习

### 4. 日志验证
检查日志文件中的功能日志：
```bash
tail -f logs/server.log
```

## 阶段总结

本阶段完成了游戏核心功能的实现，包括：
- 登录认证功能
- 角色管理功能
- 背包系统功能
- 装备系统功能
- 技能系统功能

这些核心功能为后续的扩展功能提供了坚实的基础。
