# 拍卖系统设计文档

## 文档导航

本系统文档已拆分为以下子文档，便于维护和查阅：

- [系统概述.md](12_拍卖系统/系统概述.md) - 系统简介、核心功能、设计目标
- [Java代码分析.md](12_拍卖系统/Java代码分析.md) - Java服务端拍卖系统代码分析
- [Go实现方案.md](12_拍卖系统/Go实现方案.md) - Go服务端实现设计
- [API文档.md](12_拍卖系统/API文档.md) - HTTP和gRPC接口定义
- [数据库设计文档.md](12_拍卖系统/数据库设计文档.md) - 数据库表结构设计
- [业务流程文档.md](12_拍卖系统/业务流程文档.md) - 核心业务流程说明
- [测试用例文档.md](12_拍卖系统/测试用例文档.md) - 测试用例和测试策略
- [部署文档.md](12_拍卖系统/部署文档.md) - 系统部署和配置说明
- [监控与维护.md](12_拍卖系统/监控与维护.md) - 系统监控和日常维护
- [变更记录.md](12_拍卖系统/变更记录.md) - 系统变更历史记录

## 概述

拍卖系统是游戏中的重要交易功能，用于玩家之间进行物品拍卖交易，包括装备拍卖和堆叠物品拍卖，支持一口价购买和竞价购买。

## Java 代码分析

### 核心控制器
- **文件位置**: `src/main/java/com/dnfm/game/auction/AuctionController.java`
- **处理器数量**: 8 个 @RequestMapping 方法

### 核心功能

#### 1. 查询我的注册物品列表 (REQ_AUCTION_MY_REGISTERED_ITEM_LIST)
- **方法**: `REQ_AUCTION_MY_REGISTERED_ITEM_LIST(IoSession session, REQ_AUCTION_MY_REGISTERED_ITEM_LIST req_auction_my_registered_item_list)`
- **功能**:
  - 查询当前玩家注册的拍卖物品
  - 处理到期物品（返还或发送邮件）
  - 返回装备和堆叠物品列表

#### 2. 查询分类物品列表 (REQ_AUCTION_CATEGORY_ITEM_LIST)
- **方法**: `REQ_AUCTION_CATEGORY_ITEM_LIST(IoSession session, REQ_AUCTION_CATEGORY_ITEM_LIST req_auction_category_item_list)`
- **功能**:
  - 查询指定分类下的物品列表
  - 返回分类下的所有物品

#### 3. 查询物品价格列表 (REQ_AUCTION_ITEM_PRICE_LIST)
- **方法**: `REQ_AUCTION_ITEM_PRICE_LIST(IoSession session, REQ_AUCTION_ITEM_PRICE_LIST req_auction_item_price_list)`
- **功能**:
  - 查询指定物品的价格列表
  - 返回不同价格段的数量

#### 4. 一口价购买 (REQ_AUCTION_BUY_AT_ONCE)
- **方法**: `REQ_AUCTION_BUY_AT_ONCE(IoSession session, REQ_AUCTION_BUY_AT_ONCE req_auction_buy_at_once)`
- **功能**:
  - 以一口价购买拍卖物品
  - 扣除玩家泰拉
  - 通过邮件发送物品
  - 记录购买信息

#### 5. 查询物品平均价格 (REQ_ITEM_AVR_PRICE)
- **方法**: `REQ_ITEM_AVR_PRICE(IoSession session, REQ_ITEM_AVR_PRICE req_item_avr_price)`
- **功能**:
  - 查询物品的平均价格
  - 返回价格列表和平均价格

#### 6. 注册拍卖物品 (REQ_AUCTION_REGISTER_ITEM)
- **方法**: `REQ_AUCTION_REGISTER_ITEM(IoSession session, REQ_AUCTION_REGISTER_ITEM req_auction_register_item)`
- **功能**:
  - 注册物品到拍卖行
  - 扣除玩家物品
  - 设置拍卖价格和到期时间
  - 支持装备和堆叠物品

#### 7. 取消注册 (REQ_AUCTION_REGISTER_CANCEL)
- **方法**: `REQ_AUCTION_REGISTER_CANCEL(IoSession session, REQ_AUCTION_REGISTER_CANCEL req_auction_register_cancel)`
- **功能**:
  - 取消已注册的拍卖物品
  - 返还物品或已售出的泰拉
  - 通过邮件发送

#### 8. 完成注册 (REQ_AUCTION_REGISTER_COMPLETE)
- **方法**: `REQ_AUCTION_REGISTER_COMPLETE(IoSession session, REQ_AUCTION_REGISTER_COMPLETE req_auction_register_complete)`
- **功能**:
  - 完成拍卖注册
  - 处理拍卖结果

#### 9. 查询拍卖历史 (REQ_AUCTION_HISTORY)
- **方法**: `REQ_AUCTION_HISTORY(IoSession session, REQ_AUCTION_HISTORY req_auction_history)`
- **功能**:
  - 查询拍卖历史记录
  - 返回历史交易信息

## Go 实现方案

### 1. ProtoBuf 消息定义

#### auction.proto
```protobuf
syntax = "proto3";

package dnf.v1;

option go_package = "gen/dnf/v1";

import "dnf/v1/common.proto";

// 拍卖装备信息
message AuctionEquip {
    uint64 auid = 1;
    uint64 charguid = 2;
    uint64 guid = 3;
    uint32 index = 4;
    uint32 count = 5;
    uint32 type = 6;
    uint64 price = 7;
    uint64 buyprice = 8;
    uint32 registcount = 9;
    uint64 enddate = 10;
    uint64 tera = 11;
}

// 拍卖堆叠物品信息
message AuctionStackable {
    uint64 auid = 1;
    uint64 charguid = 2;
    uint32 index = 3;
    uint32 count = 4;
    uint32 type = 6;
    uint64 price = 7;
    uint64 buyprice = 8;
    uint32 registcount = 9;
    uint64 enddate = 10;
    uint64 tera = 11;
}

// 拍卖物品索引
message AuctionItemIndex {
    uint32 index = 1;
    uint32 qty = 2;
}

// 拍卖物品价格信息
message AuctionItemPriceInfo {
    uint64 price = 1;
    uint32 count = 2;
}

// 查询我的注册物品列表请求
message AuctionMyRegisteredItemListRequest {
    uint32 transid = 1;
}

// 查询我的注册物品列表响应
message AuctionMyRegisteredItemListResponse {
    repeated AuctionEquip equip = 1;
    repeated AuctionStackable stackable = 2;
    uint32 transid = 3;
    uint32 error = 4;
    string message = 5;
}

// 查询分类物品列表请求
message AuctionCategoryItemListRequest {
    uint32 category = 1;
    uint32 transid = 2;
}

// 查询分类物品列表响应
message AuctionCategoryItemListResponse {
    uint32 category = 1;
    repeated AuctionItemIndex item = 2;
    uint32 transid = 3;
    uint32 error = 4;
    string message = 5;
}

// 查询物品价格列表请求
message AuctionItemPriceListRequest {
    uint32 category = 1;
    uint32 index = 2;
    uint32 transid = 3;
}

// 查询物品价格列表响应
message AuctionItemPriceListResponse {
    uint32 category = 1;
    uint32 index = 2;
    repeated AuctionItemPriceInfo list = 3;
    uint32 transid = 4;
    uint32 error = 5;
    string message = 6;
}

// 一口价购买请求
message AuctionBuyAtOnceRequest {
    uint32 category = 1;
    uint32 index = 2;
    uint64 price = 3;
    uint32 qty = 4;
    uint32 transid = 5;
}

// 一口价购买响应
message AuctionBuyAtOnceResponse {
    uint32 category = 1;
    uint32 index = 2;
    repeated AuctionItemIndex categoryitemlist = 3;
    repeated AuctionItemPriceInfo itempricelist = 4;
    uint32 transid = 5;
    uint32 error = 6;
    string message = 7;
}

// 查询物品平均价格请求
message ItemAvrPriceRequest {
    uint32 index = 1;
    uint32 transid = 2;
}

// 查询物品平均价格响应
message ItemAvrPriceResponse {
    uint32 index = 1;
    uint32 price = 2;
    repeated uint32 prices = 3;
    uint32 transid = 4;
    uint32 error = 5;
    string message = 6;
}

// 注册拍卖物品请求
message AuctionRegisterItemRequest {
    uint32 tab = 1;
    uint32 index = 2;
    uint32 qty = 3;
    uint64 price = 4;
    uint64 guid = 5;
    uint32 transid = 6;
}

// 注册拍卖物品响应
message AuctionRegisterItemResponse {
    uint32 tab = 1;
    uint32 index = 2;
    uint32 qty = 3;
    repeated AuctionEquip equip = 4;
    repeated AuctionStackable stackable = 5;
    uint32 transid = 6;
    uint32 error = 7;
    string message = 8;
}

// 取消注册请求
message AuctionRegisterCancelRequest {
    uint32 category = 1;
    uint64 auid = 2;
    uint32 transid = 3;
}

// 取消注册响应
message AuctionRegisterCancelResponse {
    uint32 category = 1;
    uint64 auid = 2;
    uint32 transid = 3;
    uint32 error = 4;
    string message = 5;
}

// 完成注册请求
message AuctionRegisterCompleteRequest {
    uint32 tab = 1;
    uint32 index = 2;
    uint32 qty = 3;
    uint64 price = 4;
    uint64 guid = 5;
    uint32 transid = 6;
}

// 完成注册响应
message AuctionRegisterCompleteResponse {
    uint32 tab = 1;
    uint32 index = 2;
    uint32 qty = 3;
    uint32 transid = 4;
    uint32 error = 5;
    string message = 6;
}

// 查询拍卖历史请求
message AuctionHistoryRequest {
    uint32 transid = 1;
}

// 查询拍卖历史响应
message AuctionHistoryResponse {
    repeated AuctionEquip equip = 1;
    repeated AuctionStackable stackable = 2;
    uint32 transid = 3;
    uint32 error = 4;
    string message = 5;
}
```

### 2. 数据模型设计

#### models/auction.go
```go
package models

import (
    "time"
    "gorm.io/gorm"
)

// AuctionEquip 拍卖装备
type AuctionEquip struct {
    AUID        uint64    `gorm:"primaryKey;column:auid" json:"auid"`
    CharGUID    uint64    `gorm:"column:charguid;index" json:"charguid"`
    GUID        uint64    `gorm:"column:guid;uniqueIndex" json:"guid"`
    Index       uint32    `gorm:"column:index;index" json:"index"`
    Count       uint32    `gorm:"column:count" json:"count"`
    Type        uint32    `gorm:"column:type" json:"type"`
    Price       uint64    `gorm:"column:price;index" json:"price"`
    BuyPrice    uint64    `gorm:"column:buyprice" json:"buyprice"`
    RegistCount uint32    `gorm:"column:registcount" json:"registcount"`
    EndDate     time.Time `gorm:"column:enddate;index" json:"enddate"`
    Tera        uint64    `gorm:"column:tera" json:"tera"`
    CreateTime  time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime  time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (AuctionEquip) TableName() string {
    return "t_auction_equip"
}

// AuctionStackable 拍卖堆叠物品
type AuctionStackable struct {
    AUID        uint64    `gorm:"primaryKey;column:auid" json:"auid"`
    CharGUID    uint64    `gorm:"column:charguid;index" json:"charguid"`
    Index       uint32    `gorm:"column:index;index" json:"index"`
    Count       uint32    `gorm:"column:count" json:"count"`
    Type        uint32    `gorm:"column:type" json:"type"`
    Price       uint64    `gorm:"column:price;index" json:"price"`
    BuyPrice    uint64    `gorm:"column:buyprice" json:"buyprice"`
    RegistCount uint32    `gorm:"column:registcount" json:"registcount"`
    EndDate     time.Time `gorm:"column:enddate;index" json:"enddate"`
    Tera        uint64    `gorm:"column:tera" json:"tera"`
    CreateTime  time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime  time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (AuctionStackable) TableName() string {
    return "t_auction_stackable"
}

// AuctionBuyRecord 拍卖购买记录
type AuctionBuyRecord struct {
    ID         uint64    `gorm:"primaryKey;column:id" json:"id"`
    BuyerGUID  uint64    `gorm:"column:buyerGuid;index" json:"buyer_guid"`
    SellerGUID uint64    `gorm:"column:sellerGuid;index" json:"seller_guid"`
    AUID       uint64    `gorm:"column:auid;index" json:"auid"`
    Index      uint32    `gorm:"column:index" json:"index"`
    Count      uint32    `gorm:"column:count" json:"count"`
    Price      uint64    `gorm:"column:price" json:"price"`
    TotalPrice uint64    `gorm:"column:totalprice" json:"totalprice"`
    BuyTime    time.Time `gorm:"column:buyTime;index" json:"buy_time"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (AuctionBuyRecord) TableName() string {
    return "t_auction_buy_record"
}

// AuctionCategory 拍卖分类
type AuctionCategory struct {
    ID          uint64    `gorm:"primaryKey;column:id" json:"id"`
    Category    uint32    `gorm:"column:category;uniqueIndex" json:"category"`
    Name        string    `gorm:"column:name;size:50" json:"name"`
    Type        uint32    `gorm:"column:type" json:"type"`
    Sort        uint32    `gorm:"column:sort" json:"sort"`
    Status      uint32    `gorm:"column:status;default:1" json:"status"`
    CreateTime  time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime  time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (AuctionCategory) TableName() string {
    return "t_auction_category"
}

// AuctionPriceHistory 拍卖价格历史
type AuctionPriceHistory struct {
    ID         uint64    `gorm:"primaryKey;column:id" json:"id"`
    Index      uint32    `gorm:"column:index;index:idx_index_time" json:"index"`
    Price      uint64    `gorm:"column:price" json:"price"`
    Count      uint32    `gorm:"column:count" json:"count"`
    RecordTime time.Time `gorm:"column:recordTime;index:idx_index_time" json:"record_time"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (AuctionPriceHistory) TableName() string {
    return "t_auction_price_history"
}
```

### 3. Handler 实现

#### handlers/auction.go
```go
package handlers

import (
    "context"

    "github.com/pixb/DnfGameServer/dnf-go-server/internal/game/auction_service"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/network"
    dnfv1 "github.com/pixb/DnfGameServer/dnf-go-server/proto/gen/dnf/v1"
    "google.golang.org/protobuf/proto"
)

type AuctionHandler struct {
    auctionService *auction_service.AuctionService
}

func NewAuctionHandler(auctionService *auction_service.AuctionService) *AuctionHandler {
    return &AuctionHandler{
        auctionService: auctionService,
    }
}

// AuctionMyRegisteredItemListHandler 查询我的注册物品列表处理器
func (h *AuctionHandler) AuctionMyRegisteredItemListHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.AuctionMyRegisteredItemListRequest)
    if !ok {
        return
    }

    equipList, stackableList, err := h.auctionService.GetMyRegisteredItems(context.Background(), sess.RoleID)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get my registered items")
        return
    }

    resp := &dnfv1.AuctionMyRegisteredItemListResponse{
        Equip:      equipList,
        Stackable:  stackableList,
        Transid:    req.Transid,
        Error:      0,
    }
    sess.Send(resp)
}

// AuctionCategoryItemListHandler 查询分类物品列表处理器
func (h *AuctionHandler) AuctionCategoryItemListHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.AuctionCategoryItemListRequest)
    if !ok {
        return
    }

    itemList, err := h.auctionService.GetCategoryItems(context.Background(), req.Category)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get category items")
        return
    }

    resp := &dnfv1.AuctionCategoryItemListResponse{
        Category:   req.Category,
        Item:       itemList,
        Transid:    req.Transid,
        Error:      0,
    }
    sess.Send(resp)
}

// AuctionItemPriceListHandler 查询物品价格列表处理器
func (h *AuctionHandler) AuctionItemPriceListHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.AuctionItemPriceListRequest)
    if !ok {
        return
    }

    priceList, err := h.auctionService.GetItemPriceList(context.Background(), req.Category, req.Index)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get item price list")
        return
    }

    resp := &dnfv1.AuctionItemPriceListResponse{
        Category:   req.Category,
        Index:      req.Index,
        List:       priceList,
        Transid:    req.Transid,
        Error:      0,
    }
    sess.Send(resp)
}

// AuctionBuyAtOnceHandler 一口价购买处理器
func (h *AuctionHandler) AuctionBuyAtOnceHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.AuctionBuyAtOnceRequest)
    if !ok {
        return
    }

    itemList, priceList, err := h.auctionService.BuyAtOnce(context.Background(), sess.RoleID, req.Category, req.Index, req.Price, req.Qty)
    if err != nil {
        h.sendError(sess, req, 3, "failed to buy at once")
        return
    }

    resp := &dnfv1.AuctionBuyAtOnceResponse{
        Category:        req.Category,
        Index:           req.Index,
        Categoryitemlist: itemList,
        Itempricelist:   priceList,
        Transid:         req.Transid,
        Error:           0,
    }
    sess.Send(resp)
}

// ItemAvrPriceHandler 查询物品平均价格处理器
func (h *AuctionHandler) ItemAvrPriceHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.ItemAvrPriceRequest)
    if !ok {
        return
    }

    avrPrice, prices, err := h.auctionService.GetItemAvrPrice(context.Background(), req.Index)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get item average price")
        return
    }

    resp := &dnfv1.ItemAvrPriceResponse{
        Index:   req.Index,
        Price:   avrPrice,
        Prices:  prices,
        Transid: req.Transid,
        Error:   0,
    }
    sess.Send(resp)
}

// AuctionRegisterItemHandler 注册拍卖物品处理器
func (h *AuctionHandler) AuctionRegisterItemHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.AuctionRegisterItemRequest)
    if !ok {
        return
    }

    equip, stackable, err := h.auctionService.RegisterItem(context.Background(), sess.RoleID, req.Tab, req.Index, req.Qty, req.Price, req.Guid)
    if err != nil {
        h.sendError(sess, req, 1, "failed to register item")
        return
    }

    resp := &dnfv1.AuctionRegisterItemResponse{
        Tab:       req.Tab,
        Index:     req.Index,
        Qty:       req.Qty,
        Equip:     equip,
        Stackable: stackable,
        Transid:   req.Transid,
        Error:     0,
    }
    sess.Send(resp)
}

// AuctionRegisterCancelHandler 取消注册处理器
func (h *AuctionHandler) AuctionRegisterCancelHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.AuctionRegisterCancelRequest)
    if !ok {
        return
    }

    err := h.auctionService.CancelRegister(context.Background(), sess.RoleID, req.Category, req.Auid)
    if err != nil {
        h.sendError(sess, req, 1, "failed to cancel register")
        return
    }

    resp := &dnfv1.AuctionRegisterCancelResponse{
        Category: req.Category,
        Auid:     req.Auid,
        Transid:  req.Transid,
        Error:    0,
    }
    sess.Send(resp)
}

// AuctionRegisterCompleteHandler 完成注册处理器
func (h *AuctionHandler) AuctionRegisterCompleteHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.AuctionRegisterCompleteRequest)
    if !ok {
        return
    }

    err := h.auctionService.CompleteRegister(context.Background(), sess.RoleID, req.Tab, req.Index, req.Qty, req.Price, req.Guid)
    if err != nil {
        h.sendError(sess, req, 1, "failed to complete register")
        return
    }

    resp := &dnfv1.AuctionRegisterCompleteResponse{
        Tab:     req.Tab,
        Index:   req.Index,
        Qty:     req.Qty,
        Transid: req.Transid,
        Error:   0,
    }
    sess.Send(resp)
}

// AuctionHistoryHandler 查询拍卖历史处理器
func (h *AuctionHandler) AuctionHistoryHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.AuctionHistoryRequest)
    if !ok {
        return
    }

    equipList, stackableList, err := h.auctionService.GetAuctionHistory(context.Background(), sess.RoleID)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get auction history")
        return
    }

    resp := &dnfv1.AuctionHistoryResponse{
        Equip:     equipList,
        Stackable: stackableList,
        Transid:   req.Transid,
        Error:     0,
    }
    sess.Send(resp)
}

func (h *AuctionHandler) sendError(sess *network.Session, req proto.Message, code uint32, message string) {
    switch req.(type) {
    case *dnfv1.AuctionMyRegisteredItemListRequest:
        resp := &dnfv1.AuctionMyRegisteredItemListResponse{
            Transid: req.(*dnfv1.AuctionMyRegisteredItemListRequest).Transid,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.AuctionCategoryItemListRequest:
        resp := &dnfv1.AuctionCategoryItemListResponse{
            Transid: req.(*dnfv1.AuctionCategoryItemListRequest).Transid,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.AuctionItemPriceListRequest:
        resp := &dnfv1.AuctionItemPriceListResponse{
            Transid: req.(*dnfv1.AuctionItemPriceListRequest).Transid,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.AuctionBuyAtOnceRequest:
        resp := &dnfv1.AuctionBuyAtOnceResponse{
            Transid: req.(*dnfv1.AuctionBuyAtOnceRequest).Transid,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.ItemAvrPriceRequest:
        resp := &dnfv1.ItemAvrPriceResponse{
            Transid: req.(*dnfv1.ItemAvrPriceRequest).Transid,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.AuctionRegisterItemRequest:
        resp := &dnfv1.AuctionRegisterItemResponse{
            Transid: req.(*dnfv1.AuctionRegisterItemRequest).Transid,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.AuctionRegisterCancelRequest:
        resp := &dnfv1.AuctionRegisterCancelResponse{
            Transid: req.(*dnfv1.AuctionRegisterCancelRequest).Transid,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.AuctionRegisterCompleteRequest:
        resp := &dnfv1.AuctionRegisterCompleteResponse{
            Transid: req.(*dnfv1.AuctionRegisterCompleteRequest).Transid,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.AuctionHistoryRequest:
        resp := &dnfv1.AuctionHistoryResponse{
            Transid: req.(*dnfv1.AuctionHistoryRequest).Transid,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    }
}
```

### 4. Service 实现

#### auction_service/auction.go
```go
package auction_service

import (
    "context"
    "time"

    "github.com/pixb/DnfGameServer/dnf-go-server/store"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/db/models"
    dnfv1 "github.com/pixb/DnfGameServer/dnf-go-server/proto/gen/dnf/v1"
)

type AuctionService struct {
    store *store.Store
}

func NewAuctionService(store *store.Store) *AuctionService {
    return &AuctionService{
        store: store,
    }
}

// GetMyRegisteredItems 获取我的注册物品
func (s *AuctionService) GetMyRegisteredItems(ctx context.Context, roleID uint64) ([]*dnfv1.AuctionEquip, []*dnfv1.AuctionStackable, error) {
    now := time.Now()

    // 1. 获取装备列表
    equipList, err := s.store.GetAuctionEquipsByCharGUID(ctx, roleID)
    if err != nil {
        return nil, nil, err
    }

    // 2. 处理到期装备
    for _, equip := range equipList {
        if now.After(equip.EndDate) {
            s.handleExpiredEquip(ctx, equip)
        }
    }

    // 3. 获取堆叠物品列表
    stackableList, err := s.store.GetAuctionStackablesByCharGUID(ctx, roleID)
    if err != nil {
        return nil, nil, err
    }

    // 4. 处理到期堆叠物品
    for _, stackable := range stackableList {
        if now.After(stackable.EndDate) {
            s.handleExpiredStackable(ctx, stackable)
        }
    }

    // 5. 转换为响应格式
    pbEquipList := make([]*dnfv1.AuctionEquip, 0, len(equipList))
    for _, equip := range equipList {
        pbEquipList = append(pbEquipList, &dnfv1.AuctionEquip{
            Auid:        equip.AUID,
            Charguid:    equip.CharGUID,
            Guid:        equip.GUID,
            Index:       equip.Index,
            Count:       equip.Count,
            Type:        equip.Type,
            Price:       equip.Price,
            Buyprice:    equip.BuyPrice,
            Registcount: equip.RegistCount,
            Enddate:     uint64(equip.EndDate.Unix()),
            Tera:        equip.Tera,
        })
    }

    pbStackableList := make([]*dnfv1.AuctionStackable, 0, len(stackableList))
    for _, stackable := range stackableList {
        pbStackableList = append(pbStackableList, &dnfv1.AuctionStackable{
            Auid:        stackable.AUID,
            Charguid:    stackable.CharGUID,
            Index:       stackable.Index,
            Count:       stackable.Count,
            Type:        stackable.Type,
            Price:       stackable.Price,
            Buyprice:    stackable.BuyPrice,
            Registcount: stackable.RegistCount,
            Enddate:     uint64(stackable.EndDate.Unix()),
            Tera:        stackable.Tera,
        })
    }

    return pbEquipList, pbStackableList, nil
}

// GetCategoryItems 获取分类物品
func (s *AuctionService) GetCategoryItems(ctx context.Context, category uint32) ([]*dnfv1.AuctionItemIndex, error) {
    categoryInfo, err := s.store.GetAuctionCategory(ctx, category)
    if err != nil {
        return nil, err
    }

    var items []*dnfv1.AuctionItemIndex

    if categoryInfo.Type == 1 {
        stackables, err := s.store.GetAuctionStackablesByCategory(ctx, category)
        if err != nil {
            return nil, err
        }

        for _, stackable := range stackables {
            items = append(items, &dnfv1.AuctionItemIndex{
                Index: stackable.Index,
                Qty:   stackable.Count,
            })
        }
    } else {
        equips, err := s.store.GetAuctionEquipsByCategory(ctx, category)
        if err != nil {
            return nil, err
        }

        for _, equip := range equips {
            items = append(items, &dnfv1.AuctionItemIndex{
                Index: equip.Index,
                Qty:   equip.Count,
            })
        }
    }

    return items, nil
}

// GetItemPriceList 获取物品价格列表
func (s *AuctionService) GetItemPriceList(ctx context.Context, category uint32, index uint32) ([]*dnfv1.AuctionItemPriceInfo, error) {
    categoryInfo, err := s.store.GetAuctionCategory(ctx, category)
    if err != nil {
        return nil, err
    }

    var priceList []*dnfv1.AuctionItemPriceInfo

    if categoryInfo.Type == 1 {
        prices, err := s.store.GetAuctionStackablePriceList(ctx, index)
        if err != nil {
            return nil, err
        }

        for price, count := range prices {
            priceList = append(priceList, &dnfv1.AuctionItemPriceInfo{
                Price: price,
                Count: count,
            })
        }
    } else {
        prices, err := s.store.GetAuctionEquipPriceList(ctx, index)
        if err != nil {
            return nil, err
        }

        for price, count := range prices {
            priceList = append(priceList, &dnfv1.AuctionItemPriceInfo{
                Price: price,
                Count: count,
            })
        }
    }

    return priceList, nil
}

// BuyAtOnce 一口价购买
func (s *AuctionService) BuyAtOnce(ctx context.Context, roleID uint64, category uint32, index uint32, price uint64, qty uint32) ([]*dnfv1.AuctionItemIndex, []*dnfv1.AuctionItemPriceInfo, error) {
    // 1. 检查玩家泰拉余额
    totalTera := price * uint64(qty)
    account, err := s.store.GetAccountByRoleID(ctx, roleID)
    if err != nil {
        return nil, nil, err
    }

    moneyBox, err := s.store.GetAccountMoneyBox(ctx, account.ID)
    if err != nil {
        return nil, nil, err
    }

    if moneyBox.TylorCnt < totalTera {
        return nil, nil, store.ErrInsufficientBalance
    }

    // 2. 获取分类信息
    categoryInfo, err := s.store.GetAuctionCategory(ctx, category)
    if err != nil {
        return nil, nil, err
    }

    // 3. 购买物品
    if categoryInfo.Type == 1 {
        err = s.buyStackable(ctx, roleID, index, price, qty)
    } else {
        err = s.buyEquip(ctx, roleID, index, price, qty)
    }

    if err != nil {
        return nil, nil, err
    }

    // 4. 扣除泰拉
    err = s.store.SubMoney(ctx, moneyBox.ID, 2013000001, totalTera)
    if err != nil {
        return nil, nil, err
    }

    // 5. 发送邮件
    role, err := s.store.GetRole(ctx, roleID)
    if err != nil {
        return nil, nil, err
    }

    err = s.store.SendMail(ctx, roleID, "拍卖行购买物品成功", "恭喜您在拍卖行购买物品成功-点击领取", []*models.MailItem{
        {
            Index: index,
            Count: qty,
        },
    })
    if err != nil {
        return nil, nil, err
    }

    // 6. 记录购买信息
    enddate := time.Now().Add(24 * time.Hour)
    if categoryInfo.Type == 1 {
        err = s.store.AddAuctionStackableBuy(ctx, roleID, price, enddate, qty, price, index, qty)
    } else {
        err = s.store.AddAuctionEquipBuy(ctx, roleID, price, enddate, qty, price, index, qty)
    }

    if err != nil {
        return nil, nil, err
    }

    // 7. 返回更新后的列表
    itemList, err := s.GetCategoryItems(ctx, category)
    if err != nil {
        return nil, nil, err
    }

    priceList, err := s.GetItemPriceList(ctx, category, index)
    if err != nil {
        return nil, nil, err
    }

    return itemList, priceList, nil
}

// GetItemAvrPrice 获取物品平均价格
func (s *AuctionService) GetItemAvrPrice(ctx context.Context, index uint32) (uint32, []uint32, error) {
    prices, err := s.store.GetAuctionPriceHistory(ctx, index)
    if err != nil {
        return 0, nil, err
    }

    if len(prices) == 0 {
        return 0, []uint32{}, nil
    }

    var total uint64
    for _, price := range prices {
        total += uint64(price.Price)
    }

    avrPrice := uint32(total / uint64(len(prices)))
    priceList := make([]uint32, len(prices))
    for i, price := range prices {
        priceList[i] = price.Price
    }

    return avrPrice, priceList, nil
}

// RegisterItem 注册拍卖物品
func (s *AuctionService) RegisterItem(ctx context.Context, roleID uint64, tab uint32, index uint32, qty uint32, price uint64, guid uint64) ([]*dnfv1.AuctionEquip, []*dnfv1.AuctionStackable, error) {
    enddate := time.Now().Add(24 * time.Hour)

    if guid == 0 {
        // 堆叠物品
        auid := s.store.GenerateID(ctx)

        stackable := &models.AuctionStackable{
            AUID:        auid,
            CharGUID:    roleID,
            Index:       index,
            Count:       qty,
            Type:        1,
            Price:       price,
            BuyPrice:    price,
            RegistCount: qty,
            EndDate:     enddate,
            CreateTime:  time.Now(),
            UpdateTime:  time.Now(),
        }

        err := s.store.CreateAuctionStackable(ctx, stackable)
        if err != nil {
            return nil, nil, err
        }

        // 扣除物品
        err = s.store.SubBagItem(ctx, roleID, index, qty, 0)
        if err != nil {
            return nil, nil, err
        }

        return nil, []*dnfv1.AuctionStackable{
            {
                Auid:        stackable.AUID,
                Charguid:    stackable.CharGUID,
                Index:       stackable.Index,
                Count:       stackable.Count,
                Type:        stackable.Type,
                Price:       stackable.Price,
                Buyprice:    stackable.BuyPrice,
                Registcount: stackable.RegistCount,
                Enddate:     uint64(stackable.EndDate.Unix()),
            },
        }, nil
    } else {
        // 装备
        auid := s.store.GenerateID(ctx)

        equip := &models.AuctionEquip{
            AUID:        auid,
            CharGUID:    roleID,
            GUID:        guid,
            Index:       index,
            Count:       qty,
            Type:        1,
            Price:       price,
            BuyPrice:    price,
            RegistCount: qty,
            EndDate:     enddate,
            CreateTime:  time.Now(),
            UpdateTime:  time.Now(),
        }

        err := s.store.CreateAuctionEquip(ctx, equip)
        if err != nil {
            return nil, nil, err
        }

        // 扣除物品
        err = s.store.SubBagItem(ctx, roleID, index, qty, guid)
        if err != nil {
            return nil, nil, err
        }

        return []*dnfv1.AuctionEquip{
            {
                Auid:        equip.AUID,
                Charguid:    equip.CharGUID,
                Guid:        equip.GUID,
                Index:       equip.Index,
                Count:       equip.Count,
                Type:        equip.Type,
                Price:       equip.Price,
                Buyprice:    equip.BuyPrice,
                Registcount: equip.RegistCount,
                Enddate:     uint64(equip.EndDate.Unix()),
            },
        }, nil, nil
    }
}

// CancelRegister 取消注册
func (s *AuctionService) CancelRegister(ctx context.Context, roleID uint64, category uint32, auid uint64) error {
    categoryInfo, err := s.store.GetAuctionCategory(ctx, category)
    if err != nil {
        return err
    }

    if categoryInfo.Type == 1 {
        stackable, err := s.store.GetAuctionStackableByAUID(ctx, auid)
        if err != nil {
            return err
        }

        if stackable.CharGUID != roleID {
            return store.ErrPermissionDenied
        }

        err = s.store.DeleteAuctionStackable(ctx, auid)
        if err != nil {
            return err
        }

        // 返还物品或泰拉
        if stackable.Tera > 0 {
            err = s.store.SendMail(ctx, roleID, "拍卖行-出售得到的泰拉", "[拍卖行]出售得到的泰拉", []*models.MailItem{
                {
                    Index: 2013000001,
                    Count: uint32(stackable.Tera * 9 / 10),
                },
            })
            if err != nil {
                return err
            }
        }

        if stackable.Count > 0 {
            err = s.store.SendMail(ctx, roleID, "拍卖行-返还未售出的物品", "[拍卖行]返还未售出的物品", []*models.MailItem{
                {
                    Index: stackable.Index,
                    Count: stackable.Count,
                },
            })
            if err != nil {
                return err
            }
        }
    } else {
        equip, err := s.store.GetAuctionEquipByAUID(ctx, auid)
        if err != nil {
            return err
        }

        if equip.CharGUID != roleID {
            return store.ErrPermissionDenied
        }

        err = s.store.DeleteAuctionEquip(ctx, auid)
        if err != nil {
            return err
        }

        // 返还物品或泰拉
        if equip.Tera > 0 {
            err = s.store.SendMail(ctx, roleID, "拍卖行-出售得到的泰拉", "[拍卖行]出售得到的泰拉", []*models.MailItem{
                {
                    Index: 2013000001,
                    Count: uint32(equip.Tera * 9 / 10),
                },
            })
            if err != nil {
                return err
            }
        }

        err = s.store.SendMail(ctx, roleID, "拍卖行-返还未售出的物品", "[拍卖行]返还未售出的物品", []*models.MailItem{
            {
                Index: equip.Index,
                Count: equip.Count,
            },
        })
        if err != nil {
            return err
        }
    }

    return nil
}

// CompleteRegister 完成注册
func (s *AuctionService) CompleteRegister(ctx context.Context, roleID uint64, tab uint32, index uint32, qty uint32, price uint64, guid uint64) error {
    return s.RegisterItem(ctx, roleID, tab, index, qty, price, guid)
}

// GetAuctionHistory 获取拍卖历史
func (s *AuctionService) GetAuctionHistory(ctx context.Context, roleID uint64) ([]*dnfv1.AuctionEquip, []*dnfv1.AuctionStackable, error) {
    buyRecords, err := s.store.GetAuctionBuyRecords(ctx, roleID)
    if err != nil {
        return nil, nil, err
    }

    equipList := make([]*dnfv1.AuctionEquip, 0)
    stackableList := make([]*dnfv1.AuctionStackable, 0)

    for _, record := range buyRecords {
        if record.GUID > 0 {
            equipList = append(equipList, &dnfv1.AuctionEquip{
                Auid:     record.AUID,
                Charguid: record.SellerGUID,
                Guid:     record.GUID,
                Index:    record.Index,
                Count:    record.Count,
                Price:    record.Price,
                Enddate:  uint64(record.BuyTime.Unix()),
            })
        } else {
            stackableList = append(stackableList, &dnfv1.AuctionStackable{
                Auid:     record.AUID,
                Charguid: record.SellerGUID,
                Index:    record.Index,
                Count:    record.Count,
                Price:    record.Price,
                Enddate:  uint64(record.BuyTime.Unix()),
            })
        }
    }

    return equipList, stackableList, nil
}

// handleExpiredEquip 处理到期装备
func (s *AuctionService) handleExpiredEquip(ctx context.Context, equip *models.AuctionEquip) error {
    err := s.store.DeleteAuctionEquip(ctx, equip.AUID)
    if err != nil {
        return err
    }

    if equip.Tera > 0 {
        err = s.store.SendMail(ctx, equip.CharGUID, "拍卖行-售出得到的泰拉", "[拍卖行]售出得到的泰拉", []*models.MailItem{
            {
                Index: 2013000001,
                Count: uint32(equip.Tera * 9 / 10),
            },
        })
        if err != nil {
            return err
        }
    } else {
        err = s.store.SendMail(ctx, equip.CharGUID, "拍卖行-返还到期未售出的物品", "[拍卖行]返还到期未售出的物品", []*models.MailItem{
            {
                Index: equip.Index,
                Count: equip.Count,
            },
        })
        if err != nil {
            return err
        }
    }

    return nil
}

// handleExpiredStackable 处理到期堆叠物品
func (s *AuctionService) handleExpiredStackable(ctx context.Context, stackable *models.AuctionStackable) error {
    err := s.store.DeleteAuctionStackable(ctx, stackable.AUID)
    if err != nil {
        return err
    }

    if stackable.Count == 0 || stackable.Tera > 0 {
        err = s.store.SendMail(ctx, stackable.CharGUID, "拍卖行-出售得到的泰拉", "[拍卖行]出售得到的泰拉", []*models.MailItem{
            {
                Index: 2013000001,
                Count: uint32(stackable.Tera * 9 / 10),
            },
        })
        if err != nil {
            return err
        }
    }

    if stackable.Count > 0 {
        err = s.store.SendMail(ctx, stackable.CharGUID, "拍卖行-返还未售出的物品", "[拍卖行]返还未售出的物品", []*models.MailItem{
            {
                Index: stackable.Index,
                Count: stackable.Count,
            },
        })
        if err != nil {
            return err
        }
    }

    return nil
}

// buyStackable 购买堆叠物品
func (s *AuctionService) buyStackable(ctx context.Context, roleID uint64, index uint32, price uint64, qty uint32) error {
    return s.store.BuyAuctionStackable(ctx, index, price, qty)
}

// buyEquip 购买装备
func (s *AuctionService) buyEquip(ctx context.Context, roleID uint64, index uint32, price uint64, qty uint32) error {
    return s.store.BuyAuctionEquip(ctx, index, price, qty)
}
```

## 实现步骤

### 步骤 1: 创建 ProtoBuf 定义
1. 创建 `proto/dnf/v1/auction.proto`
2. 定义所有拍卖相关的消息
3. 运行 `buf generate` 生成 Go 代码

### 步骤 2: 创建数据模型
1. 创建 `internal/db/models/auction.go`
2. 定义 AuctionEquip、AuctionStackable、AuctionBuyRecord、AuctionCategory、AuctionPriceHistory 模型
3. 运行数据库迁移

### 步骤 3: 实现 Handler
1. 创建 `internal/game/handlers/auction.go`
2. 实现所有拍卖相关的处理器
3. 注册消息路由

### 步骤 4: 实现 Service
1. 创建 `internal/game/auction_service/auction.go`
2. 实现业务逻辑
3. 集成数据库操作

### 步骤 5: 编写测试用例
1. 创建 `tests/auction_test.go`
2. 编写所有功能的测试用例
3. 运行测试验证

### 步骤 6: 集成到主服务器
1. 在 `cmd/server/main.go` 中注册 Handler
2. 更新消息注册表
3. 测试完整流程

## 注意事项

1. **拍卖到期**: 正确处理到期物品的返还和邮件发送
2. **价格计算**: 正确计算一口价和平均价格
3. **库存管理**: 确保拍卖物品的库存管理正确
4. **泰拉扣除**: 确保泰拉扣除的原子性
5. **邮件系统**: 正确集成邮件系统发送物品
6. **权限验证**: 验证玩家是否有权限操作拍卖物品
7. **并发控制**: 处理并发购买和取消的情况
8. **错误处理**: 完善的错误处理和日志记录
9. **性能优化**: 大量拍卖数据时需要优化查询性能
10. **缓存机制**: 使用缓存减少数据库查询
