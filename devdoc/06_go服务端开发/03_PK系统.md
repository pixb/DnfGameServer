# PK 系统设计文档

## 概述

PK（Player Kill）系统是玩家对战的核心功能，支持玩家匹配、战斗、结算等功能。

## Java 代码分析

### 核心控制器
- **文件位置**: `src/main/java/com/dnfm/game/pk/PkController.java`
- **处理器数量**: 9 个 @RequestMapping 方法

### 核心功能

#### 1. 多人游戏请求匹配 (REQ_MULTI_PLAY_REQUEST_MATCH)
- **方法**: `reqMultiPlayRequestMatch(IoSession session, REQ_MULTI_PLAY_REQUEST_MATCH reqMultiPlayRequestMatch)`
- **功能**:
  - 请求多人游戏匹配
  - 返回匹配结果
  - 当前实现返回错误码 3（未实现）

#### 2. 取消多人游戏请求匹配 (REQ_MULTI_PLAY_REQUEST_MATCH_CANCEL)
- **方法**: `reqMultiPlayRequestMatchCancel(IoSession session, REQ_MULTI_PLAY_REQUEST_MATCH_CANCEL reqMultiPlayRequestMatchCancel)`
- **功能**:
  - 取消多人游戏匹配请求
  - 返回取消结果
  - 当前实现返回错误码 3（未实现）

#### 3. 历史遗迹通知 (REQ_HISTORICSITE_NOTI)
- **方法**: `REQ_HISTORICSITE_NOTI(IoSession session, REQ_HISTORICSITE_NOTI req_historicsite_noti)`
- **功能**:
  - 获取历史遗迹通知
  - 返回通知信息

#### 4. 加载公会捐赠信息 (REQ_LOAD_GUILD_DONATION_INFO_2)
- **方法**: `REQ_LOAD_GUILD_DONATION_INFO_2(IoSession session, REQ_LOAD_GUILD_DONATION_INFO_2 req_load_guild_donation_info_2)`
- **功能**:
  - 加载公会捐赠信息
  - 返回捐赠配方列表
  - 返回数据示例：`{"recipe": [{"index": 5}, {"index": 13}, ...]}`

#### 5. 梦境迷宫基本信息 (REQ_DREAM_MAZE_BASICINFO)
- **方法**: `REQ_DREAM_MAZE_BASICINFO(IoSession session, REQ_DREAM_MAZE_BASICINFO req_dream_maze_basicinfo)`
- **功能**:
  - 获取梦境迷宫基本信息
  - 返回迷宫信息

#### 6. 副本入场次数 (REQ_RAID_ENTRANCE_COUNT)
- **方法**: `REQ_RAID_ENTRANCE_COUNT(IoSession session, REQ_RAID_ENTRANCE_COUNT req_raid_entrance_count)`
- **功能**:
  - 获取副本入场次数
  - 返回副本入场限制信息
  - 返回数据示例：
    ```json
    {
      "entrance": [
        {
          "raidindex": 1,
          "dailycharacter": 1,
          "character": 3,
          "account": 12,
          "dailyrewardcharacter": 1,
          "rewardcharacter": 3,
          "rewardaccount": 12
        }
      ]
    }
    ```

#### 7. 加载进度 (REQ_LOADING_PROGRESS)
- **方法**: `REQ_LOADING_PROGRESS(IoSession session, REQ_LOADING_PROGRESS req_loading_progress)`
- **功能**:
  - 报告加载进度
  - 广播给所有 PVP 角色地图中的玩家
  - 返回匹配 GUID 和进度值

#### 8. 返回城镇 (REQ_RETURN_TO_TOWN_AT_MULTI_PLAY)
- **方法**: `REQ_RETURN_TO_TOWN_AT_MULTI_PLAY(IoSession session, REQ_RETURN_TO_TOWN_AT_MULTI_PLAY req_return_to_town_at_multi_play)`
- **功能**:
  - 从多人游戏返回城镇
  - 返回确认信息

#### 9. 自定义游戏房间设置 (REQ_CUSTOM_GAME_ROOM_SETTING)
- **方法**: `REQ_CUSTOM_GAME_ROOM_SETTING(IoSession session, REQ_CUSTOM_GAME_ROOM_SETTING req_custom_game_room_setting)`
- **功能**:
  - 设置自定义游戏房间
  - 队长可以设置房间参数
  - 返回房间信息和控制组通知
  - 包含队伍成员信息、战斗选项等

## Go 实现方案

### 1. ProtoBuf 消息定义

#### pk.proto
```protobuf
syntax = "proto3";

package dnf.v1;

option go_package = "gen/dnf/v1";

import "dnf/v1/common.proto";

// 多人游戏请求匹配请求
message MultiPlayRequestMatchRequest {
    uint32 transId = 1;
    uint32 matchtype = 2;
    uint32 dungeonindex = 3;
}

// 多人游戏请求匹配响应
message MultiPlayRequestMatchResponse {
    uint32 transId = 1;
    uint32 error = 2;
    string message = 3;
    uint64 matchingguid = 4;
    string bip = 5;
    uint32 bport = 6;
}

// 取消多人游戏请求匹配请求
message MultiPlayRequestMatchCancelRequest {
    uint32 transId = 1;
    uint64 matchingguid = 2;
}

// 取消多人游戏请求匹配响应
message MultiPlayRequestMatchCancelResponse {
    uint32 transId = 1;
    uint32 error = 2;
    string message = 3;
}

// 历史遗迹通知请求
message HistoricSiteNotiRequest {
    uint32 transId = 1;
}

// 历史遗迹通知响应
message HistoricSiteNotiResponse {
    uint32 transId = 1;
    uint32 error = 2;
    string message = 3;
}

// 加载公会捐赠信息请求
message LoadGuildDonationInfoRequest {
    uint32 transId = 1;
}

// 加载公会捐赠信息响应
message LoadGuildDonationInfoResponse {
    uint32 transId = 1;
    repeated RecipeInfo recipe = 2;
    uint32 error = 3;
    string message = 4;
}

// 配方信息
message RecipeInfo {
    uint32 index = 1;
}

// 梦境迷宫基本信息请求
message DreamMazeBasicInfoRequest {
    uint32 transId = 1;
}

// 梦境迷宫基本信息响应
message DreamMazeBasicInfoResponse {
    uint32 transId = 1;
    uint32 error = 2;
    string message = 3;
}

// 副本入场次数请求
message RaidEntranceCountRequest {
    uint32 transId = 1;
}

// 副本入场次数响应
message RaidEntranceCountResponse {
    uint32 transId = 1;
    repeated RaidEntranceInfo entrance = 2;
    uint32 error = 3;
    string message = 4;
}

// 副本入场信息
message RaidEntranceInfo {
    uint32 raidindex = 1;
    uint32 dailycharacter = 2;
    uint32 character = 3;
    uint32 account = 4;
    uint32 dailyrewardcharacter = 5;
    uint32 rewardcharacter = 6;
    uint32 rewardaccount = 7;
}

// 加载进度请求
message LoadingProgressRequest {
    uint32 transId = 1;
    uint32 value = 2;
}

// 加载进度响应
message LoadingProgressResponse {
    uint32 transId = 1;
    uint64 matchingguid = 2;
    uint64 charguid = 3;
    uint32 value = 4;
}

// 返回城镇请求
message ReturnToTownAtMultiPlayRequest {
    uint32 transId = 1;
}

// 返回城镇响应
message ReturnToTownAtMultiPlayResponse {
    uint32 transId = 1;
    uint32 error = 2;
    string message = 3;
}

// 自定义游戏房间设置请求
message CustomGameRoomSettingRequest {
    uint32 transId = 1;
    CustomData customdata = 2;
}

// 自定义数据
message CustomData {
    uint64 senderguid = 1;
    uint32 type = 2;
    int32 iValue = 3;
    string sValue = 4;
}

// 自定义游戏房间设置响应
message CustomGameRoomSettingResponse {
    uint32 transId = 1;
    uint32 error = 2;
    string message = 3;
}

// 控制组通知
message NotifyControlGroup {
    uint32 world = 1;
    uint32 channel = 2;
    uint64 partyguid = 3;
    uint64 partyleaderguid = 4;
    string ip = 5;
    uint32 port = 6;
    uint32 type = 7;
    uint32 area = 8;
    uint32 dungeonindex = 9;
    uint32 subtype = 10;
    uint32 stageindex = 11;
    string partyname = 12;
    repeated GroupMember users = 13;
    bool isobserver = 14;
    bool isobserverchat = 15;
    repeated BattleOption battleoptionlist = 16;
    uint32 transId = 17;
}

// 队伍成员
message GroupMember {
    uint64 charguid = 1;
    uint32 equipscore = 2;
    uint32 level = 3;
    string name = 4;
    uint64 gguid = 5;
    string gname = 6;
    bool partyleader = 7;
    uint32 fatigue = 8;
    uint32 world = 9;
    uint32 creditscore = 10;
    uint32 teamtype = 11;
    CustomData customdata = 12;
    uint32 ping = 13;
    uint32 mineworld = 14;
    uint64 specialcategoryitemindex = 15;
}

// 战斗选项
message BattleOption {
    uint32 type = 1;
}
```

### 2. 数据模型设计

#### models/pk.go
```go
package models

import (
    "time"
    "gorm.io/gorm"
)

// PvpRecord PK 记录
type PvpRecord struct {
    ID          uint64    `gorm:"primaryKey;column:id" json:"id"`
    RoleID      uint64    `gorm:"column:roleId" json:"role_id"`
    MatchType   uint32    `gorm:"column:matchType" json:"match_type"`
    Win         bool      `gorm:"column:win" json:"win"`
    Score       int32     `gorm:"column:score" json:"score"`
    OpponentID  uint64    `gorm:"column:opponentId" json:"opponent_id"`
    BattleTime  time.Time `gorm:"column:battleTime" json:"battle_time"`
    CreateTime  time.Time `gorm:"column:createTime" json:"create_time"`
}

func (PvpRecord) TableName() string {
    return "t_pvp_record"
}

// RaidEntrance 副本入场记录
type RaidEntrance struct {
    ID                    uint64    `gorm:"primaryKey;column:id" json:"id"`
    RoleID                uint64    `gorm:"column:roleId" json:"role_id"`
    RaidIndex             uint32    `gorm:"column:raidIndex" json:"raid_index"`
    DailyCharacterCount   uint32    `gorm:"column:dailyCharacterCount" json:"daily_character_count"`
    CharacterCount        uint32    `gorm:"column:characterCount" json:"character_count"`
    AccountCount          uint32    `gorm:"column:accountCount" json:"account_count"`
    DailyRewardCount      uint32    `gorm:"column:dailyRewardCount" json:"daily_reward_count"`
    RewardCount           uint32    `gorm:"column:rewardCount" json:"reward_count"`
    LastEnterTime         time.Time `gorm:"column:lastEnterTime" json:"last_enter_time"`
    CreateTime            time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime            time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (RaidEntrance) TableName() string {
    return "t_raid_entrance"
}

// PvpMatching PK 匹配
type PvpMatching struct {
    ID          uint64    `gorm:"primaryKey;column:id" json:"id"`
    MatchingID  uint64    `gorm:"column:matchingId" json:"matching_id"`
    RoleID      uint64    `gorm:"column:roleId" json:"role_id"`
    MatchType   uint32    `gorm:"column:matchType" json:"match_type"`
    Status      uint32    `gorm:"column:status" json:"status"`
    CreateTime  time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime  time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (PvpMatching) TableName() string {
    return "t_pvp_matching"
}
```

### 3. Handler 实现

#### handlers/pk.go
```go
package handlers

import (
    "context"

    "github.com/pixb/DnfGameServer/dnf-go-server/internal/game/pk_service"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/network"
    dnfv1 "github.com/pixb/DnfGameServer/dnf-go-server/proto/gen/dnf/v1"
    "google.golang.org/protobuf/proto"
)

type PkHandler struct {
    pkService *pk_service.PkService
}

func NewPkHandler(pkService *pk_service.PkService) *PkHandler {
    return &PkHandler{
        pkService: pkService,
    }
}

// MultiPlayRequestMatchHandler 多人游戏请求匹配处理器
func (h *PkHandler) MultiPlayRequestMatchHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MultiPlayRequestMatchRequest)
    if !ok {
        return
    }

    result, err := h.pkService.RequestMatch(context.Background(), sess.RoleID, req.Matchtype, req.Dungeonindex)
    if err != nil {
        h.sendError(sess, req, 3, "matching not implemented")
        return
    }

    resp := &dnfv1.MultiPlayRequestMatchResponse{
        TransId:     req.TransId,
        Error:       0,
        Matchingguid: result.MatchingGuid,
        Bip:        result.IP,
        Bport:      result.Port,
    }
    sess.Send(resp)
}

// MultiPlayRequestMatchCancelHandler 取消多人游戏请求匹配处理器
func (h *PkHandler) MultiPlayRequestMatchCancelHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MultiPlayRequestMatchCancelRequest)
    if !ok {
        return
    }

    err := h.pkService.CancelMatch(context.Background(), sess.RoleID, req.Matchingguid)
    if err != nil {
        h.sendError(sess, req, 3, "cancel match not implemented")
        return
    }

    resp := &dnfv1.MultiPlayRequestMatchCancelResponse{
        TransId: req.TransId,
        Error:   0,
    }
    sess.Send(resp)
}

// HistoricSiteNotiHandler 历史遗迹通知处理器
func (h *PkHandler) HistoricSiteNotiHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.HistoricSiteNotiRequest)
    if !ok {
        return
    }

    resp := &dnfv1.HistoricSiteNotiResponse{
        TransId: req.TransId,
        Error:   0,
    }
    sess.Send(resp)
}

// LoadGuildDonationInfoHandler 加载公会捐赠信息处理器
func (h *PkHandler) LoadGuildDonationInfoHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.LoadGuildDonationInfoRequest)
    if !ok {
        return
    }

    recipes, err := h.pkService.GetGuildDonationRecipes(context.Background())
    if err != nil {
        h.sendError(sess, req, 1, "failed to load guild donation info")
        return
    }

    resp := &dnfv1.LoadGuildDonationInfoResponse{
        TransId: req.TransId,
        Recipe:  recipes,
        Error:   0,
    }
    sess.Send(resp)
}

// DreamMazeBasicInfoHandler 梦境迷宫基本信息处理器
func (h *PkHandler) DreamMazeBasicInfoHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.DreamMazeBasicInfoRequest)
    if !ok {
        return
    }

    resp := &dnfv1.DreamMazeBasicInfoResponse{
        TransId: req.TransId,
        Error:   0,
    }
    sess.Send(resp)
}

// RaidEntranceCountHandler 副本入场次数处理器
func (h *PkHandler) RaidEntranceCountHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.RaidEntranceCountRequest)
    if !ok {
        return
    }

    entrances, err := h.pkService.GetRaidEntranceCount(context.Background(), sess.RoleID)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get raid entrance count")
        return
    }

    resp := &dnfv1.RaidEntranceCountResponse{
        TransId:  req.TransId,
        Entrance: entrances,
        Error:    0,
    }
    sess.Send(resp)
}

// LoadingProgressHandler 加载进度处理器
func (h *PkHandler) LoadingProgressHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.LoadingProgressRequest)
    if !ok {
        return
    }

    err := h.pkService.ReportLoadingProgress(context.Background(), sess.RoleID, req.Value)
    if err != nil {
        h.sendError(sess, req, 1, "failed to report loading progress")
        return
    }

    resp := &dnfv1.LoadingProgressResponse{
        TransId:      req.TransId,
        Matchingguid: sess.MatchingID,
        Charguid:     sess.RoleID,
        Value:        req.Value,
    }
    sess.Send(resp)
}

// ReturnToTownAtMultiPlayHandler 返回城镇处理器
func (h *PkHandler) ReturnToTownAtMultiPlayHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.ReturnToTownAtMultiPlayRequest)
    if !ok {
        return
    }

    err := h.pkService.ReturnToTown(context.Background(), sess.RoleID)
    if err != nil {
        h.sendError(sess, req, 1, "failed to return to town")
        return
    }

    resp := &dnfv1.ReturnToTownAtMultiPlayResponse{
        TransId: req.TransId,
        Error:   0,
    }
    sess.Send(resp)
}

// CustomGameRoomSettingHandler 自定义游戏房间设置处理器
func (h *PkHandler) CustomGameRoomSettingHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.CustomGameRoomSettingRequest)
    if !ok {
        return
    }

    result, err := h.pkService.SetCustomGameRoom(context.Background(), sess.RoleID, req.Customdata)
    if err != nil {
        h.sendError(sess, req, 1, "failed to set custom game room")
        return
    }

    resp := &dnfv1.CustomGameRoomSettingResponse{
        TransId: req.TransId,
        Error:   0,
    }
    sess.Send(resp)

    if result.NotifyControlGroup != nil {
        sess.Send(result.NotifyControlGroup)
    }
}

func (h *PkHandler) sendError(sess *network.Session, req proto.Message, code uint32, message string) {
    switch req.(type) {
    case *dnfv1.MultiPlayRequestMatchRequest:
        resp := &dnfv1.MultiPlayRequestMatchResponse{
            TransId: req.(*dnfv1.MultiPlayRequestMatchRequest).TransId,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.MultiPlayRequestMatchCancelRequest:
        resp := &dnfv1.MultiPlayRequestMatchCancelResponse{
            TransId: req.(*dnfv1.MultiPlayRequestMatchCancelRequest).TransId,
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    default:
        // 通用错误处理
    }
}
```

## 实现步骤

### 步骤 1: 创建 ProtoBuf 定义
1. 创建 `proto/dnf/v1/pk.proto`
2. 定义所有 PK 相关的消息
3. 运行 `buf generate` 生成 Go 代码

### 步骤 2: 创建数据模型
1. 创建 `internal/db/models/pk.go`
2. 定义 PvpRecord、RaidEntrance、PvpMatching 模型
3. 运行数据库迁移

### 步骤 3: 实现 Handler
1. 创建 `internal/game/handlers/pk.go`
2. 实现所有 PK 相关的处理器
3. 注册消息路由

### 步骤 4: 实现 Service
1. 创建 `internal/game/pk_service/pk.go`
2. 实现业务逻辑
3. 集成数据库操作

### 步骤 5: 编写测试用例
1. 创建 `tests/pk_test.go`
2. 编写所有功能的测试用例
3. 运行测试验证

### 步骤 6: 集成到主服务器
1. 在 `cmd/server/main.go` 中注册 Handler
2. 更新消息注册表
3. 测试完整流程

## 注意事项

1. **匹配系统**: 正确实现匹配逻辑
2. **状态同步**: PK 状态需要同步给所有参与者
3. **副本限制**: 正确处理副本入场次数限制
4. **加载进度**: 广播加载进度给所有玩家
5. **房间设置**: 队长有特殊权限
6. **错误处理**: 完善的错误处理和日志记录
