# 进入游戏系统设计文档

## 概述

进入游戏系统是玩家登录后进入游戏世界的核心流程，包括角色选择、数据加载、位置同步、心跳检测等功能。

## Java 代码分析

### 核心控制器
- **文件位置**: `src/main/java/com/dnfm/game/enter/EnterGameController.java`
- **处理器数量**: 98 个 @RequestMapping 方法

### 核心功能

#### 1. 开始游戏 (REQ_START_GAME)
- **方法**: `ReqStartGame(IoSession session, REQ_START_GAME reqStartGame)`
- **功能**:
  - 验证账户状态
  - 加载角色数据
  - 设置会话属性
  - 返回游戏初始化数据
  - 处理重连逻辑
- **返回数据**:
  - 世界信息 (world, currentworld)
  - 位置信息 (town, area)
  - 角色信息 (level, exp, fatigue)
  - Buff 列表
  - 技能版本
  - 城镇间隔
  - 事件选择信息
  - 任务状态
  - SVN/GIT 版本信息

#### 2. 角色列表 (REQ_CHARAC_LIST)
- **方法**: `ReqCharacList(IoSession session, REQ_CHARAC_LIST req_charac_list)`
- **功能**:
  - 根据 openid 获取角色列表
  - 返回角色基本信息

#### 3. 角色信息 (REQ_CHARACTER_INFO)
- **方法**: `ReqCharacterInfo(IoSession session, REQ_CHARACTER_INFO req_character_info)`
- **功能**:
  - 获取指定角色的详细信息
  - 返回完整角色数据

#### 4. 加载服务器简单数据 (REQ_LOAD_SERVER_SIMPLE_DATA)
- **方法**: `ReqLoadServerSimpleData(IoSession session, REQ_LOAD_SERVER_SIMPLE_DATA req_load_server_simple_data)`
- **功能**:
  - 加载服务器配置数据
  - 返回服务器简单数据

#### 5. 保存服务器简单数据 (REQ_SAVE_SERVER_SIMPLE_DATA)
- **方法**: `ReqSaveServerSimpleData(IoSession session, REQ_SAVE_SERVER_SIMPLE_DATA req_save_server_simple_data)`
- **功能**:
  - 保存玩家服务器简单数据
  - 更新玩家配置

#### 6. 进入频道 (REQ_ENTER_CHANNEL)
- **方法**: `ReqEnterChannel(IoSession session, REQ_ENTER_CHANNEL req_enter_channel)`
- **功能**:
  - 玩家进入游戏频道
  - 更新在线状态

#### 7. 进入城镇 (REQ_ENTER_TO_TOWN)
- **方法**: `ReqEnterToTown(IoSession session, REQ_ENTER_TO_TOWN req_enter_to_town)`
- **功能**:
  - 玩家进入城镇
  - 更新位置信息
  - 返回城镇信息

#### 8. 离开城镇 (REQ_LEAVE_FROM_TOWN)
- **方法**: `ReqLeaveFromTown(IoSession session, REQ_LEAVE_FROM_TOWN req_leave_from_town)`
- **功能**:
  - 玩家离开城镇
  - 更新位置状态

#### 9. 心跳检测 (REQ_PING)
- **方法**: `ReqPing(IoSession session, REQ_PING req_ping)`
- **功能**:
  - 客户端心跳检测
  - 返回 PONG 响应
  - 更新会话活跃时间

#### 10. 待机 (REQ_STANDBY)
- **方法**: `ReqStandby(IoSession session, REQ_STANDBY req_standby)`
- **功能**:
  - 玩家待机状态
  - 返回待机确认

#### 11. 每日重置 (REQ_DAILY_RESET)
- **方法**: `ReqDailyReset(IoSession session, REQ_DAILY_RESET req_daily_reset)`
- **功能**:
  - 每日数据重置
  - 疲劳值恢复
  - 商店购买记录清空

#### 12. 交互菜单 (REQ_INTERACTION_MENU)
- **方法**: `REQ_INTERACTION_MENU(IoSession session, REQ_INTERACTION_MENU req_interaction_menu)`
- **功能**:
  - 获取角色交互菜单
  - 返回交互选项

#### 13. 非交易角色状态 (REQ_NOT_TRANSACTION_CHARACTER_STATE_INFO)
- **方法**: `REQ_NOT_TRANSACTION_CHARACTER_STATE_INFO(IoSession session, REQ_NOT_TRANSACTION_CHARACTER_STATE_INFO req_not_transaction_character_state_info)`
- **功能**:
  - 获取角色交易状态
  - 返回是否可交易

#### 14. 冒险联盟讨伐信息 (REQ_ADVENTURE_UNION_SUBDUE_INFO)
- **方法**: `ReqAdventureUnionSubdueInfo(IoSession session, REQ_ADVENTURE_UNION_SUBDUE_INFO reqAdventureUnionSubdueInfo)`
- **功能**:
  - 获取冒险联盟讨伐信息
  - 返回疲劳值、门票、入场道具

#### 15. PVP 记录信息 (REQ_PVP_RECORD_INFO)
- **方法**: `ReqPvpRecordInfo(IoSession session, REQ_PVP_RECORD_INFO reqPvpRecordInfo)`
- **功能**:
  - 获取 PVP 记录
  - 支持多种匹配类型

#### 16. IDIP 通知 (REQ_IDIP_NOTICES)
- **方法**: `ReqIdipNotices(IoSession session, REQ_IDIP_NOTICES reqIdipNotices)`
- **功能**:
  - 获取 IDIP 通知信息

#### 17. 黑色钻石信息 (REQ_BLACK_DIAMON_INFO)
- **方法**: `ReqBlackDiamonInfo(IoSession session, REQ_BLACK_DIAMON_INFO reqBlackDiamonInfo)`
- **功能**:
  - 获取黑色钻石信息

#### 18. 发送邀请好友列表 (REQ_SENDING_INVITE_FRIEND_LIST)
- **方法**: `ReqSendingInviteFriendList(IoSession session, REQ_SENDING_INVITE_FRIEND_LIST reqSendingInviteFriendList)`
- **功能**:
  - 获取发送邀请的好友列表

## Go 实现方案

### 1. ProtoBuf 消息定义

需要在 `proto/dnf/v1/` 目录下创建或更新以下 proto 文件：

#### enter_game.proto
```protobuf
syntax = "proto3";

package dnf.v1;

option go_package = "gen/dnf/v1";

import "dnf/v1/common.proto";

// 开始游戏请求
message StartGameRequest {
    uint64 charguid = 1;
    string authkey = 2;
    string accesstoken = 3;
    repeated ProtocolTransaction request = 4;
    uint32 town = 5;
}

// 协议事务
message ProtocolTransaction {
    uint32 type = 1;
    bytes data = 2;
}

// 开始游戏响应
message StartGameResponse {
    uint32 world = 1;
    uint32 currentworld = 2;
    uint32 town = 3;
    uint32 area = 4;
    uint32 level = 5;
    uint64 exp = 6;
    uint32 fatigue = 7;
    repeated DiningFoodBuffInfo bufflist = 8;
    uint32 partydisturb = 9;
    uint32 battletutorial = 10;
    uint32 qindex = 11;
    uint32 areaId = 12;
    uint32 expratio = 13;
    uint32 fatigueratio = 14;
    uint32 chatchnidx = 15;
    uint64 createcount = 16;
    ReturnUserInfo returnUserInfo = 17;
    BattlePassInfo battlePassInfo = 18;
    BattlePassInfo pvpBattlePassInfo = 19;
    uint32 intervalidtowncharacterinfoms = 20;
    InitSkill initskillversion = 21;
    repeated TownInterval towninterval = 22;
    bool adventurebookOpen = 23;
    uint32 svnrevision = 24;
    string gitrevision = 25;
    EventSelectInfo eventSelectInfo = 26;
    uint32 queststate = 27;
    uint32 error = 28;
    string message = 29;
}

// 进餐食物Buff信息
message DiningFoodBuffInfo {
    uint32 index = 1;
}

// 返回用户信息
message ReturnUserInfo {
    uint64 uid = 1;
    string name = 2;
    uint32 level = 3;
    uint32 job = 4;
}

// 战斗通行证信息
message BattlePassInfo {
    uint32 level = 1;
    uint32 exp = 2;
}

// 初始化技能
message InitSkill {
    uint32 currentVersion = 1;
    uint32 latestVersion = 2;
}

// 城镇间隔
message TownInterval {
    uint32 townindex = 1;
    uint32 refreshinterval = 2;
}

// 事件选择信息
message EventSelectInfo {
    uint32 eventId = 1;
    uint32 status = 2;
}

// 角色列表请求
message CharacterListRequest {
    string openid = 1;
}

// 角色列表响应
message CharacterListResponse {
    repeated CharacterInfo characters = 1;
    uint32 error = 2;
    string message = 3;
}

// 角色信息请求
message CharacterInfoRequest {
    uint64 charguid = 1;
}

// 角色信息响应
message CharacterInfoResponse {
    CharacterInfo character = 1;
    uint32 error = 2;
    string message = 3;
}

// 心跳请求
message PingRequest {
    uint64 timestamp = 1;
}

// 心跳响应
message PingResponse {
    uint64 timestamp = 1;
    uint32 error = 2;
}

// 进入城镇请求
message EnterTownRequest {
    uint32 town = 1;
    uint32 area = 2;
}

// 进入城镇响应
message EnterTownResponse {
    uint32 town = 1;
    uint32 area = 2;
    uint32 error = 3;
    string message = 4;
}

// 离开城镇请求
message LeaveTownRequest {
    uint32 town = 1;
}

// 离开城镇响应
message LeaveTownResponse {
    uint32 error = 2;
    string message = 3;
}

// 每日重置请求
message DailyResetRequest {
}

// 每日重置响应
message DailyResetResponse {
    uint32 error = 2;
    string message = 3;
}
```

### 2. 数据模型设计

#### models/enter_game.go
```go
package models

import (
    "time"
    "gorm.io/gorm"
)

// ServerSimpleData 服务器简单数据
type ServerSimpleData struct {
    ID        uint64    `gorm:"primaryKey;column:id" json:"id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    Type      uint32    `gorm:"column:type" json:"type"`
    EnumValue uint32    `gorm:"column:enumValue" json:"enum_value"`
    Value     string    `gorm:"column:value;size:1000" json:"value"`
    TransID   uint32    `gorm:"column:transId" json:"trans_id"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (ServerSimpleData) TableName() string {
    return "t_server_simple_data"
}

// OnlineStatus 在线状态
type OnlineStatus struct {
    ID        uint64    `gorm:"primaryKey;column:id" json:"id"`
    AccountID uint64    `gorm:"column:accountId" json:"account_id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    Status    uint32    `gorm:"column:status" json:"status"`
    LastPing  time.Time `gorm:"column:lastPing" json:"last_ping"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (OnlineStatus) TableName() string {
    return "t_online_status"
}
```

### 3. Handler 实现

#### handlers/enter_game.go
```go
package handlers

import (
    "context"
    "time"

    "github.com/pixb/DnfGameServer/dnf-go-server/internal/game/player_service"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/network"
    "github.com/pixb/DnfGameServer/dnf-go-server/store"
    dnfv1 "github.com/pixb/DnfGameServer/dnf-go-server/proto/gen/dnf/v1"
    "google.golang.org/protobuf/proto"
)

type EnterGameHandler struct {
    playerService *player_service.PlayerService
    store        *store.Store
}

func NewEnterGameHandler(playerService *player_service.PlayerService, store *store.Store) *EnterGameHandler {
    return &EnterGameHandler{
        playerService: playerService,
        store:        store,
    }
}

// StartGameHandler 开始游戏处理器
func (h *EnterGameHandler) StartGameHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.StartGameRequest)
    if !ok {
        return
    }

    // 验证账户状态
    account, err := h.store.GetAccountByOpenID(sess.OpenID)
    if err != nil {
        h.sendError(sess, req, 1, "account not found")
        return
    }

    if account.IsStop {
        h.sendError(sess, req, 2, "account is stopped")
        return
    }

    // 加载角色数据
    role, err := h.playerService.GetPlayerBy(req.Charguid)
    if err != nil {
        h.sendError(sess, req, 3, "role not found")
        return
    }

    // 设置会话属性
    sess.UserID = req.Charguid
    sess.RoleID = req.Charguid

    // 构建响应
    resp := &dnfv1.StartGameResponse{
        World:           1,
        Currentworld:     1,
        Town:            2,
        Area:            5,
        Level:           role.Level,
        Exp:             role.Exp,
        Fatigue:         role.Fatigue,
        Partydisturb:     1,
        Battletutorial:   2,
        Qindex:          role.Qindex,
        AreaId:          2,
        Expratio:        role.Expratio,
        Fatigueratio:    role.Fatigueratio,
        Chatchnidx:      1,
        Createcount:      1838611,
        Initskillversion: &dnfv1.InitSkill{
            CurrentVersion: 1,
            LatestVersion:  1,
        },
        AdventurebookOpen: true,
        Svnrevision:      188783,
        Gitrevision:      "188783",
    }

    // 发送响应
    sess.Send(resp)
}

// PingHandler 心跳处理器
func (h *EnterGameHandler) PingHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.PingRequest)
    if !ok {
        return
    }

    // 更新最后心跳时间
    sess.LastPing = time.Now()

    // 返回 PONG
    resp := &dnfv1.PingResponse{
        Timestamp: req.Timestamp,
    }
    sess.Send(resp)
}

// EnterTownHandler 进入城镇处理器
func (h *EnterGameHandler) EnterTownHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.EnterTownRequest)
    if !ok {
        return
    }

    // 更新角色位置
    err := h.playerService.UpdatePosition(sess.RoleID, req.Town, req.Area)
    if err != nil {
        h.sendError(sess, req, 1, "failed to update position")
        return
    }

    // 返回响应
    resp := &dnfv1.EnterTownResponse{
        Town:  req.Town,
        Area:  req.Area,
        Error: 0,
    }
    sess.Send(resp)
}

// LeaveTownHandler 离开城镇处理器
func (h *EnterGameHandler) LeaveTownHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.LeaveTownRequest)
    if !ok {
        return
    }

    // 更新角色状态
    err := h.playerService.LeaveTown(sess.RoleID, req.Town)
    if err != nil {
        h.sendError(sess, req, 1, "failed to leave town")
        return
    }

    // 返回响应
    resp := &dnfv1.LeaveTownResponse{
        Error: 0,
    }
    sess.Send(resp)
}

// DailyResetHandler 每日重置处理器
func (h *EnterGameHandler) DailyResetHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.DailyResetRequest)
    if !ok {
        return
    }

    // 执行每日重置
    err := h.playerService.DailyReset(sess.RoleID)
    if err != nil {
        h.sendError(sess, req, 1, "failed to daily reset")
        return
    }

    // 返回响应
    resp := &dnfv1.DailyResetResponse{
        Error: 0,
    }
    sess.Send(resp)
}

func (h *EnterGameHandler) sendError(sess *network.Session, req proto.Message, code uint32, message string) {
    // 根据请求类型发送错误响应
    switch req.(type) {
    case *dnfv1.StartGameRequest:
        resp := &dnfv1.StartGameResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    default:
        // 通用错误处理
    }
}
```

### 4. Service 实现

#### player_service/enter_game.go
```go
package player_service

import (
    "context"
    "time"

    "github.com/pixb/DnfGameServer/dnf-go-server/store"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/db/models"
)

type EnterGameService struct {
    store *store.Store
}

func NewEnterGameService(store *store.Store) *EnterGameService {
    return &EnterGameService{
        store: store,
    }
}

// UpdatePosition 更新角色位置
func (s *EnterGameService) UpdatePosition(ctx context.Context, roleID uint64, town, area uint32) error {
    role, err := s.store.GetRole(ctx, roleID)
    if err != nil {
        return err
    }

    role.Town = town
    role.Area = area
    role.UpdateTime = time.Now()

    return s.store.UpdateRole(ctx, role)
}

// LeaveTown 离开城镇
func (s *EnterGameService) LeaveTown(ctx context.Context, roleID uint64, town uint32) error {
    role, err := s.store.GetRole(ctx, roleID)
    if err != nil {
        return err
    }

    role.Town = 0
    role.Area = 0
    role.UpdateTime = time.Now()

    return s.store.UpdateRole(ctx, role)
}

// DailyReset 每日重置
func (s *EnterGameService) DailyReset(ctx context.Context, roleID uint64) error {
    role, err := s.store.GetRole(ctx, roleID)
    if err != nil {
        return err
    }

    // 恢复疲劳值
    role.Fatigue = 100

    // 清空商店购买记录
    role.ShopBuyCount = 0

    role.UpdateTime = time.Now()

    return s.store.UpdateRole(ctx, role)
}
```

## 实现步骤

### 步骤 1: 创建 ProtoBuf 定义
1. 创建 `proto/dnf/v1/enter_game.proto`
2. 定义所有进入游戏相关的消息
3. 运行 `buf generate` 生成 Go 代码

### 步骤 2: 创建数据模型
1. 创建 `internal/db/models/enter_game.go`
2. 定义 ServerSimpleData 和 OnlineStatus 模型
3. 运行数据库迁移

### 步骤 3: 实现 Handler
1. 创建 `internal/game/handlers/enter_game.go`
2. 实现所有进入游戏相关的处理器
3. 注册消息路由

### 步骤 4: 实现 Service
1. 创建 `internal/game/player_service/enter_game.go`
2. 实现业务逻辑
3. 集成数据库操作

### 步骤 5: 编写测试用例
1. 创建 `tests/enter_game_test.go`
2. 编写所有功能的测试用例
3. 运行测试验证

### 步骤 6: 集成到主服务器
1. 在 `cmd/server/main.go` 中注册 Handler
2. 更新消息注册表
3. 测试完整流程

## 注意事项

1. **会话管理**: 进入游戏后需要正确设置会话属性
2. **重连处理**: 需要处理玩家重连场景
3. **数据同步**: 确保角色数据正确同步到数据库
4. **心跳检测**: 实现心跳超时检测机制
5. **每日重置**: 正确处理每日数据重置逻辑
6. **错误处理**: 完善的错误处理和日志记录
