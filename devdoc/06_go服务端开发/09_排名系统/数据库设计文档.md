# 排名系统 - 数据库设计文档

## 1. 数据库概述

排名系统数据库用于存储游戏中各种排名相关的数据，包括实时排名数据、排名历史记录、排名配置和排名奖励等信息。该数据库设计充分考虑了性能、可扩展性和数据一致性，确保排名系统能够高效运行并支持大量玩家数据。

### 1.1 设计目标

- **高性能**：支持快速的排名查询和更新操作
- **可扩展性**：能够轻松添加新的排名类型和功能
- **数据一致性**：确保排名数据的准确性和一致性
- **存储空间优化**：合理设计表结构，减少存储空间占用
- **索引优化**：通过合理的索引设计，提高查询性能

### 1.2 数据库类型

| 数据库 | 版本 | 用途 | 存储引擎 |
|--------|------|------|----------|
| MySQL | 5.7+ | 存储排名数据、配置和历史记录 | InnoDB |
| Redis | 7.0+ | 缓存热门排名数据，提高查询性能 | - |

## 2. 表结构设计

### 2.1 核心表结构

#### 2.1.1 t_rank - 排名表

**表名**: `t_rank`

**表类型**: 核心表

**存储引擎**: InnoDB

**字符集**: utf8mb4

**表结构**:

| 字段名 | 数据类型 | 约束 | 描述 | 默认值 |
|--------|----------|------|------|--------|
| `id` | `BIGINT` | `PRIMARY KEY AUTO_INCREMENT` | 排名ID | `NULL` |
| `type` | `INT` | `NOT NULL` | 排名类型 | `NULL` |
| `roleId` | `BIGINT` | `NOT NULL` | 角色ID | `NULL` |
| `roleName` | `VARCHAR(50)` | `NOT NULL` | 角色名称 | `''` |
| `job` | `INT` | `NOT NULL` | 职业 | `0` |
| `level` | `INT` | `NOT NULL` | 等级 | `0` |
| `rank` | `INT` | `NOT NULL` | 排名 | `0` |
| `score` | `INT` | `NOT NULL` | 分数 | `0` |
| `exp` | `BIGINT` | `NOT NULL` | 经验值 | `0` |
| `equipScore` | `INT` | `NOT NULL` | 装备评分 | `0` |
| `guildId` | `INT` | `NOT NULL` | 公会ID | `0` |
| `guildName` | `VARCHAR(50)` | `NOT NULL` | 公会名称 | `''` |
| `updateTime` | `DATETIME` | `NOT NULL` | 更新时间 | `CURRENT_TIMESTAMP` |
| `createTime` | `DATETIME` | `NOT NULL` | 创建时间 | `CURRENT_TIMESTAMP` |

**索引设计**:

| 索引名 | 索引类型 | 索引字段 | 唯一性 | 用途 |
|--------|----------|----------|--------|------|
| `PRIMARY` | `BTREE` | `id` | `Yes` | 主键索引 |
| `idx_type_role` | `BTREE` | `type, roleId` | `Yes` | 快速查找指定角色的排名 |
| `idx_type_rank` | `BTREE` | `type, rank` | `No` | 按类型和排名查询排行榜 |
| `idx_type_score` | `BTREE` | `type, score` | `No` | 按类型和分数排序 |
| `idx_update_time` | `BTREE` | `updateTime` | `No` | 按更新时间查询 |

**注释**:
- 该表存储玩家的实时排名数据，每种排名类型对每个角色只存储一条记录
- 通过复合索引 `idx_type_role` 确保每个角色在每种排名类型中只存在一条记录
- 使用 `idx_type_rank` 索引加速排行榜查询
- 使用 `idx_type_score` 索引加速排名计算

#### 2.1.2 t_rank_history - 排名历史表

**表名**: `t_rank_history`

**表类型**: 历史表

**存储引擎**: InnoDB

**字符集**: utf8mb4

**表结构**:

| 字段名 | 数据类型 | 约束 | 描述 | 默认值 |
|--------|----------|------|------|--------|
| `id` | `BIGINT` | `PRIMARY KEY AUTO_INCREMENT` | 历史ID | `NULL` |
| `type` | `INT` | `NOT NULL` | 排名类型 | `NULL` |
| `roleId` | `BIGINT` | `NOT NULL` | 角色ID | `NULL` |
| `roleName` | `VARCHAR(50)` | `NOT NULL` | 角色名称 | `''` |
| `rank` | `INT` | `NOT NULL` | 排名 | `0` |
| `score` | `INT` | `NOT NULL` | 分数 | `0` |
| `recordTime` | `DATETIME` | `NOT NULL` | 记录时间 | `CURRENT_TIMESTAMP` |
| `createTime` | `DATETIME` | `NOT NULL` | 创建时间 | `CURRENT_TIMESTAMP` |

**索引设计**:

| 索引名 | 索引类型 | 索引字段 | 唯一性 | 用途 |
|--------|----------|----------|--------|------|
| `PRIMARY` | `BTREE` | `id` | `Yes` | 主键索引 |
| `idx_type_record` | `BTREE` | `type, recordTime` | `No` | 按类型和记录时间查询 |
| `idx_role_id` | `BTREE` | `roleId` | `No` | 按角色ID查询历史 |
| `idx_type_role_record` | `BTREE` | `type, roleId, recordTime` | `No` | 按类型、角色ID和记录时间查询 |

**注释**:
- 该表存储排名历史数据，用于记录玩家排名的变化情况
- 通过 `recordTime` 字段记录排名的具体时间
- 建议定期清理历史数据，只保留最近一段时间的记录

#### 2.1.3 t_rank_config - 排名配置表

**表名**: `t_rank_config`

**表类型**: 配置表

**存储引擎**: InnoDB

**字符集**: utf8mb4

**表结构**:

| 字段名 | 数据类型 | 约束 | 描述 | 默认值 |
|--------|----------|------|------|--------|
| `id` | `BIGINT` | `PRIMARY KEY AUTO_INCREMENT` | 配置ID | `NULL` |
| `type` | `INT` | `NOT NULL UNIQUE` | 排名类型 | `NULL` |
| `name` | `VARCHAR(50)` | `NOT NULL` | 排名名称 | `''` |
| `description` | `VARCHAR(200)` | `NOT NULL` | 排名描述 | `''` |
| `scoreField` | `VARCHAR(50)` | `NOT NULL` | 分数字段 | `''` |
| `updateInterval` | `INT` | `NOT NULL` | 更新间隔(秒) | `60` |
| `maxRank` | `INT` | `NOT NULL` | 最大排名数 | `100` |
| `status` | `INT` | `NOT NULL` | 状态(1-启用, 0-禁用) | `1` |
| `createTime` | `DATETIME` | `NOT NULL` | 创建时间 | `CURRENT_TIMESTAMP` |
| `updateTime` | `DATETIME` | `NOT NULL` | 更新时间 | `CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` |

**索引设计**:

| 索引名 | 索引类型 | 索引字段 | 唯一性 | 用途 |
|--------|----------|----------|--------|------|
| `PRIMARY` | `BTREE` | `id` | `Yes` | 主键索引 |
| `idx_type` | `BTREE` | `type` | `Yes` | 快速查找排名配置 |
| `idx_status` | `BTREE` | `status` | `No` | 按状态查询配置 |

**注释**:
- 该表存储排名类型的配置信息，包括排名名称、描述、更新间隔等
- 通过 `type` 字段的唯一索引确保每种排名类型只存在一条配置
- 可通过修改配置实现排名类型的动态管理

#### 2.1.4 t_rank_reward - 排名奖励表

**表名**: `t_rank_reward`

**表类型**: 配置表

**存储引擎**: InnoDB

**字符集**: utf8mb4

**表结构**:

| 字段名 | 数据类型 | 约束 | 描述 | 默认值 |
|--------|----------|------|------|--------|
| `id` | `BIGINT` | `PRIMARY KEY AUTO_INCREMENT` | 奖励ID | `NULL` |
| `type` | `INT` | `NOT NULL` | 排名类型 | `NULL` |
| `minRank` | `INT` | `NOT NULL` | 最低排名 | `1` |
| `maxRank` | `INT` | `NOT NULL` | 最高排名 | `1` |
| `rewardType` | `INT` | `NOT NULL` | 奖励类型 | `1` |
| `rewardId` | `INT` | `NOT NULL` | 奖励ID | `0` |
| `rewardCount` | `INT` | `NOT NULL` | 奖励数量 | `1` |
| `status` | `INT` | `NOT NULL` | 状态(1-启用, 0-禁用) | `1` |
| `createTime` | `DATETIME` | `NOT NULL` | 创建时间 | `CURRENT_TIMESTAMP` |
| `updateTime` | `DATETIME` | `NOT NULL` | 更新时间 | `CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` |

**索引设计**:

| 索引名 | 索引类型 | 索引字段 | 唯一性 | 用途 |
|--------|----------|----------|--------|------|
| `PRIMARY` | `BTREE` | `id` | `Yes` | 主键索引 |
| `idx_type_rank` | `BTREE` | `type, minRank, maxRank` | `No` | 按类型和排名范围查询奖励 |
| `idx_status` | `BTREE` | `status` | `No` | 按状态查询奖励 |

**注释**:
- 该表存储排名奖励配置，包括不同排名范围对应的奖励内容
- 通过 `minRank` 和 `maxRank` 字段定义奖励的排名范围
- 可通过修改配置实现奖励的动态管理

#### 2.1.5 t_rank_reward_record - 排名奖励发放记录

**表名**: `t_rank_reward_record`

**表类型**: 记录表

**存储引擎**: InnoDB

**字符集**: utf8mb4

**表结构**:

| 字段名 | 数据类型 | 约束 | 描述 | 默认值 |
|--------|----------|------|------|--------|
| `id` | `BIGINT` | `PRIMARY KEY AUTO_INCREMENT` | 记录ID | `NULL` |
| `roleId` | `BIGINT` | `NOT NULL` | 角色ID | `NULL` |
| `type` | `INT` | `NOT NULL` | 排名类型 | `NULL` |
| `rank` | `INT` | `NOT NULL` | 排名 | `0` |
| `rewardId` | `INT` | `NOT NULL` | 奖励ID | `0` |
| `rewardCount` | `INT` | `NOT NULL` | 奖励数量 | `1` |
| `rewardTime` | `DATETIME` | `NOT NULL` | 发放时间 | `CURRENT_TIMESTAMP` |
| `createTime` | `DATETIME` | `NOT NULL` | 创建时间 | `CURRENT_TIMESTAMP` |

**索引设计**:

| 索引名 | 索引类型 | 索引字段 | 唯一性 | 用途 |
|--------|----------|----------|--------|------|
| `PRIMARY` | `BTREE` | `id` | `Yes` | 主键索引 |
| `idx_role_id` | `BTREE` | `roleId` | `No` | 按角色ID查询奖励记录 |
| `idx_type_time` | `BTREE` | `type, rewardTime` | `No` | 按类型和发放时间查询 |
| `idx_role_type` | `BTREE` | `roleId, type` | `No` | 按角色ID和类型查询 |

**注释**:
- 该表存储排名奖励的发放记录，用于跟踪奖励的发放情况
- 通过 `rewardTime` 字段记录奖励的发放时间
- 建议定期清理过期记录，只保留最近一段时间的记录

## 3. 索引优化

### 3.1 核心索引设计

| 表名 | 索引名 | 索引字段 | 索引类型 | 用途 | 预期性能提升 |
|------|--------|----------|----------|------|--------------|
| t_rank | idx_type_role | `type, roleId` | 唯一索引 | 快速查找指定角色的排名 | 90%+ |
| t_rank | idx_type_rank | `type, rank` | 复合索引 | 按类型和排名查询排行榜 | 85%+ |
| t_rank | idx_type_score | `type, score` | 复合索引 | 按类型和分数排序计算排名 | 80%+ |
| t_rank_history | idx_type_record | `type, recordTime` | 复合索引 | 按类型和记录时间查询历史 | 75%+ |
| t_rank_config | idx_type | `type` | 唯一索引 | 快速查找排名配置 | 95%+ |
| t_rank_reward | idx_type_rank | `type, minRank, maxRank` | 复合索引 | 按类型和排名范围查询奖励 | 80%+ |

### 3.2 索引使用建议

1. **查询优化**
   - 对于排行榜查询，使用 `idx_type_rank` 索引加速排序
   - 对于角色排名查询，使用 `idx_type_role` 索引快速定位
   - 对于排名计算，使用 `idx_type_score` 索引加速排序

2. **避免全表扫描**
   - 所有排名相关查询都应使用索引
   - 避免在 `WHERE` 子句中使用函数操作索引字段
   - 保持索引字段的类型一致性

3. **索引维护**
   - 定期重建索引，保持索引效率
   - 监控索引使用情况，及时调整
   - 避免创建过多无用索引

## 4. 分区设计

### 4.1 表分区策略

| 表名 | 分区类型 | 分区字段 | 分区规则 | 预期效果 |
|------|----------|----------|----------|----------|
| t_rank | 范围分区 | `type` | 按排名类型分区 | 提高查询性能，便于管理 |
| t_rank_history | 范围分区 | `recordTime` | 按月份分区 | 提高查询性能，便于历史数据清理 |
| t_rank_reward_record | 范围分区 | `rewardTime` | 按月份分区 | 提高查询性能，便于历史数据清理 |

### 4.2 分区实现示例

**t_rank_history 表分区示例**:

```sql
ALTER TABLE t_rank_history
PARTITION BY RANGE (YEAR(recordTime) * 12 + MONTH(recordTime)) (
    PARTITION p202401 VALUES LESS THAN (2024*12+2),
    PARTITION p202402 VALUES LESS THAN (2024*12+3),
    PARTITION p202403 VALUES LESS THAN (2024*12+4),
    PARTITION p202404 VALUES LESS THAN (2024*12+5),
    PARTITION p202405 VALUES LESS THAN (2024*12+6),
    PARTITION p202406 VALUES LESS THAN (2024*12+7),
    PARTITION p202407 VALUES LESS THAN (2024*12+8),
    PARTITION p202408 VALUES LESS THAN (2024*12+9),
    PARTITION p202409 VALUES LESS THAN (2024*12+10),
    PARTITION p202410 VALUES LESS THAN (2024*12+11),
    PARTITION p202411 VALUES LESS THAN (2024*12+12),
    PARTITION p202412 VALUES LESS THAN (2025*12+1)
);
```

## 5. 缓存设计

### 5.1 缓存策略

| 缓存类型 | 缓存键格式 | 缓存内容 | 过期时间 | 刷新策略 | 预期命中率 |
|----------|------------|----------|----------|----------|------------|
| 个人排名缓存 | `rank:{roleId}:{type}` | 角色排名信息 | 1小时 | 主动更新 | 95%+ |
| 排行榜缓存 | `ranklist:{type}:{page}` | 排行榜分页数据 | 5分钟 | 定时更新 | 80%+ |
| 排名配置缓存 | `rankconfig:{type}` | 排名配置信息 | 24小时 | 配置变更时更新 | 99%+ |
| 排名奖励缓存 | `rankreward:{type}` | 排名奖励配置 | 24小时 | 配置变更时更新 | 99%+ |

### 5.2 缓存实现

**Redis 缓存实现示例**:

```go
// 缓存个人排名
func (s *Store) CacheRank(ctx context.Context, rank *models.Rank) error {
    key := fmt.Sprintf("rank:%d:%d", rank.RoleID, rank.Type)
    val, err := json.Marshal(rank)
    if err != nil {
        return err
    }
    return s.redis.Set(ctx, key, val, time.Hour).Err()
}

// 缓存排行榜
func (s *Store) CacheRankList(ctx context.Context, rankType uint32, page uint32, ranks []*models.Rank) error {
    key := fmt.Sprintf("ranklist:%d:%d", rankType, page)
    val, err := json.Marshal(ranks)
    if err != nil {
        return err
    }
    return s.redis.Set(ctx, key, val, 5*time.Minute).Err()
}

// 获取缓存的个人排名
func (s *Store) GetCachedRank(ctx context.Context, roleID uint64, rankType uint32) (*models.Rank, error) {
    key := fmt.Sprintf("rank:%d:%d", roleID, rankType)
    val, err := s.redis.Get(ctx, key).Result()
    if err != nil {
        return nil, err
    }
    var rank models.Rank
    err = json.Unmarshal([]byte(val), &rank)
    if err != nil {
        return nil, err
    }
    return &rank, nil
}
```

## 6. 数据同步与一致性

### 6.1 数据同步策略

1. **实时同步**
   - 排名数据变更时实时更新数据库
   - 同时更新缓存，确保缓存与数据库一致
   - 对于实时性要求高的排名类型（如等级、战力），使用实时同步

2. **定时同步**
   - 对于实时性要求较低的排名类型（如财富、贡献），使用定时同步
   - 通过定时任务批量更新排名数据
   - 减少数据库压力，提高系统稳定性

3. **批量同步**
   - 使用批处理操作更新排名数据
   - 减少数据库交互次数，提高性能
   - 适用于大量排名数据的更新

### 6.2 一致性保证

1. **事务处理**
   - 使用数据库事务确保排名数据的一致性
   - 在排名更新和重新计算时使用事务
   - 确保排名计算的原子性

2. **锁机制**
   - 在排名重新计算时使用锁机制
   - 防止并发更新导致的排名错误
   - 确保排名计算的准确性

3. **数据验证**
   - 定期验证排名数据的一致性
   - 检查排名计算是否正确
   - 及时发现和修复数据不一致问题

## 7. 数据迁移与初始化

### 7.1 数据迁移

**迁移步骤**:

1. **创建新表结构**
   - 执行建表语句创建排名相关表
   - 创建必要的索引

2. **导入历史数据**
   - 从旧系统导出排名数据
   - 转换数据格式
   - 导入到新表结构

3. **验证数据**
   - 检查数据完整性
   - 验证索引是否正确
   - 测试查询性能

4. **切换系统**
   - 停止旧系统排名更新
   - 启动新系统排名服务
   - 监控系统运行状态

### 7.2 初始化数据

**初始化步骤**:

1. **插入排名配置**
   - 插入默认排名类型配置
   - 设置合理的更新间隔和最大排名数

2. **插入排名奖励**
   - 为每种排名类型设置奖励配置
   - 定义不同排名范围的奖励

3. **初始化缓存**
   - 预热热门排名数据缓存
   - 确保系统启动后能快速响应

4. **启动定时任务**
   - 启动排名更新任务
   - 启动排名奖励发放任务

## 8. 性能优化

### 8.1 查询优化

| 优化项 | 优化策略 | 预期效果 | 实施难度 |
|--------|----------|----------|----------|
| 排行榜查询 | 使用复合索引 `idx_type_rank`，分页查询 | 响应时间 < 50ms | 低 |
| 个人排名查询 | 使用唯一索引 `idx_type_role` | 响应时间 < 10ms | 低 |
| 排名计算 | 使用复合索引 `idx_type_score`，批量排序 | 计算时间 < 1s | 中 |
| 历史数据查询 | 使用分区表，按时间范围查询 | 响应时间 < 100ms | 中 |

### 8.2 写入优化

| 优化项 | 优化策略 | 预期效果 | 实施难度 |
|--------|----------|----------|----------|
| 排名更新 | 使用批量操作，减少数据库交互 | 写入速度提升 50% | 中 |
| 历史记录 | 使用异步写入，不阻塞主流程 | 主流程响应时间不变 | 中 |
| 奖励记录 | 使用批量插入，定期清理 | 写入速度提升 60% | 低 |

### 8.3 存储优化

| 优化项 | 优化策略 | 预期效果 | 实施难度 |
|--------|----------|----------|----------|
| 数据压缩 | 使用 InnoDB 压缩表 | 存储空间减少 30% | 低 |
| 分区存储 | 使用范围分区，按时间或类型分区 | 查询性能提升 40% | 中 |
| 历史数据清理 | 定期清理过期历史数据 | 存储空间减少 50% | 低 |

## 9. 安全考虑

### 9.1 数据安全

1. **数据加密**
   - 对敏感排名数据进行加密存储
   - 使用 SSL/TLS 保护数据传输

2. **访问控制**
   - 限制数据库用户权限
   - 实施最小权限原则
   - 定期审计数据库访问

3. **备份策略**
   - 定期备份排名数据
   - 实施增量备份和全量备份相结合
   - 测试备份恢复流程

### 9.2 防止作弊

1. **数据验证**
   - 验证排名数据的合法性
   - 检测异常的排名变化
   - 限制排名更新频率

2. **日志记录**
   - 记录所有排名相关操作
   - 监控排名异常变化
   - 及时发现和处理作弊行为

3. **防刷机制**
   - 限制排名查询频率
   - 防止恶意请求导致系统负载过高
   - 实施请求限流

## 10. 监控与维护

### 10.1 监控指标

| 监控项 | 监控指标 | 告警阈值 | 监控频率 |
|--------|----------|----------|----------|
| 排名查询 | 响应时间 | > 100ms | 1分钟 |
| 排名更新 | 处理时间 | > 5s | 1分钟 |
| 数据库 | 连接数 | > 80% 最大连接数 | 30秒 |
| 数据库 | 查询缓存命中率 | < 70% | 5分钟 |
| Redis | 内存使用率 | > 80% | 5分钟 |
| Redis | 命中率 | < 75% | 5分钟 |
| 系统负载 | CPU使用率 | > 80% | 30秒 |
| 系统负载 | 内存使用率 | > 85% | 30秒 |

### 10.2 维护计划

| 维护项 | 维护内容 | 维护频率 | 维护窗口 |
|--------|----------|----------|----------|
| 数据库优化 | 重建索引，分析表 | 每周 | 低峰期 |
| 缓存清理 | 清理过期缓存 | 每天 | 低峰期 |
| 历史数据清理 | 清理过期历史记录 | 每月 | 低峰期 |
| 性能分析 | 分析查询性能，优化SQL | 每月 | 低峰期 |
| 安全审计 | 检查访问日志，检测异常 | 每周 | 低峰期 |
| 备份验证 | 测试备份恢复流程 | 每月 | 低峰期 |

## 11. 总结

排名系统数据库设计充分考虑了性能、可扩展性和数据一致性，通过合理的表结构设计、索引优化和缓存策略，确保排名系统能够高效运行并支持大量玩家数据。

**核心优势**:

1. **高性能**：通过复合索引和缓存策略，确保排名查询和更新的快速响应
2. **可扩展性**：通过配置驱动和模块化设计，支持轻松添加新的排名类型
3. **数据一致性**：通过事务处理和锁机制，确保排名数据的准确性
4. **存储空间优化**：通过分区表和数据清理策略，减少存储空间占用
5. **安全性**：通过数据加密和访问控制，确保排名数据的安全

**未来优化方向**:

1. **使用分布式缓存**：进一步提高缓存性能和容量
2. **实施读写分离**：减轻主数据库压力，提高系统吞吐量
3. **使用时序数据库**：优化排名历史数据的存储和查询
4. **引入机器学习**：预测排名变化趋势，优化排名计算

通过本设计文档，排名系统数据库将能够为游戏提供稳定、高效的排名服务，增强游戏的竞争性和社交性，为玩家提供良好的游戏体验。