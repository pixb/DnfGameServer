# 排名系统设计文档

## 概述

排名系统是游戏中的重要功能，用于展示玩家在不同维度的排名，如等级排名、战力排名、副本排名等。

## Java 代码分析

### 核心控制器
- **文件位置**: `src/main/java/com/dnfm/game/rank/RankController.java`
- **处理器数量**: 4 个 @RequestMapping 方法

### 核心功能

#### 1. 查询个人排名 (REQ_INQUIRE_PERSONAL_RANKING)
- **方法**: `ReqInquirePersonalRanking(IoSession session, REQ_INQUIRE_PERSONAL_RANKING reqInquirePersonalRanking)`
- **功能**:
  - 查询指定玩家的排名信息
  - 返回排名数据
  - 当前实现返回错误码 3（未实现）

#### 2. 查询我的排名 (REQ_MY_RANKING)
- **方法**: `reqMyRanking(IoSession session, REQ_MY_RANKING reqMyRanking)`
- **功能**:
  - 查询当前玩家的排名
  - 返回排名数据
  - 当前实现返回错误码 3（未实现）

#### 3. 查询好友排名 (REQ_RANK_FRIEND)
- **方法**: `REQ_RANK_FRIEND(IoSession session, REQ_RANK_FRIEND req_rank_friend)`
- **功能**:
  - 查询好友的排名信息
  - 返回好友排名列表
  - 当前实现返回空列表

#### 4. 查询我的队伍排名 (REQ_MY_PARTY_RANKING)
- **方法**: `reqMyPartyRanking(IoSession session, REQ_MY_PARTY_RANKING reqMyPartyRanking)`
- **功能**:
  - 查询当前玩家队伍的排名
  - 返回队伍排名数据
  - 当前实现返回错误码 3（未实现）

## Go 实现方案

### 1. ProtoBuf 消息定义

#### rank.proto
```protobuf
syntax = "proto3";

package dnf.v1;

option go_package = "gen/dnf/v1";

import "dnf/v1/common.proto";

// 排名信息
message RankInfo {
    uint64 charguid = 1;
    string name = 2;
    uint32 job = 3;
    uint32 level = 4;
    uint32 rank = 5;
    uint32 score = 6;
    uint64 exp = 7;
    uint32 equipscore = 8;
    uint32 guildid = 9;
    string guildname = 10;
}

// 查询个人排名请求
message InquirePersonalRankingRequest {
    uint64 charguid = 1;
    uint32 type = 2;
    uint32 transid = 3;
}

// 查询个人排名响应
message InquirePersonalRankingResponse {
    RankInfo rankinfo = 1;
    uint32 type = 2;
    uint32 error = 3;
    string message = 4;
}

// 查询我的排名请求
message MyRankingRequest {
    uint32 type = 1;
    uint32 transid = 2;
}

// 查询我的排名响应
message MyRankingResponse {
    RankInfo rankinfo = 1;
    uint32 type = 2;
    uint32 error = 3;
    string message = 4;
}

// 查询好友排名请求
message RankFriendRequest {
    uint32 type = 1;
    uint32 transid = 2;
}

// 查询好友排名响应
message RankFriendResponse {
    repeated RankInfo ranking = 1;
    uint32 type = 2;
    uint32 error = 3;
    string message = 4;
}

// 查询我的队伍排名请求
message MyPartyRankingRequest {
    uint32 type = 1;
    uint32 transid = 2;
}

// 查询我的队伍排名响应
message MyPartyRankingResponse {
    RankInfo rankinfo = 1;
    uint32 type = 2;
    uint32 error = 3;
    string message = 4;
}

// 排行榜列表请求
message RankingListRequest {
    uint32 type = 1;
    uint32 page = 2;
    uint32 page_size = 3;
}

// 排行榜列表响应
message RankingListResponse {
    repeated RankInfo ranking = 1;
    uint32 type = 2;
    uint32 total = 3;
    uint32 error = 4;
    string message = 5;
}
```

### 2. 数据模型设计

#### models/rank.go
```go
package models

import (
    "time"
    "gorm.io/gorm"
)

// Rank 排名
type Rank struct {
    ID         uint64    `gorm:"primaryKey;column:id" json:"id"`
    Type       uint32    `gorm:"column:type;index:idx_type_rank" json:"type"`
    RoleID     uint64    `gorm:"column:roleId;uniqueIndex:idx_type_role;index" json:"role_id"`
    RoleName   string    `gorm:"column:roleName;size:50" json:"role_name"`
    Job        uint32    `gorm:"column:job" json:"job"`
    Level      uint32    `gorm:"column:level" json:"level"`
    Rank       uint32    `gorm:"column:rank;index:idx_type_rank" json:"rank"`
    Score      uint32    `gorm:"column:score;index:idx_type_score" json:"score"`
    Exp        uint64    `gorm:"column:exp" json:"exp"`
    EquipScore uint32    `gorm:"column:equipScore" json:"equip_score"`
    GuildID    uint32    `gorm:"column:guildId" json:"guild_id"`
    GuildName  string    `gorm:"column:guildName;size:50" json:"guild_name"`
    UpdateTime time.Time `gorm:"column:updateTime;index" json:"update_time"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (Rank) TableName() string {
    return "t_rank"
}

// RankHistory 排名历史
type RankHistory struct {
    ID         uint64    `gorm:"primaryKey;column:id" json:"id"`
    Type       uint32    `gorm:"column:type;index" json:"type"`
    RoleID     uint64    `gorm:"column:roleId;index" json:"role_id"`
    RoleName   string    `gorm:"column:roleName;size:50" json:"role_name"`
    Rank       uint32    `gorm:"column:rank" json:"rank"`
    Score      uint32    `gorm:"column:score" json:"score"`
    RecordTime time.Time `gorm:"column:recordTime;index" json:"record_time"`
    CreateTime time.Time `gorm:"column:createTime" json:"create_time"`
}

func (RankHistory) TableName() string {
    return "t_rank_history"
}

// RankConfig 排名配置
type RankConfig struct {
    ID          uint64    `gorm:"primaryKey;column:id" json:"id"`
    Type        uint32    `gorm:"column:type;uniqueIndex" json:"type"`
    Name        string    `gorm:"column:name;size:50" json:"name"`
    Description string    `gorm:"column:description;size:200" json:"description"`
    ScoreField  string    `gorm:"column:scoreField;size:50" json:"score_field"`
    UpdateInterval uint32 `gorm:"column:updateInterval" json:"update_interval"`
    MaxRank     uint32    `gorm:"column:maxRank" json:"max_rank"`
    Status      uint32    `gorm:"column:status;default:1" json:"status"`
    CreateTime  time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime  time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (RankConfig) TableName() string {
    return "t_rank_config"
}
```

### 3. Handler 实现

#### handlers/rank.go
```go
package handlers

import (
    "context"

    "github.com/pixb/DnfGameServer/dnf-go-server/internal/game/rank_service"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/network"
    dnfv1 "github.com/pixb/DnfGameServer/dnf-go-server/proto/gen/dnf/v1"
    "google.golang.org/protobuf/proto"
)

type RankHandler struct {
    rankService *rank_service.RankService
}

func NewRankHandler(rankService *rank_service.RankService) *RankHandler {
    return &RankHandler{
        rankService: rankService,
    }
}

// InquirePersonalRankingHandler 查询个人排名处理器
func (h *RankHandler) InquirePersonalRankingHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.InquirePersonalRankingRequest)
    if !ok {
        return
    }

    rankInfo, err := h.rankService.GetPersonalRank(context.Background(), req.Charguid, req.Type)
    if err != nil {
        h.sendError(sess, req, 3, "failed to get personal ranking")
        return
    }

    resp := &dnfv1.InquirePersonalRankingResponse{
        Rankinfo: rankInfo,
        Type:     req.Type,
        Error:    0,
    }
    sess.Send(resp)
}

// MyRankingHandler 查询我的排名处理器
func (h *RankHandler) MyRankingHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MyRankingRequest)
    if !ok {
        return
    }

    rankInfo, err := h.rankService.GetMyRank(context.Background(), sess.RoleID, req.Type)
    if err != nil {
        h.sendError(sess, req, 3, "failed to get my ranking")
        return
    }

    resp := &dnfv1.MyRankingResponse{
        Rankinfo: rankInfo,
        Type:     req.Type,
        Error:    0,
    }
    sess.Send(resp)
}

// RankFriendHandler 查询好友排名处理器
func (h *RankHandler) RankFriendHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.RankFriendRequest)
    if !ok {
        return
    }

    rankings, err := h.rankService.GetFriendRankings(context.Background(), sess.RoleID, req.Type)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get friend rankings")
        return
    }

    resp := &dnfv1.RankFriendResponse{
        Ranking: rankings,
        Type:    req.Type,
        Error:   0,
    }
    sess.Send(resp)
}

// MyPartyRankingHandler 查询我的队伍排名处理器
func (h *RankHandler) MyPartyRankingHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MyPartyRankingRequest)
    if !ok {
        return
    }

    rankInfo, err := h.rankService.GetMyPartyRank(context.Background(), sess.RoleID, req.Type)
    if err != nil {
        h.sendError(sess, req, 3, "failed to get my party ranking")
        return
    }

    resp := &dnfv1.MyPartyRankingResponse{
        Rankinfo: rankInfo,
        Type:     req.Type,
        Error:    0,
    }
    sess.Send(resp)
}

// RankingListHandler 排行榜列表处理器
func (h *RankHandler) RankingListHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.RankingListRequest)
    if !ok {
        return
    }

    rankings, total, err := h.rankService.GetRankingList(context.Background(), req.Type, req.Page, req.PageSize)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get ranking list")
        return
    }

    resp := &dnfv1.RankingListResponse{
        Ranking: rankings,
        Type:    req.Type,
        Total:   total,
        Error:   0,
    }
    sess.Send(resp)
}

func (h *RankHandler) sendError(sess *network.Session, req proto.Message, code uint32, message string) {
    switch req.(type) {
    case *dnfv1.InquirePersonalRankingRequest:
        resp := &dnfv1.InquirePersonalRankingResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.MyRankingRequest:
        resp := &dnfv1.MyRankingResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.RankFriendRequest:
        resp := &dnfv1.RankFriendResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.MyPartyRankingRequest:
        resp := &dnfv1.MyPartyRankingResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.RankingListRequest:
        resp := &dnfv1.RankingListResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    }
}
```

### 4. Service 实现

#### rank_service/rank.go
```go
package rank_service

import (
    "context"
    "time"

    "github.com/pixb/DnfGameServer/dnf-go-server/store"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/db/models"
    dnfv1 "github.com/pixb/DnfGameServer/dnf-go-server/proto/gen/dnf/v1"
)

type RankService struct {
    store *store.Store
}

func NewRankService(store *store.Store) *RankService {
    return &RankService{
        store: store,
    }
}

// GetPersonalRank 获取个人排名
func (s *RankService) GetPersonalRank(ctx context.Context, roleID uint64, rankType uint32) (*dnfv1.RankInfo, error) {
    rank, err := s.store.GetRank(ctx, roleID, rankType)
    if err != nil {
        return nil, err
    }

    return &dnfv1.RankInfo{
        Charguid:   rank.RoleID,
        Name:       rank.RoleName,
        Job:        rank.Job,
        Level:      rank.Level,
        Rank:       rank.Rank,
        Score:      rank.Score,
        Exp:        rank.Exp,
        Equipscore: rank.EquipScore,
        Guildid:    rank.GuildID,
        Guildname:  rank.GuildName,
    }, nil
}

// GetMyRank 获取我的排名
func (s *RankService) GetMyRank(ctx context.Context, roleID uint64, rankType uint32) (*dnfv1.RankInfo, error) {
    return s.GetPersonalRank(ctx, roleID, rankType)
}

// GetFriendRankings 获取好友排名
func (s *RankService) GetFriendRankings(ctx context.Context, roleID uint64, rankType uint32) ([]*dnfv1.RankInfo, error) {
    // 1. 获取好友列表
    friends, err := s.store.GetFriendList(ctx, roleID)
    if err != nil {
        return nil, err
    }

    if len(friends) == 0 {
        return []*dnfv1.RankInfo{}, nil
    }

    // 2. 获取好友排名
    roleIDs := make([]uint64, len(friends))
    for i, friend := range friends {
        roleIDs[i] = friend.FriendID
    }

    ranks, err := s.store.GetRanksByRoleIDs(ctx, roleIDs, rankType)
    if err != nil {
        return nil, err
    }

    // 3. 转换为响应格式
    rankings := make([]*dnfv1.RankInfo, len(ranks))
    for i, rank := range ranks {
        rankings[i] = &dnfv1.RankInfo{
            Charguid:   rank.RoleID,
            Name:       rank.RoleName,
            Job:        rank.Job,
            Level:      rank.Level,
            Rank:       rank.Rank,
            Score:      rank.Score,
            Exp:        rank.Exp,
            Equipscore: rank.EquipScore,
            Guildid:    rank.GuildID,
            Guildname:  rank.GuildName,
        }
    }

    return rankings, nil
}

// GetMyPartyRank 获取我的队伍排名
func (s *RankService) GetMyPartyRank(ctx context.Context, roleID uint64, rankType uint32) (*dnfv1.RankInfo, error) {
    // 1. 获取队伍信息
    party, err := s.store.GetPartyByRoleID(ctx, roleID)
    if err != nil {
        return nil, err
    }

    // 2. 计算队伍总分
    members, err := s.store.GetPartyMembers(ctx, party.ID)
    if err != nil {
        return nil, err
    }

    totalScore := uint32(0)
    for _, member := range members {
        rank, err := s.store.GetRank(ctx, member.RoleID, rankType)
        if err == nil {
            totalScore += rank.Score
        }
    }

    // 3. 返回队伍排名信息
    return &dnfv1.RankInfo{
        Charguid: party.ID,
        Name:     party.Name,
        Rank:     party.Rank,
        Score:    totalScore,
    }, nil
}

// GetRankingList 获取排行榜列表
func (s *RankService) GetRankingList(ctx context.Context, rankType, page, pageSize uint32) ([]*dnfv1.RankInfo, uint32, error) {
    offset := (page - 1) * pageSize

    ranks, total, err := s.store.GetRanksByType(ctx, rankType, offset, pageSize)
    if err != nil {
        return nil, 0, err
    }

    rankings := make([]*dnfv1.RankInfo, len(ranks))
    for i, rank := range ranks {
        rankings[i] = &dnfv1.RankInfo{
            Charguid:   rank.RoleID,
            Name:       rank.RoleName,
            Job:        rank.Job,
            Level:      rank.Level,
            Rank:       rank.Rank,
            Score:      rank.Score,
            Exp:        rank.Exp,
            Equipscore: rank.EquipScore,
            Guildid:    rank.GuildID,
            Guildname:  rank.GuildName,
        }
    }

    return rankings, uint32(total), nil
}

// UpdateRank 更新排名
func (s *RankService) UpdateRank(ctx context.Context, roleID uint64, rankType uint32, score uint32) error {
    // 1. 获取角色信息
    role, err := s.store.GetRole(ctx, roleID)
    if err != nil {
        return err
    }

    // 2. 获取公会信息
    guildName := ""
    if role.GuildID > 0 {
        guild, err := s.store.GetGuild(ctx, role.GuildID)
        if err == nil {
            guildName = guild.Name
        }
    }

    // 3. 更新或创建排名
    rank, err := s.store.GetRank(ctx, roleID, rankType)
    if err == nil {
        rank.Score = score
        rank.Level = role.Level
        rank.Exp = role.Exp
        rank.EquipScore = role.EquipScore
        rank.GuildID = role.GuildID
        rank.GuildName = guildName
        rank.UpdateTime = time.Now()
        return s.store.UpdateRank(ctx, rank)
    }

    newRank := &models.Rank{
        Type:       rankType,
        RoleID:     roleID,
        RoleName:   role.Name,
        Job:        role.Job,
        Level:      role.Level,
        Score:      score,
        Exp:        role.Exp,
        EquipScore: role.EquipScore,
        GuildID:    role.GuildID,
        GuildName:  guildName,
        UpdateTime: time.Now(),
        CreateTime: time.Now(),
    }

    return s.store.CreateRank(ctx, newRank)
}

// RecalculateRank 重新计算排名
func (s *RankService) RecalculateRank(ctx context.Context, rankType uint32) error {
    return s.store.RecalculateRank(ctx, rankType)
}

// SaveRankHistory 保存排名历史
func (s *RankService) SaveRankHistory(ctx context.Context, rankType uint32) error {
    ranks, err := s.store.GetRanksByType(ctx, rankType, 0, 100)
    if err != nil {
        return err
    }

    for _, rank := range ranks {
        history := &models.RankHistory{
            Type:       rankType,
            RoleID:     rank.RoleID,
            RoleName:   rank.RoleName,
            Rank:       rank.Rank,
            Score:      rank.Score,
            RecordTime: time.Now(),
            CreateTime: time.Now(),
        }
        s.store.CreateRankHistory(ctx, history)
    }

    return nil
}
```

## 实现步骤

### 步骤 1: 创建 ProtoBuf 定义
1. 创建 `proto/dnf/v1/rank.proto`
2. 定义所有排名相关的消息
3. 运行 `buf generate` 生成 Go 代码

### 步骤 2: 创建数据模型
1. 创建 `internal/db/models/rank.go`
2. 定义 Rank、RankHistory、RankConfig 模型
3. 运行数据库迁移

### 步骤 3: 实现 Handler
1. 创建 `internal/game/handlers/rank.go`
2. 实现所有排名相关的处理器
3. 注册消息路由

### 步骤 4: 实现 Service
1. 创建 `internal/game/rank_service/rank.go`
2. 实现业务逻辑
3. 集成数据库操作

### 步骤 5: 编写测试用例
1. 创建 `tests/rank_test.go`
2. 编写所有功能的测试用例
3. 运行测试验证

### 步骤 6: 集成到主服务器
1. 在 `cmd/server/main.go` 中注册 Handler
2. 更新消息注册表
3. 测试完整流程

## 注意事项

1. **排名计算**: 正确实现排名计算逻辑
2. **性能优化**: 大量数据时需要优化查询性能
3. **缓存机制**: 使用缓存减少数据库查询
4. **定时更新**: 定时更新排名数据
5. **历史记录**: 保存排名历史数据
6. **并发控制**: 处理并发更新排名的情况
7. **错误处理**: 完善的错误处理和日志记录
8. **排名类型**: 支持多种排名类型（等级、战力、副本等）
