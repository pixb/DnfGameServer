# 组队系统设计文档

## 文档导航

- [系统概述](02_组队系统/系统概述.md)
- [Java代码分析](02_组队系统/Java代码分析.md)
- [Go实现方案](02_组队系统/Go实现方案.md)
- [API文档](02_组队系统/API文档.md)
- [数据库设计文档](02_组队系统/数据库设计文档.md)
- [业务流程文档](02_组队系统/业务流程文档.md)
- [测试用例文档](02_组队系统/测试用例文档.md)
- [部署文档](02_组队系统/部署文档.md)
- [监控与维护](02_组队系统/监控与维护.md)
- [变更记录](02_组队系统/变更记录.md)

## 1. 系统概述

### 1.1 系统简介
- 系统名称：组队系统
- 系统功能：多人协作游戏的核心功能，支持玩家创建队伍、加入队伍、邀请玩家、队伍管理、多人副本等操作
- 系统位置：游戏客户端与服务端交互的核心系统之一，是玩家进行多人协作游戏的基础

### 1.2 核心流程
- 玩家可以通过组队系统创建队伍、搜索队伍、加入队伍、邀请其他玩家加入队伍
- 队伍成员可以进行队伍管理操作，如踢出成员、转让队长、设置队伍属性等
- 队伍可以进入多人副本，系统负责匹配、分配战斗服务器、同步副本状态等
- 系统支持半公开队伍、推荐队伍、队伍移动建议等高级功能

## 2. Java 代码分析

### 2.1 核心控制器
- **文件位置**: `src/main/java/com/dnfm/game/party/PartyController.java`
- **处理器数量**: 23 个 @RequestMapping 方法

### 2.2 核心功能

#### 2.2.1 半公开队伍接受 (REQ_HALF_OPEN_PARTY_ACCEPT)
- **方法**: `REQ_HALF_OPEN_PARTY_ACCEPT(IoSession session, REQ_HALF_OPEN_PARTY_ACCEPT req_half_open_party_accept)`
- **功能**:
  - 接受半公开队伍邀请
  - 返回队伍信息
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_half_open_party_accept`: 半公开队伍接受请求对象
- **返回数据**:
  - 队伍信息

#### 2.2.2 半公开队伍拒绝 (REQ_HALF_OPEN_PARTY_REFUSE)
- **方法**: `REQ_HALF_OPEN_PARTY_REFUSE(IoSession session, REQ_HALF_OPEN_PARTY_REFUSE req_half_open_party_refuse)`
- **功能**:
  - 拒绝半公开队伍邀请
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_half_open_party_refuse`: 半公开队伍拒绝请求对象
- **返回数据**:
  - 拒绝结果

#### 2.2.3 控制队伍自定义 (REQ_CONTROL_GROUP_CUSTOM)
- **方法**: `REQ_CONTROL_GROUP_CUSTOM(IoSession session, REQ_CONTROL_GROUP_CUSTOM req_control_group_custom)`
- **功能**:
  - 控制队伍自定义数据
  - 广播给队伍成员
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_control_group_custom`: 控制队伍自定义请求对象
- **返回数据**:
  - 自定义结果

#### 2.2.4 开始多人游戏 (REQ_START_MULTI_PLAY)
- **方法**: `REQ_START_MULTI_PLAY(IoSession session, REQ_START_MULTI_PLAY req_start_multi_play)`
- **功能**:
  - 开始多人游戏
  - 初始化副本地图
  - 分配玩家 ID
  - 返回匹配信息
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_start_multi_play`: 开始多人游戏请求对象
- **返回数据**:
  - 匹配 GUID
  - 副本 GUID
  - 战斗服务器信息
  - 匹配类型
  - 玩家列表

#### 2.2.5 搜索队伍列表 (REQ_SEARCH_PARTY_LIST)
- **方法**: `REQ_SEARCH_PARTY_LIST(IoSession session, REQ_SEARCH_PARTY_LIST req_search_party_list)`
- **功能**:
  - 搜索可加入的队伍
  - 返回队伍列表
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_search_party_list`: 搜索队伍列表请求对象
- **返回数据**:
  - 队伍列表

#### 2.2.6 推荐队伍 (REQ_RECOMMAND_GROUP)
- **方法**: `REQ_RECOMMAND_GROUP(IoSession session, REQ_RECOMMAND_GROUP req_recommand_group)`
- **功能**:
  - 推荐队伍
  - 返回推荐队伍信息
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_recommand_group`: 推荐队伍请求对象
- **返回数据**:
  - 推荐队伍列表

#### 2.2.7 控制队伍 (REQ_CONTROL_GROUP)
- **方法**: `REQ_CONTROL_GROUP(IoSession session, REQ_CONTROL_GROUP req_control_group)`
- **功能**:
  - 控制队伍
  - 队长操作
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_control_group`: 控制队伍请求对象
- **返回数据**:
  - 控制结果

#### 2.2.8 控制队伍查询区域 (REQ_CONTROL_GROUP_QUERYAREA)
- **方法**: `REQ_CONTROL_GROUP_QUERYAREA(IoSession session, REQ_CONTROL_GROUP_QUERYAREA req_control_group_queryarea)`
- **功能**:
  - 查询队伍区域
  - 返回区域信息
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_control_group_queryarea`: 控制队伍查询区域请求对象
- **返回数据**:
  - 区域信息

#### 2.2.9 半公开队伍加入 (REQ_HALF_OPEN_PARTY_JOIN)
- **方法**: `REQ_HALF_OPEN_PARTY_JOIN(IoSession session, REQ_HALF_OPEN_PARTY_JOIN req_half_open_party_join)`
- **功能**:
  - 加入半公开队伍
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_half_open_party_join`: 半公开队伍加入请求对象
- **返回数据**:
  - 加入结果

#### 2.2.10 多人游戏副本条件 (REQ_PARTY_DUNGEON_CONDITION)
- **方法**: `REQ_PARTY_DUNGEON_CONDITION(IoSession session, REQ_PARTY_DUNGEON_CONDITION req_party_dungeon_condition)`
- **功能**:
  - 获取多人副本条件
  - 返回副本条件信息
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_party_dungeon_condition`: 多人游戏副本条件请求对象
- **返回数据**:
  - 副本条件信息

#### 2.2.11 多人游戏同步副本 (REQ_MULTI_PLAY_SYNC_DUNGEON)
- **方法**: `REQ_MULTI_PLAY_SYNC_DUNGEON(IoSession session, REQ_MULTI_PLAY_SYNC_DUNGEON req_multi_play_sync_dungeon)`
- **功能**:
  - 同步多人副本状态
  - 返回同步信息
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_multi_play_sync_dungeon`: 多人游戏同步副本请求对象
- **返回数据**:
  - 同步结果

#### 2.2.12 多人游戏副本进入完成 (REQ_MULTI_PLAY_DUNGEON_ENTER_COMPLETE)
- **方法**: `REQ_MULTI_PLAY_DUNGEON_ENTER_COMPLETE(IoSession session, REQ_MULTI_PLAY_DUNGEON_ENTER_COMPLETE req_multi_play_dungeon_enter_complete)`
- **功能**:
  - 多人副本进入完成
  - 返回完成状态
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_multi_play_dungeon_enter_complete`: 多人游戏副本进入完成请求对象
- **返回数据**:
  - 完成状态

#### 2.2.13 多人游戏开始副本 (REQ_MULTI_PLAY_START_DUNGEON)
- **方法**: `REQ_MULTI_PLAY_START_DUNGEON(IoSession session, REQ_MULTI_PLAY_START_DUNGEON req_multi_play_start_dungeon)`
- **功能**:
  - 开始多人副本
  - 初始化副本数据
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_multi_play_start_dungeon`: 多人游戏开始副本请求对象
- **返回数据**:
  - 开始结果

#### 2.2.14 队伍加载状态 (REQ_PARTY_LOADING_STATUS)
- **方法**: `REQ_PARTY_LOADING_STATUS(IoSession session, REQ_PARTY_LOADING_STATUS req_party_loading_status)`
- **功能**:
  - 获取队伍加载状态
  - 返回加载进度
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_party_loading_status`: 队伍加载状态请求对象
- **返回数据**:
  - 加载中玩家列表
  - 准备就绪玩家列表

#### 2.2.15 准备锁定步骤 (REQ_READY_TO_LOCKSTEP)
- **方法**: `REQ_READY_TO_LOCKSTEP(IoSession session, REQ_READY_TO_LOCKSTEP req_ready_to_lockstep)`
- **功能**:
  - 准备锁定步骤
  - 返回锁定状态
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_ready_to_lockstep`: 准备锁定步骤请求对象
- **返回数据**:
  - 锁定状态

#### 2.2.16 请求进入副本接受 (REQ_REQUEST_TO_RE_ENTER_ACCEPT_DUNGEON)
- **方法**: `REQ_REQUEST_TO_RE_ENTER_ACCEPT_DUNGEON(IoSession session, REQ_REQUEST_TO_RE_ENTER_ACCEPT_DUNGEON req_request_to_re_enter_accept_dungeon)`
- **功能**:
  - 接受重新进入副本请求
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_request_to_re_enter_accept_dungeon`: 请求进入副本接受请求对象
- **返回数据**:
  - 接受结果

#### 2.2.17 请求进入副本 (REQ_REQUEST_TO_RE_ENTER_DUNGEON)
- **方法**: `REQ_REQUEST_TO_RE_ENTER_DUNGEON(IoSession session, REQ_REQUEST_TO_RE_ENTER_DUNGEON req_request_to_re_enter_dungeon)`
- **功能**:
  - 请求重新进入副本
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_request_to_re_enter_dungeon`: 请求进入副本请求对象
- **返回数据**:
  - 请求结果

#### 2.2.18 建议移动队伍 (REQ_SUGGEST_MOVE_PARTY)
- **方法**: `REQ_SUGGEST_MOVE_PARTY(IoSession session, REQ_SUGGEST_MOVE_PARTY req_suggest_move_party)`
- **功能**:
  - 建议队伍移动
  - 返回移动建议
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_suggest_move_party`: 建议移动队伍请求对象
- **返回数据**:
  - 移动建议

#### 2.2.19 目标用户队伍信息 (REQ_TARGET_USER_PARTY_INFO)
- **方法**: `REQ_TARGET_USER_PARTY_INFO(IoSession session, REQ_TARGET_USER_PARTY_INFO req_target_user_party_info)`
- **功能**:
  - 获取目标用户队伍信息
  - 返回队伍详情
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_target_user_party_info`: 目标用户队伍信息请求对象
- **返回数据**:
  - 队伍详情

#### 2.2.20 等待用户加载 (REQ_WAITING_TO_USERS_LOADING)
- **方法**: `REQ_WAITING_TO_USERS_LOADING(IoSession session, REQ_WAITING_TO_USERS_LOADING req_waiting_to_users_loading)`
- **功能**:
  - 等待用户加载
  - 返回加载状态
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_waiting_to_users_loading`: 等待用户加载请求对象
- **返回数据**:
  - 加载状态

#### 2.2.21 投票踢出用户 (REQ_VOTE_KICK_OUT_USER)
- **方法**: `REQ_VOTE_KICK_OUT_USER(IoSession session, REQ_VOTE_KICK_OUT_USER req_vote_kick_out_user)`
- **功能**:
  - 投票踢出队伍成员
  - 返回投票结果
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_vote_kick_out_user`: 投票踢出用户请求对象
- **返回数据**:
  - 投票结果

#### 2.2.22 连接战斗服务器 (REQ_CONNECT_BATTLE_SERVER)
- **方法**: `REQ_CONNECT_BATTLE_SERVER(IoSession session, REQ_CONNECT_BATTLE_SERVER req_connect_battle_server)`
- **功能**:
  - 连接战斗服务器
  - 返回连接信息
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_connect_battle_server`: 连接战斗服务器请求对象
- **返回数据**:
  - 战斗服务器连接信息

#### 2.2.23 检查禁用词 (REQ_CHECK_PROHIBITED_WORD)
- **方法**: `REQ_CHECK_PROHIBITED_WORD(IoSession session, REQ_CHECK_PROHIBITED_WORD req_check_prohibited_word)`
- **功能**:
  - 检查禁用词
  - 返回检查结果
- **参数**:
  - `session`: IoSession 对象，客户端会话
  - `req_check_prohibited_word`: 检查禁用词请求对象
- **返回数据**:
  - 检查结果

## 3. Go 实现方案

### 3.1 ProtoBuf 消息定义

#### party.proto
```protobuf
syntax = "proto3";

package dnf.v1;

option go_package = "gen/dnf/v1";

import "dnf/v1/common.proto";

// 队伍成员
message GroupMember {
    uint64 charguid = 1;
    string name = 2;
    uint32 job = 3;
    uint32 level = 4;
    uint32 growtype = 5;
    uint32 secondgrowtype = 6;
    uint32 teamtype = 7;
    uint32 playerid = 8;
    uint64 objectgroupid = 9;
    bool ready = 10;
    bool waiting = 11;
}

// 队伍信息
message PartyInfo {
    uint64 partyguid = 1;
    uint64 leaderguid = 2;
    string name = 3;
    uint32 maxmembers = 4;
    repeated GroupMember members = 5;
    uint32 dungeonindex = 6;
    uint32 roomid = 7;
}

// 搜索队伍请求
message SearchPartyListRequest {
    uint32 dungeonindex = 1;
    uint32 minlevel = 2;
    uint32 maxlevel = 3;
}

// 搜索队伍响应
message SearchPartyListResponse {
    repeated PartyInfo parties = 1;
    uint32 error = 2;
    string message = 3;
}

// 推荐队伍请求
message RecommendGroupRequest {
    uint32 dungeonindex = 1;
}

// 推荐队伍响应
message RecommendGroupResponse {
    repeated PartyInfo parties = 1;
    uint32 error = 2;
    string message = 3;
}

// 控制队伍请求
message ControlGroupRequest {
    uint32 action = 1;
    uint64 targetguid = 2;
}

// 控制队伍响应
message ControlGroupResponse {
    uint32 error = 2;
    string message = 3;
}

// 开始多人游戏请求
message StartMultiPlayRequest {
    uint32 input = 1;
    uint32 type = 2;
    uint32 index = 3;
    uint64 partyguid = 4;
}

// 开始多人游戏响应
message StartMultiPlayResponse {
    uint64 matchingguid = 1;
    uint64 dungeonguid = 2;
    uint32 battleworld = 3;
    uint32 bchannel = 4;
    string bip = 5;
    uint32 bport = 6;
    uint32 matchtype = 7;
    uint32 world = 8;
    uint32 channel = 9;
    repeated uint64 users = 10;
    repeated UserMinimumInfo detail = 11;
    uint32 error = 12;
    string message = 13;
}

// 用户最小信息
message UserMinimumInfo {
    uint64 charguid = 1;
    uint32 job = 2;
    uint32 growtype = 3;
    uint32 secondgrowtype = 4;
    uint32 level = 5;
    string name = 6;
    uint32 teamtype = 7;
    uint32 world = 8;
}

// 多人游戏同步副本请求
message MultiPlaySyncDungeonRequest {
    uint32 stageid = 1;
    uint32 progress = 2;
}

// 多人游戏同步副本响应
message MultiPlaySyncDungeonResponse {
    uint32 error = 2;
    string message = 3;
}

// 多人游戏副本进入完成请求
message MultiPlayDungeonEnterCompleteRequest {
    uint32 stageid = 1;
}

// 多人游戏副本进入完成响应
message MultiPlayDungeonEnterCompleteResponse {
    uint32 error = 2;
    string message = 3;
}

// 队伍加载状态请求
message PartyLoadingStatusRequest {
}

// 队伍加载状态响应
message PartyLoadingStatusResponse {
    repeated uint64 loadingusers = 1;
    repeated uint64 readyusers = 2;
    uint32 error = 3;
    string message = 4;
}

// 半公开队伍接受请求
message HalfOpenPartyAcceptRequest {
    uint64 partyguid = 1;
}

// 半公开队伍接受响应
message HalfOpenPartyAcceptResponse {
    PartyInfo party = 1;
    uint32 error = 2;
    string message = 3;
}

// 半公开队伍拒绝请求
message HalfOpenPartyRefuseRequest {
    uint64 partyguid = 1;
}

// 半公开队伍拒绝响应
message HalfOpenPartyRefuseResponse {
    uint32 error = 1;
    string message = 2;
}

// 控制队伍自定义请求
message ControlGroupCustomRequest {
    uint64 partyguid = 1;
    uint32 type = 2;
    bytes data = 3;
}

// 控制队伍自定义响应
message ControlGroupCustomResponse {
    uint32 error = 1;
    string message = 2;
}

// 控制队伍查询区域请求
message ControlGroupQueryAreaRequest {
    uint64 partyguid = 1;
}

// 控制队伍查询区域响应
message ControlGroupQueryAreaResponse {
    uint32 area = 1;
    uint32 error = 2;
    string message = 3;
}

// 半公开队伍加入请求
message HalfOpenPartyJoinRequest {
    uint64 partyguid = 1;
}

// 半公开队伍加入响应
message HalfOpenPartyJoinResponse {
    PartyInfo party = 1;
    uint32 error = 2;
    string message = 3;
}

// 多人游戏副本条件请求
message PartyDungeonConditionRequest {
    uint32 dungeonindex = 1;
}

// 多人游戏副本条件响应
message PartyDungeonConditionResponse {
    uint32 level = 1;
    uint32疲劳 = 2;
    uint32门票 = 3;
    uint32 error = 4;
    string message = 5;
}

// 多人游戏开始副本请求
message MultiPlayStartDungeonRequest {
    uint64 partyguid = 1;
    uint32 dungeonindex = 2;
}

// 多人游戏开始副本响应
message MultiPlayStartDungeonResponse {
    uint32 error = 1;
    string message = 2;
}

// 准备锁定步骤请求
message ReadyToLockstepRequest {
    uint64 partyguid = 1;
}

// 准备锁定步骤响应
message ReadyToLockstepResponse {
    bool locked = 1;
    uint32 error = 2;
    string message = 3;
}

// 请求进入副本接受请求
message RequestToReEnterAcceptDungeonRequest {
    uint64 partyguid = 1;
}

// 请求进入副本接受响应
message RequestToReEnterAcceptDungeonResponse {
    uint32 error = 1;
    string message = 2;
}

// 请求进入副本请求
message RequestToReEnterDungeonRequest {
    uint64 partyguid = 1;
    uint32 dungeonindex = 2;
}

// 请求进入副本响应
message RequestToReEnterDungeonResponse {
    uint32 error = 1;
    string message = 2;
}

// 建议移动队伍请求
message SuggestMovePartyRequest {
    uint64 partyguid = 1;
    uint32 area = 2;
}

// 建议移动队伍响应
message SuggestMovePartyResponse {
    bool accepted = 1;
    uint32 error = 2;
    string message = 3;
}

// 目标用户队伍信息请求
message TargetUserPartyInfoRequest {
    uint64 charguid = 1;
}

// 目标用户队伍信息响应
message TargetUserPartyInfoResponse {
    PartyInfo party = 1;
    uint32 error = 2;
    string message = 3;
}

// 等待用户加载请求
message WaitingToUsersLoadingRequest {
    uint64 partyguid = 1;
}

// 等待用户加载响应
message WaitingToUsersLoadingResponse {
    repeated uint64 loadingusers = 1;
    uint32 error = 2;
    string message = 3;
}

// 投票踢出用户请求
message VoteKickOutUserRequest {
    uint64 partyguid = 1;
    uint64 targetguid = 2;
}

// 投票踢出用户响应
message VoteKickOutUserResponse {
    uint32 votes = 1;
    uint32 required = 2;
    uint32 error = 3;
    string message = 4;
}

// 连接战斗服务器请求
message ConnectBattleServerRequest {
    uint64 matchingguid = 1;
}

// 连接战斗服务器响应
message ConnectBattleServerResponse {
    string ip = 1;
    uint32 port = 2;
    uint32 error = 3;
    string message = 4;
}

// 检查禁用词请求
message CheckProhibitedWordRequest {
    string text = 1;
}

// 检查禁用词响应
message CheckProhibitedWordResponse {
    bool prohibited = 1;
    uint32 error = 2;
    string message = 3;
}
```

### 3.2 服务端实现

#### 3.2.1 控制器
```go
package party

import (
    "context"
    "fmt"

    "github.com/pixb/DnfGameServer/dnf-go-server/gen/dnf/v1"
    "github.com/pixb/DnfGameServer/dnf-go-server/store"
)

// PartyController 组队控制器
type PartyController struct {
    store *store.Store
}

// NewPartyController 创建组队控制器实例
func NewPartyController(store *store.Store) *PartyController {
    return &PartyController{store: store}
}

// SearchPartyList 处理搜索队伍列表请求
func (c *PartyController) SearchPartyList(ctx context.Context, req *v1.SearchPartyListRequest) (*v1.SearchPartyListResponse, error) {
    // 搜索可加入的队伍
    // 返回队伍列表
    return &v1.SearchPartyListResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// RecommendGroup 处理推荐队伍请求
func (c *PartyController) RecommendGroup(ctx context.Context, req *v1.RecommendGroupRequest) (*v1.RecommendGroupResponse, error) {
    // 推荐队伍
    // 返回推荐队伍信息
    return &v1.RecommendGroupResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// ControlGroup 处理控制队伍请求
func (c *PartyController) ControlGroup(ctx context.Context, req *v1.ControlGroupRequest) (*v1.ControlGroupResponse, error) {
    // 控制队伍
    // 队长操作
    return &v1.ControlGroupResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// StartMultiPlay 处理开始多人游戏请求
func (c *PartyController) StartMultiPlay(ctx context.Context, req *v1.StartMultiPlayRequest) (*v1.StartMultiPlayResponse, error) {
    // 开始多人游戏
    // 初始化副本地图
    // 分配玩家 ID
    // 返回匹配信息
    return &v1.StartMultiPlayResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// MultiPlaySyncDungeon 处理多人游戏同步副本请求
func (c *PartyController) MultiPlaySyncDungeon(ctx context.Context, req *v1.MultiPlaySyncDungeonRequest) (*v1.MultiPlaySyncDungeonResponse, error) {
    // 同步多人副本状态
    // 返回同步信息
    return &v1.MultiPlaySyncDungeonResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// MultiPlayDungeonEnterComplete 处理多人游戏副本进入完成请求
func (c *PartyController) MultiPlayDungeonEnterComplete(ctx context.Context, req *v1.MultiPlayDungeonEnterCompleteRequest) (*v1.MultiPlayDungeonEnterCompleteResponse, error) {
    // 多人副本进入完成
    // 返回完成状态
    return &v1.MultiPlayDungeonEnterCompleteResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// PartyLoadingStatus 处理队伍加载状态请求
func (c *PartyController) PartyLoadingStatus(ctx context.Context, req *v1.PartyLoadingStatusRequest) (*v1.PartyLoadingStatusResponse, error) {
    // 获取队伍加载状态
    // 返回加载进度
    return &v1.PartyLoadingStatusResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// HalfOpenPartyAccept 处理半公开队伍接受请求
func (c *PartyController) HalfOpenPartyAccept(ctx context.Context, req *v1.HalfOpenPartyAcceptRequest) (*v1.HalfOpenPartyAcceptResponse, error) {
    // 接受半公开队伍邀请
    // 返回队伍信息
    return &v1.HalfOpenPartyAcceptResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// HalfOpenPartyRefuse 处理半公开队伍拒绝请求
func (c *PartyController) HalfOpenPartyRefuse(ctx context.Context, req *v1.HalfOpenPartyRefuseRequest) (*v1.HalfOpenPartyRefuseResponse, error) {
    // 拒绝半公开队伍邀请
    return &v1.HalfOpenPartyRefuseResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// ControlGroupCustom 处理控制队伍自定义请求
func (c *PartyController) ControlGroupCustom(ctx context.Context, req *v1.ControlGroupCustomRequest) (*v1.ControlGroupCustomResponse, error) {
    // 控制队伍自定义数据
    // 广播给队伍成员
    return &v1.ControlGroupCustomResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// ControlGroupQueryArea 处理控制队伍查询区域请求
func (c *PartyController) ControlGroupQueryArea(ctx context.Context, req *v1.ControlGroupQueryAreaRequest) (*v1.ControlGroupQueryAreaResponse, error) {
    // 查询队伍区域
    // 返回区域信息
    return &v1.ControlGroupQueryAreaResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// HalfOpenPartyJoin 处理半公开队伍加入请求
func (c *PartyController) HalfOpenPartyJoin(ctx context.Context, req *v1.HalfOpenPartyJoinRequest) (*v1.HalfOpenPartyJoinResponse, error) {
    // 加入半公开队伍
    return &v1.HalfOpenPartyJoinResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// PartyDungeonCondition 处理多人游戏副本条件请求
func (c *PartyController) PartyDungeonCondition(ctx context.Context, req *v1.PartyDungeonConditionRequest) (*v1.PartyDungeonConditionResponse, error) {
    // 获取多人副本条件
    // 返回副本条件信息
    return &v1.PartyDungeonConditionResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// MultiPlayStartDungeon 处理多人游戏开始副本请求
func (c *PartyController) MultiPlayStartDungeon(ctx context.Context, req *v1.MultiPlayStartDungeonRequest) (*v1.MultiPlayStartDungeonResponse, error) {
    // 开始多人副本
    // 初始化副本数据
    return &v1.MultiPlayStartDungeonResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// ReadyToLockstep 处理准备锁定步骤请求
func (c *PartyController) ReadyToLockstep(ctx context.Context, req *v1.ReadyToLockstepRequest) (*v1.ReadyToLockstepResponse, error) {
    // 准备锁定步骤
    // 返回锁定状态
    return &v1.ReadyToLockstepResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// RequestToReEnterAcceptDungeon 处理请求进入副本接受请求
func (c *PartyController) RequestToReEnterAcceptDungeon(ctx context.Context, req *v1.RequestToReEnterAcceptDungeonRequest) (*v1.RequestToReEnterAcceptDungeonResponse, error) {
    // 接受重新进入副本请求
    return &v1.RequestToReEnterAcceptDungeonResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// RequestToReEnterDungeon 处理请求进入副本请求
func (c *PartyController) RequestToReEnterDungeon(ctx context.Context, req *v1.RequestToReEnterDungeonRequest) (*v1.RequestToReEnterDungeonResponse, error) {
    // 请求重新进入副本
    return &v1.RequestToReEnterDungeonResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// SuggestMoveParty 处理建议移动队伍请求
func (c *PartyController) SuggestMoveParty(ctx context.Context, req *v1.SuggestMovePartyRequest) (*v1.SuggestMovePartyResponse, error) {
    // 建议队伍移动
    // 返回移动建议
    return &v1.SuggestMovePartyResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// TargetUserPartyInfo 处理目标用户队伍信息请求
func (c *PartyController) TargetUserPartyInfo(ctx context.Context, req *v1.TargetUserPartyInfoRequest) (*v1.TargetUserPartyInfoResponse, error) {
    // 获取目标用户队伍信息
    // 返回队伍详情
    return &v1.TargetUserPartyInfoResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// WaitingToUsersLoading 处理等待用户加载请求
func (c *PartyController) WaitingToUsersLoading(ctx context.Context, req *v1.WaitingToUsersLoadingRequest) (*v1.WaitingToUsersLoadingResponse, error) {
    // 等待用户加载
    // 返回加载状态
    return &v1.WaitingToUsersLoadingResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// VoteKickOutUser 处理投票踢出用户请求
func (c *PartyController) VoteKickOutUser(ctx context.Context, req *v1.VoteKickOutUserRequest) (*v1.VoteKickOutUserResponse, error) {
    // 投票踢出队伍成员
    // 返回投票结果
    return &v1.VoteKickOutUserResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// ConnectBattleServer 处理连接战斗服务器请求
func (c *PartyController) ConnectBattleServer(ctx context.Context, req *v1.ConnectBattleServerRequest) (*v1.ConnectBattleServerResponse, error) {
    // 连接战斗服务器
    // 返回连接信息
    return &v1.ConnectBattleServerResponse{
        Error:   0,
        Message: "OK",
    }, nil
}

// CheckProhibitedWord 处理检查禁用词请求
func (c *PartyController) CheckProhibitedWord(ctx context.Context, req *v1.CheckProhibitedWordRequest) (*v1.CheckProhibitedWordResponse, error) {
    // 检查禁用词
    // 返回检查结果
    return &v1.CheckProhibitedWordResponse{
        Error:   0,
        Message: "OK",
    }, nil
}
```

#### 3.2.2 路由注册
```go
package api

import (
    "github.com/labstack/echo/v4"
    "github.com/pixb/DnfGameServer/dnf-go-server/gen/dnf/v1"
    "github.com/pixb/DnfGameServer/dnf-go-server/server/party"
    "google.golang.org/grpc"
)

// APIV1Service API v1 服务
type APIV1Service struct {
    partyController *party.PartyController
}

// NewAPIV1Service 创建 API v1 服务实例
func NewAPIV1Service(partyController *party.PartyController) *APIV1Service {
    return &APIV1Service{partyController: partyController}
}

// RegisterRoutes 注册路由
func (s *APIV1Service) RegisterRoutes(e *echo.Echo) {
    // 组队相关路由
    e.POST("/api/v1/party/search", s.SearchPartyList)
    e.POST("/api/v1/party/recommend", s.RecommendGroup)
    e.POST("/api/v1/party/control", s.ControlGroup)
    e.POST("/api/v1/party/start-multi-play", s.StartMultiPlay)
    e.POST("/api/v1/party/sync-dungeon", s.MultiPlaySyncDungeon)
    e.POST("/api/v1/party/enter-complete", s.MultiPlayDungeonEnterComplete)
    e.POST("/api/v1/party/loading-status", s.PartyLoadingStatus)
    e.POST("/api/v1/party/half-open/accept", s.HalfOpenPartyAccept)
    e.POST("/api/v1/party/half-open/refuse", s.HalfOpenPartyRefuse)
    e.POST("/api/v1/party/custom", s.ControlGroupCustom)
    e.POST("/api/v1/party/query-area", s.ControlGroupQueryArea)
    e.POST("/api/v1/party/half-open/join", s.HalfOpenPartyJoin)
    e.POST("/api/v1/party/dungeon-condition", s.PartyDungeonCondition)
    e.POST("/api/v1/party/start-dungeon", s.MultiPlayStartDungeon)
    e.POST("/api/v1/party/ready-lockstep", s.ReadyToLockstep)
    e.POST("/api/v1/party/re-enter/accept", s.RequestToReEnterAcceptDungeon)
    e.POST("/api/v1/party/re-enter/request", s.RequestToReEnterDungeon)
    e.POST("/api/v1/party/suggest-move", s.SuggestMoveParty)
    e.POST("/api/v1/party/target-info", s.TargetUserPartyInfo)
    e.POST("/api/v1/party/waiting-loading", s.WaitingToUsersLoading)
    e.POST("/api/v1/party/vote-kick", s.VoteKickOutUser)
    e.POST("/api/v1/party/connect-battle", s.ConnectBattleServer)
    e.POST("/api/v1/party/check-prohibited", s.CheckProhibitedWord)
}

// RegisterGRPCServices 注册 gRPC 服务
func (s *APIV1Service) RegisterGRPCServices(server *grpc.Server) {
    v1.RegisterPartyServiceServer(server, s)
}

// 实现 gRPC 服务接口
func (s *APIV1Service) SearchPartyList(ctx context.Context, req *v1.SearchPartyListRequest) (*v1.SearchPartyListResponse, error) {
    return s.partyController.SearchPartyList(ctx, req)
}

func (s *APIV1Service) RecommendGroup(ctx context.Context, req *v1.RecommendGroupRequest) (*v1.RecommendGroupResponse, error) {
    return s.partyController.RecommendGroup(ctx, req)
}

func (s *APIV1Service) ControlGroup(ctx context.Context, req *v1.ControlGroupRequest) (*v1.ControlGroupResponse, error) {
    return s.partyController.ControlGroup(ctx, req)
}

func (s *APIV1Service) StartMultiPlay(ctx context.Context, req *v1.StartMultiPlayRequest) (*v1.StartMultiPlayResponse, error) {
    return s.partyController.StartMultiPlay(ctx, req)
}

func (s *APIV1Service) MultiPlaySyncDungeon(ctx context.Context, req *v1.MultiPlaySyncDungeonRequest) (*v1.MultiPlaySyncDungeonResponse, error) {
    return s.partyController.MultiPlaySyncDungeon(ctx, req)
}

func (s *APIV1Service) MultiPlayDungeonEnterComplete(ctx context.Context, req *v1.MultiPlayDungeonEnterCompleteRequest) (*v1.MultiPlayDungeonEnterCompleteResponse, error) {
    return s.partyController.MultiPlayDungeonEnterComplete(ctx, req)
}

func (s *APIV1Service) PartyLoadingStatus(ctx context.Context, req *v1.PartyLoadingStatusRequest) (*v1.PartyLoadingStatusResponse, error) {
    return s.partyController.PartyLoadingStatus(ctx, req)
}

func (s *APIV1Service) HalfOpenPartyAccept(ctx context.Context, req *v1.HalfOpenPartyAcceptRequest) (*v1.HalfOpenPartyAcceptResponse, error) {
    return s.partyController.HalfOpenPartyAccept(ctx, req)
}

func (s *APIV1Service) HalfOpenPartyRefuse(ctx context.Context, req *v1.HalfOpenPartyRefuseRequest) (*v1.HalfOpenPartyRefuseResponse, error) {
    return s.partyController.HalfOpenPartyRefuse(ctx, req)
}

func (s *APIV1Service) ControlGroupCustom(ctx context.Context, req *v1.ControlGroupCustomRequest) (*v1.ControlGroupCustomResponse, error) {
    return s.partyController.ControlGroupCustom(ctx, req)
}

func (s *APIV1Service) ControlGroupQueryArea(ctx context.Context, req *v1.ControlGroupQueryAreaRequest) (*v1.ControlGroupQueryAreaResponse, error) {
    return s.partyController.ControlGroupQueryArea(ctx, req)
}

func (s *APIV1Service) HalfOpenPartyJoin(ctx context.Context, req *v1.HalfOpenPartyJoinRequest) (*v1.HalfOpenPartyJoinResponse, error) {
    return s.partyController.HalfOpenPartyJoin(ctx, req)
}

func (s *APIV1Service) PartyDungeonCondition(ctx context.Context, req *v1.PartyDungeonConditionRequest) (*v1.PartyDungeonConditionResponse, error) {
    return s.partyController.PartyDungeonCondition(ctx, req)
}

func (s *APIV1Service) MultiPlayStartDungeon(ctx context.Context, req *v1.MultiPlayStartDungeonRequest) (*v1.MultiPlayStartDungeonResponse, error) {
    return s.partyController.MultiPlayStartDungeon(ctx, req)
}

func (s *APIV1Service) ReadyToLockstep(ctx context.Context, req *v1.ReadyToLockstepRequest) (*v1.ReadyToLockstepResponse, error) {
    return s.partyController.ReadyToLockstep(ctx, req)
}

func (s *APIV1Service) RequestToReEnterAcceptDungeon(ctx context.Context, req *v1.RequestToReEnterAcceptDungeonRequest) (*v1.RequestToReEnterAcceptDungeonResponse, error) {
    return s.partyController.RequestToReEnterAcceptDungeon(ctx, req)
}

func (s *APIV1Service) RequestToReEnterDungeon(ctx context.Context, req *v1.RequestToReEnterDungeonRequest) (*v1.RequestToReEnterDungeonResponse, error) {
    return s.partyController.RequestToReEnterDungeon(ctx, req)
}

func (s *APIV1Service) SuggestMoveParty(ctx context.Context, req *v1.SuggestMovePartyRequest) (*v1.SuggestMovePartyResponse, error) {
    return s.partyController.SuggestMoveParty(ctx, req)
}

func (s *APIV1Service) TargetUserPartyInfo(ctx context.Context, req *v1.TargetUserPartyInfoRequest) (*v1.TargetUserPartyInfoResponse, error) {
    return s.partyController.TargetUserPartyInfo(ctx, req)
}

func (s *APIV1Service) WaitingToUsersLoading(ctx context.Context, req *v1.WaitingToUsersLoadingRequest) (*v1.WaitingToUsersLoadingResponse, error) {
    return s.partyController.WaitingToUsersLoading(ctx, req)
}

func (s *APIV1Service) VoteKickOutUser(ctx context.Context, req *v1.VoteKickOutUserRequest) (*v1.VoteKickOutUserResponse, error) {
    return s.partyController.VoteKickOutUser(ctx, req)
}

func (s *APIV1Service) ConnectBattleServer(ctx context.Context, req *v1.ConnectBattleServerRequest) (*v1.ConnectBattleServerResponse, error) {
    return s.partyController.ConnectBattleServer(ctx, req)
}

func (s *APIV1Service) CheckProhibitedWord(ctx context.Context, req *v1.CheckProhibitedWordRequest) (*v1.CheckProhibitedWordResponse, error) {
    return s.partyController.CheckProhibitedWord(ctx, req)
}
```

## 4. API 文档

### 4.1 HTTP API

#### 4.1.1 搜索队伍列表
- **URL**: `/api/v1/party/search`
- **方法**: POST
- **请求参数**:
  | 参数名 | 类型 | 必需 | 描述 |
  |--------|------|------|------|
  | dungeonindex | uint32 | 是 | 副本索引 |
  | minlevel | uint32 | 是 | 最低等级 |
  | maxlevel | uint32 | 是 | 最高等级 |
- **响应格式**:
  ```json
  {
    "parties": [
      {
        "partyguid": 1,
        "leaderguid": 1,
        "name": "测试队伍",
        "maxmembers": 4,
        "members": [
          {
            "charguid": 1,
            "name": "测试角色",
            "job": 1,
            "level": 1,
            "ready": true
          }
        ],
        "dungeonindex": 1,
        "roomid": 1
      }
    ],
    "error": 0,
    "message": "OK"
  }
  ```

#### 4.1.2 推荐队伍
- **URL**: `/api/v1/party/recommend`
- **方法**: POST
- **请求参数**:
  | 参数名 | 类型 | 必需 | 描述 |
  |--------|------|------|------|
  | dungeonindex | uint32 | 是 | 副本索引 |
- **响应格式**:
  ```json
  {
    "parties": [
      {
        "partyguid": 1,
        "leaderguid": 1,
        "name": "测试队伍",
        "maxmembers": 4,
        "members": [
          {
            "charguid": 1,
            "name": "测试角色",
            "job": 1,
            "level": 1,
            "ready": true
          }
        ],
        "dungeonindex": 1,
        "roomid": 1
      }
    ],
    "error": 0,
    "message": "OK"
  }
  ```

#### 4.1.3 开始多人游戏
- **URL**: `/api/v1/party/start-multi-play`
- **方法**: POST
- **请求参数**:
  | 参数名 | 类型 | 必需 | 描述 |
  |--------|------|------|------|
  | input | uint32 | 是 | 输入类型 |
  | type | uint32 | 是 | 游戏类型 |
  | index | uint32 | 是 | 副本索引 |
  | partyguid | uint64 | 是 | 队伍 GUID |
- **响应格式**:
  ```json
  {
    "matchingguid": 1,
    "dungeonguid": 1,
    "battleworld": 1,
    "bchannel": 1,
    "bip": "127.0.0.1",
    "bport": 8080,
    "matchtype": 1,
    "world": 1,
    "channel": 1,
    "users": [1],
    "detail": [
      {
        "charguid": 1,
        "job": 1,
        "growtype": 1,
        "secondgrowtype": 1,
        "level": 1,
        "name": "测试角色",
        "teamtype": 1,
        "world": 1
      }
    ],
    "error": 0,
    "message": "OK"
  }
  ```

### 4.2 gRPC API

#### 4.2.1 SearchPartyList
- **服务**: PartyService
- **方法**: SearchPartyList
- **请求消息**:
  ```protobuf
  SearchPartyListRequest {
    dungeonindex: 1
    minlevel: 1
    maxlevel: 100
  }
  ```
- **响应消息**:
  ```protobuf
  SearchPartyListResponse {
    parties: [{
      partyguid: 1
      leaderguid: 1
      name: "测试队伍"
      maxmembers: 4
      members: [{
        charguid: 1
        name: "测试角色"
        job: 1
        level: 1
        ready: true
      }]
      dungeonindex: 1
      roomid: 1
    }]
    error: 0
    message: "OK"
  }
  ```

#### 4.2.2 StartMultiPlay
- **服务**: PartyService
- **方法**: StartMultiPlay
- **请求消息**:
  ```protobuf
  StartMultiPlayRequest {
    input: 1
    type: 1
    index: 1
    partyguid: 1
  }
  ```
- **响应消息**:
  ```protobuf
  StartMultiPlayResponse {
    matchingguid: 1
    dungeonguid: 1
    battleworld: 1
    bchannel: 1
    bip: "127.0.0.1"
    bport: 8080
    matchtype: 1
    world: 1
    channel: 1
    users: [1]
    detail: [{
      charguid: 1
      job: 1
      growtype: 1
      secondgrowtype: 1
      level: 1
      name: "测试角色"
      teamtype: 1
      world: 1
    }]
    error: 0
    message: "OK"
  }
  ```

## 5. 数据库设计文档

### 5.1 表结构

#### 5.1.1 parties 表
| 字段名 | 数据类型 | 约束 | 描述 |
|--------|----------|------|------|
| partyguid | BIGINT | PRIMARY KEY | 队伍 GUID |
| leaderguid | BIGINT | NOT NULL | 队长 GUID |
| name | VARCHAR(50) | NOT NULL | 队伍名称 |
| maxmembers | INT | NOT NULL | 最大成员数 |
| dungeonindex | INT | NOT NULL | 副本索引 |
| roomid | INT | NOT NULL | 房间 ID |
| created_at | TIMESTAMP | NOT NULL | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL | 更新时间 |

#### 5.1.2 party_members 表
| 字段名 | 数据类型 | 约束 | 描述 |
|--------|----------|------|------|
| id | BIGINT | PRIMARY KEY | 成员 ID |
| partyguid | BIGINT | NOT NULL | 队伍 GUID |
| charguid | BIGINT | NOT NULL | 角色 GUID |
| job | INT | NOT NULL | 职业 |
| level | INT | NOT NULL | 等级 |
| growtype | INT | NOT NULL | 成长类型 |
| secondgrowtype | INT | NOT NULL | 二次成长类型 |
| teamtype | INT | NOT NULL | 队伍类型 |
| playerid | INT | NOT NULL | 玩家 ID |
| objectgroupid | BIGINT | NOT NULL | 对象组 ID |
| ready | BOOLEAN | NOT NULL | 是否就绪 |
| waiting | BOOLEAN | NOT NULL | 是否等待 |
| created_at | TIMESTAMP | NOT NULL | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL | 更新时间 |

#### 5.1.3 party_invitations 表
| 字段名 | 数据类型 | 约束 | 描述 |
|--------|----------|------|------|
| id | BIGINT | PRIMARY KEY | 邀请 ID |
| partyguid | BIGINT | NOT NULL | 队伍 GUID |
| charguid | BIGINT | NOT NULL | 角色 GUID |
| type | INT | NOT NULL | 邀请类型 |
| status | INT | NOT NULL | 邀请状态 |
| created_at | TIMESTAMP | NOT NULL | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL | 更新时间 |

#### 5.1.4 multi_play_matches 表
| 字段名 | 数据类型 | 约束 | 描述 |
|--------|----------|------|------|
| matchingguid | BIGINT | PRIMARY KEY | 匹配 GUID |
| partyguid | BIGINT | NOT NULL | 队伍 GUID |
| dungeonguid | BIGINT | NOT NULL | 副本 GUID |
| battleworld | INT | NOT NULL | 战斗世界 |
| bchannel | INT | NOT NULL | 战斗频道 |
| bip | VARCHAR(50) | NOT NULL | 战斗服务器 IP |
| bport | INT | NOT NULL | 战斗服务器端口 |
| matchtype | INT | NOT NULL | 匹配类型 |
| world | INT | NOT NULL | 世界 |
| channel | INT | NOT NULL | 频道 |
| created_at | TIMESTAMP | NOT NULL | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL | 更新时间 |

### 5.2 索引设计

#### 5.2.1 parties 表索引
| 索引名 | 字段 | 类型 | 描述 |
|--------|------|------|------|
| idx_leaderguid | leaderguid | 普通索引 | 加速根据队长 GUID 查询队伍 |
| idx_dungeonindex | dungeonindex | 普通索引 | 加速根据副本索引查询队伍 |

#### 5.2.2 party_members 表索引
| 索引名 | 字段 | 类型 | 描述 |
|--------|------|------|------|
| idx_partyguid | partyguid | 普通索引 | 加速根据队伍 GUID 查询成员 |
| idx_charguid | charguid | 普通索引 | 加速根据角色 GUID 查询队伍 |

#### 5.2.3 party_invitations 表索引
| 索引名 | 字段 | 类型 | 描述 |
|--------|------|------|------|
| idx_partyguid | partyguid | 普通索引 | 加速根据队伍 GUID 查询邀请 |
| idx_charguid | charguid | 普通索引 | 加速根据角色 GUID 查询邀请 |
| idx_status | status | 普通索引 | 加速根据状态查询邀请 |

#### 5.2.4 multi_play_matches 表索引
| 索引名 | 字段 | 类型 | 描述 |
|--------|------|------|------|
| idx_partyguid | partyguid | 普通索引 | 加速根据队伍 GUID 查询匹配 |
| idx_dungeonguid | dungeonguid | 普通索引 | 加速根据副本 GUID 查询匹配 |

### 5.3 关系图
- **parties** 表与 **party_members** 表是一对多关系，一个队伍可以有多个成员
- **parties** 表与 **party_invitations** 表是一对多关系，一个队伍可以发送多个邀请
- **parties** 表与 **multi_play_matches** 表是一对多关系，一个队伍可以有多个匹配

## 6. 业务流程文档

### 6.1 流程描述
1. **创建队伍流程**:
   - 玩家发送创建队伍请求
   - 服务端验证玩家状态
   - 服务端创建队伍记录
   - 服务端将玩家设置为队长
   - 服务端返回队伍信息

2. **加入队伍流程**:
   - 玩家搜索可加入的队伍
   - 服务端返回队伍列表
   - 玩家选择队伍并发送加入请求
   - 服务端验证队伍状态和玩家状态
   - 服务端将玩家添加到队伍
   - 服务端广播队伍成员变更
   - 服务端返回加入结果

3. **开始多人游戏流程**:
   - 队长发送开始多人游戏请求
   - 服务端验证队伍状态
   - 服务端匹配战斗服务器
   - 服务端初始化副本地图
   - 服务端分配玩家 ID
   - 服务端返回匹配信息
   - 客户端连接战斗服务器
   - 客户端进入副本地图

4. **队伍管理流程**:
   - 队长发送队伍管理请求（如踢出成员、转让队长等）
   - 服务端验证队长权限
   - 服务端执行管理操作
   - 服务端广播队伍变更
   - 服务端返回管理结果

### 6.2 流程图

#### 6.2.1 开始多人游戏流程
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│ 客户端      │     │ 服务端      │     │ 战斗服务    │     │ 客户端      │
├─────────────┤     ├─────────────┤     ├─────────────┤     ├─────────────┤
│ 1. 发送开始 │────>│ 2. 验证队伍 │────>│ 3. 匹配战   │────>│ 6. 连接战   │
│ 多人游戏请求 │     │ 状态        │     │ 斗服务器    │     │ 斗服务器    │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
         ^                  │                  │                  │
         │                  │                  │                  │
         │                  │ 4. 初始化副本   │                  │
         │                  │ 地图           │                  │
         │                  │                  │                  │
         │                  └──────────────────┘                  │
         │                  │                                    │
         │                  ▼                                    │
         │         ┌─────────────┐                               │
         │         │ 服务端      │                               │
         │         ├─────────────┤                               │
         └─────────│ 5. 返回匹配 │<───────────────────────────────┘
                  │ 信息        │
                  └─────────────┘
```

### 6.3 状态转换

#### 6.3.1 队伍成员状态转换
| 状态 | 事件 | 下一状态 | 动作 |
|------|------|----------|------|
| 离线 | 加入队伍 | 在线 | 添加到队伍成员列表 |
| 在线 | 离开队伍 | 离线 | 从队伍成员列表移除 |
| 未就绪 | 准备就绪 | 就绪 | 更新成员状态，广播队伍变更 |
| 就绪 | 取消准备 | 未就绪 | 更新成员状态，广播队伍变更 |
| 等待 | 加载完成 | 就绪 | 更新成员状态，广播队伍变更 |

#### 6.3.2 队伍状态转换
| 状态 | 事件 | 下一状态 | 动作 |
|------|------|----------|------|
| 空闲 | 开始匹配 | 匹配中 | 创建匹配记录，等待战斗服务器 |
| 匹配中 | 匹配成功 | 战斗中 | 更新队伍状态，进入副本地图 |
| 战斗中 | 战斗结束 | 空闲 | 清理匹配记录，返回城镇 |
| 空闲 | 解散队伍 | 解散 | 删除队伍记录，清理成员关系 |

## 7. 测试用例文档

### 7.1 测试目标
- 验证组队系统的核心功能是否正常工作
- 验证队伍创建、加入、管理等操作是否正确
- 验证多人游戏匹配、副本进入等流程是否顺畅
- 验证系统对各种异常情况的处理能力
- 验证系统在高并发场景下的性能和稳定性

### 7.2 测试场景

#### 7.2.1 场景 1: 创建队伍
- **测试步骤**:
  1. 客户端发送创建队伍请求
  2. 服务端验证玩家状态
  3. 服务端创建队伍记录
  4. 服务端将玩家设置为队长
  5. 服务端返回队伍信息
- **预期结果**:
  - 服务端返回队伍创建成功
  - 队伍信息正确，玩家为队长
  - 数据库中存在队伍记录

#### 7.2.2 场景 2: 加入队伍
- **测试步骤**:
  1. 客户端发送搜索队伍列表请求
  2. 服务端返回队伍列表
  3. 客户端选择队伍并发送加入请求
  4. 服务端验证队伍状态和玩家状态
  5. 服务端将玩家添加到队伍
  6. 服务端广播队伍成员变更
  7. 服务端返回加入结果
- **预期结果**:
  - 服务端返回加入成功
  - 队伍成员列表包含新玩家
  - 其他队伍成员收到广播

#### 7.2.3 场景 3: 开始多人游戏
- **测试步骤**:
  1. 队长发送开始多人游戏请求
  2. 服务端验证队伍状态
  3. 服务端匹配战斗服务器
  4. 服务端初始化副本地图
  5. 服务端分配玩家 ID
  6. 服务端返回匹配信息
  7. 客户端连接战斗服务器
  8. 客户端进入副本地图
- **预期结果**:
  - 服务端返回匹配成功
  - 匹配信息正确，包含战斗服务器地址和端口
  - 客户端成功连接战斗服务器
  - 客户端成功进入副本地图

#### 7.2.4 场景 4: 队伍管理
- **测试步骤**:
  1. 队长发送踢出成员请求
  2. 服务端验证队长权限
  3. 服务端执行踢出操作
  4. 服务端广播队伍变更
  5. 服务端返回踢出结果
- **预期结果**:
  - 服务端返回踢出成功
  - 队伍成员列表移除被踢出的玩家
  - 其他队伍成员收到广播

#### 7.2.5 场景 5: 异常情况处理
- **测试步骤**:
  1. 非队长发送队伍管理请求
  2. 服务端验证权限
  3. 服务端返回权限错误
- **预期结果**:
  - 服务端返回权限错误
  - 队伍状态不变

### 7.3 测试数据
- **队伍数据**:
  - partyguid: 1
  - leaderguid: 1
  - name: "测试队伍"
  - maxmembers: 4
  - dungeonindex: 1
  - roomid: 1

- **队伍成员数据**:
  - id: 1
  - partyguid: 1
  - charguid: 1
  - job: 1
  - level: 1
  - growtype: 1
  - secondgrowtype: 1
  - teamtype: 1
  - playerid: 1
  - objectgroupid: 1
  - ready: true
  - waiting: false

- **匹配数据**:
  - matchingguid: 1
  - partyguid: 1
  - dungeonguid: 1
  - battleworld: 1
  - bchannel: 1
  - bip: "127.0.0.1"
  - bport: 8080
  - matchtype: 1
  - world: 1
  - channel: 1

## 8. 部署文档

### 8.1 环境要求
- **操作系统**: Linux (Ubuntu 18.04+)
- **Go 版本**: 1.16+
- **数据库**: SQLite 3+ 或 MySQL 5.7+
- **依赖服务**: 战斗服务器

### 8.2 安装步骤
1. **克隆代码库**:
   ```bash
   git clone https://github.com/pixb/DnfGameServer.git
   cd DnfGameServer/dnf-go-server
   ```

2. **安装依赖**:
   ```bash
   go mod download
   ```

3. **编译项目**:
   ```bash
   go build -o dnf-go-server ./cmd/server/main.go
   ```

4. **配置环境**:
   ```bash
   cp config.dev.yaml config.yaml
   # 编辑 config.yaml 文件，配置数据库连接等信息
   ```

5. **启动服务**:
   ```bash
   ./dnf-go-server serve --driver="sqlite" --dsn="./game.db" --mode="dev"
   ```

### 8.3 配置说明

#### 8.3.1 配置文件
```yaml
# config.yaml
server:
  port: 8081
  mode: dev

database:
  driver: sqlite
  dsn: ./game.db

logging:
  level: info
  format: json

party:
  max_members: 4
  max_parties: 1000
  invitation_expiry: 300
  matching_timeout: 60

battle_server:
  host: "127.0.0.1"
  port: 8080
  timeout: 30
```

#### 8.3.2 环境变量
| 变量名 | 类型 | 默认值 | 描述 |
|--------|------|--------|------|
| SERVER_PORT | int | 8081 | 服务器端口 |
| SERVER_MODE | string | dev | 服务器模式 (dev/prod) |
| DATABASE_DRIVER | string | sqlite | 数据库驱动 (sqlite/mysql/postgres) |
| DATABASE_DSN | string | ./game.db | 数据库连接字符串 |
| LOG_LEVEL | string | info | 日志级别 (debug/info/warn/error) |
| LOG_FORMAT | string | json | 日志格式 (json/text) |
| PARTY_MAX_MEMBERS | int | 4 | 队伍最大成员数 |
| PARTY_MAX_PARTIES | int | 1000 | 最大队伍数 |
| PARTY_INVITATION_EXPIRY | int | 300 | 邀请过期时间 (秒) |
| PARTY_MATCHING_TIMEOUT | int | 60 | 匹配超时时间 (秒) |
| BATTLE_SERVER_HOST | string | 127.0.0.1 | 战斗服务器主机 |
| BATTLE_SERVER_PORT | int | 8080 | 战斗服务器端口 |
| BATTLE_SERVER_TIMEOUT | int | 30 | 战斗服务器连接超时 (秒) |

## 9. 监控与维护

### 9.1 监控指标
- **队伍数量**: 监控当前活跃的队伍数量
- **匹配成功率**: 监控多人游戏匹配的成功率
- **匹配时间**: 监控多人游戏匹配的平均时间
- **战斗服务器连接率**: 监控客户端与战斗服务器的连接率
- **队伍操作错误率**: 监控队伍操作的错误率

### 9.2 日志管理
- **日志级别**: 默认使用 info 级别，生产环境可调整为 warn 级别
- **日志格式**: 默认使用 json 格式，便于日志收集和分析
- **日志存储**: 日志默认输出到标准输出，可通过配置重定向到文件
- **日志轮转**: 建议使用外部日志轮转工具，如 logrotate，定期轮转日志文件

### 9.3 常见问题

#### 9.3.1 问题 1: 队伍创建失败
- **原因**: 可能是玩家已经在队伍中、队伍名称包含禁用词、服务器负载过高等
- **解决方案**: 检查玩家状态、队伍名称、服务器负载，确保满足创建队伍的条件

#### 9.3.2 问题 2: 匹配战斗服务器失败
- **原因**: 可能是战斗服务器未启动、战斗服务器负载过高、网络连接问题等
- **解决方案**: 检查战斗服务器状态、负载、网络连接，确保战斗服务器正常运行

#### 9.3.3 问题 3: 客户端连接战斗服务器失败
- **原因**: 可能是战斗服务器地址错误、战斗服务器未启动、网络连接问题等
- **解决方案**: 检查战斗服务器地址、状态、网络连接，确保客户端能够正常连接

## 10. 变更记录

| 版本 | 日期 | 作者 | 变更内容 |
|------|------|------|----------|
| 1.0 | 2026-02-17 | 系统自动生成 | 初始版本 |
| 1.1 | 2026-02-24 | 人工编辑 | 按照新模板完善文档，添加 API 文档、数据库设计文档、业务流程文档等内容 |