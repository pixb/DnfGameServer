# 组队系统设计文档

## 概述

组队系统是多人协作游戏的核心功能，支持玩家创建队伍、加入队伍、邀请玩家、队伍管理等操作。

## Java 代码分析

### 核心控制器
- **文件位置**: `src/main/java/com/dnfm/game/party/PartyController.java`
- **处理器数量**: 23 个 @RequestMapping 方法

### 核心功能

#### 1. 半公开队伍接受 (REQ_HALF_OPEN_PARTY_ACCEPT)
- **方法**: `REQ_HALF_OPEN_PARTY_ACCEPT(IoSession session, REQ_HALF_OPEN_PARTY_ACCEPT req_half_open_party_accept)`
- **功能**:
  - 接受半公开队伍邀请
  - 返回队伍信息

#### 2. 半公开队伍拒绝 (REQ_HALF_OPEN_PARTY_REFUSE)
- **方法**: `REQ_HALF_OPEN_PARTY_REFUSE(IoSession session, REQ_HALF_OPEN_PARTY_REFUSE req_half_open_party_refuse)`
- **功能**:
  - 拒绝半公开队伍邀请

#### 3. 控制队伍自定义 (REQ_CONTROL_GROUP_CUSTOM)
- **方法**: `REQ_CONTROL_GROUP_CUSTOM(IoSession session, REQ_CONTROL_GROUP_CUSTOM req_control_group_custom)`
- **功能**:
  - 控制队伍自定义数据
  - 广播给队伍成员

#### 4. 开始多人游戏 (REQ_START_MULTI_PLAY)
- **方法**: `REQ_START_MULTI_PLAY(IoSession session, REQ_START_MULTI_PLAY req_start_multi_play)`
- **功能**:
  - 开始多人游戏
  - 初始化副本地图
  - 分配玩家 ID
  - 返回匹配信息

#### 5. 搜索队伍列表 (REQ_SEARCH_PARTY_LIST)
- **方法**: `REQ_SEARCH_PARTY_LIST(IoSession session, REQ_SEARCH_PARTY_LIST req_search_party_list)`
- **功能**:
  - 搜索可加入的队伍
  - 返回队伍列表

#### 6. 推荐队伍 (REQ_RECOMMAND_GROUP)
- **方法**: `REQ_RECOMMAND_GROUP(IoSession session, REQ_RECOMMAND_GROUP req_recommand_group)`
- **功能**:
  - 推荐队伍
  - 返回推荐队伍信息

#### 7. 控制队伍 (REQ_CONTROL_GROUP)
- **方法**: `REQ_CONTROL_GROUP(IoSession session, REQ_CONTROL_GROUP req_control_group)`
- **功能**:
  - 控制队伍
  - 队长操作

#### 8. 控制队伍查询区域 (REQ_CONTROL_GROUP_QUERYAREA)
- **方法**: `REQ_CONTROL_GROUP_QUERYAREA(IoSession session, REQ_CONTROL_GROUP_QUERYAREA req_control_group_queryarea)`
- **功能**:
  - 查询队伍区域
  - 返回区域信息

#### 9. 半公开队伍加入 (REQ_HALF_OPEN_PARTY_JOIN)
- **方法**: `REQ_HALF_OPEN_PARTY_JOIN(IoSession session, REQ_HALF_OPEN_PARTY_JOIN req_half_open_party_join)`
- **功能**:
  - 加入半公开队伍

#### 10. 多人游戏副本条件 (REQ_PARTY_DUNGEON_CONDITION)
- **方法**: `REQ_PARTY_DUNGEON_CONDITION(IoSession session, REQ_PARTY_DUNGEON_CONDITION req_party_dungeon_condition)`
- **功能**:
  - 获取多人副本条件
  - 返回副本条件信息

#### 11. 多人游戏同步副本 (REQ_MULTI_PLAY_SYNC_DUNGEON)
- **方法**: `REQ_MULTI_PLAY_SYNC_DUNGEON(IoSession session, REQ_MULTI_PLAY_SYNC_DUNGEON req_multi_play_sync_dungeon)`
- **功能**:
  - 同步多人副本状态
  - 返回同步信息

#### 12. 多人游戏副本进入完成 (REQ_MULTI_PLAY_DUNGEON_ENTER_COMPLETE)
- **方法**: `REQ_MULTI_PLAY_DUNGEON_ENTER_COMPLETE(IoSession session, REQ_MULTI_PLAY_DUNGEON_ENTER_COMPLETE req_multi_play_dungeon_enter_complete)`
- **功能**:
  - 多人副本进入完成
  - 返回完成状态

#### 13. 多人游戏开始副本 (REQ_MULTI_PLAY_START_DUNGEON)
- **方法**: `REQ_MULTI_PLAY_START_DUNGEON(IoSession session, REQ_MULTI_PLAY_START_DUNGEON req_multi_play_start_dungeon)`
- **功能**:
  - 开始多人副本
  - 初始化副本数据

#### 14. 队伍加载状态 (REQ_PARTY_LOADING_STATUS)
- **方法**: `REQ_PARTY_LOADING_STATUS(IoSession session, REQ_PARTY_LOADING_STATUS req_party_loading_status)`
- **功能**:
  - 获取队伍加载状态
  - 返回加载进度

#### 15. 准备锁定步骤 (REQ_READY_TO_LOCKSTEP)
- **方法**: `REQ_READY_TO_LOCKSTEP(IoSession session, REQ_READY_TO_LOCKSTEP req_ready_to_lockstep)`
- **功能**:
  - 准备锁定步骤
  - 返回锁定状态

#### 16. 请求进入副本接受 (REQ_REQUEST_TO_RE_ENTER_ACCEPT_DUNGEON)
- **方法**: `REQ_REQUEST_TO_RE_ENTER_ACCEPT_DUNGEON(IoSession session, REQ_REQUEST_TO_RE_ENTER_ACCEPT_DUNGEON req_request_to_re_enter_accept_dungeon)`
- **功能**:
  - 接受重新进入副本请求

#### 17. 请求进入副本 (REQ_REQUEST_TO_RE_ENTER_DUNGEON)
- **方法**: `REQ_REQUEST_TO_RE_ENTER_DUNGEON(IoSession session, REQ_REQUEST_TO_RE_ENTER_DUNGEON req_request_to_re_enter_dungeon)`
- **功能**:
  - 请求重新进入副本

#### 18. 建议移动队伍 (REQ_SUGGEST_MOVE_PARTY)
- **方法**: `REQ_SUGGEST_MOVE_PARTY(IoSession session, REQ_SUGGEST_MOVE_PARTY req_suggest_move_party)`
- **功能**:
  - 建议队伍移动
  - 返回移动建议

#### 19. 目标用户队伍信息 (REQ_TARGET_USER_PARTY_INFO)
- **方法**: `REQ_TARGET_USER_PARTY_INFO(IoSession session, REQ_TARGET_USER_PARTY_INFO req_target_user_party_info)`
- **功能**:
  - 获取目标用户队伍信息
  - 返回队伍详情

#### 20. 等待用户加载 (REQ_WAITING_TO_USERS_LOADING)
- **方法**: `REQ_WAITING_TO_USERS_LOADING(IoSession session, REQ_WAITING_TO_USERS_LOADING req_waiting_to_users_loading)`
- **功能**:
  - 等待用户加载
  - 返回加载状态

#### 21. 投票踢出用户 (REQ_VOTE_KICK_OUT_USER)
- **方法**: `REQ_VOTE_KICK_OUT_USER(IoSession session, REQ_VOTE_KICK_OUT_USER req_vote_kick_out_user)`
- **功能**:
  - 投票踢出队伍成员
  - 返回投票结果

#### 22. 连接战斗服务器 (REQ_CONNECT_BATTLE_SERVER)
- **方法**: `REQ_CONNECT_BATTLE_SERVER(IoSession session, REQ_CONNECT_BATTLE_SERVER req_connect_battle_server)`
- **功能**:
  - 连接战斗服务器
  - 返回连接信息

#### 23. 检查禁用词 (REQ_CHECK_PROHIBITED_WORD)
- **方法**: `REQ_CHECK_PROHIBITED_WORD(IoSession session, REQ_CHECK_PROHIBITED_WORD req_check_prohibited_word)`
- **功能**:
  - 检查禁用词
  - 返回检查结果

## Go 实现方案

### 1. ProtoBuf 消息定义

#### party.proto
```protobuf
syntax = "proto3";

package dnf.v1;

option go_package = "gen/dnf/v1";

import "dnf/v1/common.proto";

// 队伍成员
message GroupMember {
    uint64 charguid = 1;
    string name = 2;
    uint32 job = 3;
    uint32 level = 4;
    uint32 growtype = 5;
    uint32 secondgrowtype = 6;
    uint32 teamtype = 7;
    uint32 playerid = 8;
    uint64 objectgroupid = 9;
    bool ready = 10;
    bool waiting = 11;
}

// 队伍信息
message PartyInfo {
    uint64 partyguid = 1;
    uint64 leaderguid = 2;
    string name = 3;
    uint32 maxmembers = 4;
    repeated GroupMember members = 5;
    uint32 dungeonindex = 6;
    uint32 roomid = 7;
}

// 搜索队伍请求
message SearchPartyListRequest {
    uint32 dungeonindex = 1;
    uint32 minlevel = 2;
    uint32 maxlevel = 3;
}

// 搜索队伍响应
message SearchPartyListResponse {
    repeated PartyInfo parties = 1;
    uint32 error = 2;
    string message = 3;
}

// 推荐队伍请求
message RecommendGroupRequest {
    uint32 dungeonindex = 1;
}

// 推荐队伍响应
message RecommendGroupResponse {
    repeated PartyInfo parties = 1;
    uint32 error = 2;
    string message = 3;
}

// 控制队伍请求
message ControlGroupRequest {
    uint32 action = 1;
    uint64 targetguid = 2;
}

// 控制队伍响应
message ControlGroupResponse {
    uint32 error = 2;
    string message = 3;
}

// 开始多人游戏请求
message StartMultiPlayRequest {
    uint32 input = 1;
    uint32 type = 2;
    uint32 index = 3;
    uint64 partyguid = 4;
}

// 开始多人游戏响应
message StartMultiPlayResponse {
    uint64 matchingguid = 1;
    uint64 dungeonguid = 2;
    uint32 battleworld = 3;
    uint32 bchannel = 4;
    string bip = 5;
    uint32 bport = 6;
    uint32 matchtype = 7;
    uint32 world = 8;
    uint32 channel = 9;
    repeated uint64 users = 10;
    repeated UserMinimumInfo detail = 11;
    uint32 error = 12;
    string message = 13;
}

// 用户最小信息
message UserMinimumInfo {
    uint64 charguid = 1;
    uint32 job = 2;
    uint32 growtype = 3;
    uint32 secondgrowtype = 4;
    uint32 level = 5;
    string name = 6;
    uint32 teamtype = 7;
    uint32 world = 8;
}

// 多人游戏同步副本请求
message MultiPlaySyncDungeonRequest {
    uint32 stageid = 1;
    uint32 progress = 2;
}

// 多人游戏同步副本响应
message MultiPlaySyncDungeonResponse {
    uint32 error = 2;
    string message = 3;
}

// 多人游戏副本进入完成请求
message MultiPlayDungeonEnterCompleteRequest {
    uint32 stageid = 1;
}

// 多人游戏副本进入完成响应
message MultiPlayDungeonEnterCompleteResponse {
    uint32 error = 2;
    string message = 3;
}

// 队伍加载状态请求
message PartyLoadingStatusRequest {
}

// 队伍加载状态响应
message PartyLoadingStatusResponse {
    repeated uint64 loadingusers = 1;
    repeated uint64 readyusers = 2;
    uint32 error = 3;
    string message = 4;
}

// 准备锁定步骤请求
message ReadyToLockstepRequest {
    bool ready = 1;
}

// 准备锁定步骤响应
message ReadyToLockstepResponse {
    uint32 error = 2;
    string message = 3;
}

// 投票踢出用户请求
message VoteKickOutUserRequest {
    uint64 targetguid = 1;
}

// 投票踢出用户响应
message VoteKickOutUserResponse {
    uint32 error = 2;
    string message = 3;
}

// 连接战斗服务器请求
message ConnectBattleServerRequest {
    uint64 matchingguid = 1;
}

// 连接战斗服务器响应
message ConnectBattleServerResponse {
    string ip = 1;
    uint32 port = 2;
    uint32 error = 3;
    string message = 4;
}

// 检查禁用词请求
message CheckProhibitedWordRequest {
    string word = 1;
}

// 检查禁用词响应
message CheckProhibitedWordResponse {
    bool prohibited = 1;
    uint32 error = 2;
    string message = 3;
}
```

### 2. 数据模型设计

#### models/party.go
```go
package models

import (
    "time"
    "gorm.io/gorm"
)

// Party 队伍
type Party struct {
    ID           uint64    `gorm:"primaryKey;column:partyId" json:"party_id"`
    LeaderID     uint64    `gorm:"column:leaderId" json:"leader_id"`
    Name         string    `gorm:"column:name;size:50" json:"name"`
    MaxMembers   uint32    `gorm:"column:maxMembers" json:"max_members"`
    DungeonIndex uint32    `gorm:"column:dungeonIndex" json:"dungeon_index"`
    RoomID       uint64    `gorm:"column:roomId" json:"room_id"`
    Status       uint32    `gorm:"column:status" json:"status"`
    CreateTime   time.Time `gorm:"column:createTime" json:"create_time"`
    UpdateTime   time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (Party) TableName() string {
    return "t_party"
}

// PartyMember 队伍成员
type PartyMember struct {
    ID        uint64    `gorm:"primaryKey;column:memberId" json:"member_id"`
    PartyID   uint64    `gorm:"column:partyId" json:"party_id"`
    RoleID    uint64    `gorm:"column:roleId" json:"role_id"`
    PlayerID  uint32    `gorm:"column:playerId" json:"player_id"`
    TeamType  uint32    `gorm:"column:teamType" json:"team_type"`
    Status    uint32    `gorm:"column:status" json:"status"`
    JoinTime  time.Time `gorm:"column:joinTime" json:"join_time"`
}

func (PartyMember) TableName() string {
    return "t_party_member"
}
```

### 3. Handler 实现

#### handlers/party.go
```go
package handlers

import (
    "context"

    "github.com/pixb/DnfGameServer/dnf-go-server/internal/game/party_service"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/network"
    dnfv1 "github.com/pixb/DnfGameServer/dnf-go-server/proto/gen/dnf/v1"
    "google.golang.org/protobuf/proto"
)

type PartyHandler struct {
    partyService *party_service.PartyService
}

func NewPartyHandler(partyService *party_service.PartyService) *PartyHandler {
    return &PartyHandler{
        partyService: partyService,
    }
}

// SearchPartyListHandler 搜索队伍列表处理器
func (h *PartyHandler) SearchPartyListHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.SearchPartyListRequest)
    if !ok {
        return
    }

    parties, err := h.partyService.SearchPartyList(context.Background(), req.Dungeonindex, req.Minlevel, req.Maxlevel)
    if err != nil {
        h.sendError(sess, req, 1, "failed to search party list")
        return
    }

    resp := &dnfv1.SearchPartyListResponse{
        Parties: parties,
        Error:   0,
    }
    sess.Send(resp)
}

// StartMultiPlayHandler 开始多人游戏处理器
func (h *PartyHandler) StartMultiPlayHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.StartMultiPlayRequest)
    if !ok {
        return
    }

    result, err := h.partyService.StartMultiPlay(context.Background(), sess.RoleID, req.Partyguid)
    if err != nil {
        h.sendError(sess, req, 1, "failed to start multi play")
        return
    }

    resp := &dnfv1.StartMultiPlayResponse{
        Matchingguid: result.MatchingGuid,
        Dungeonguid: result.DungeonGuid,
        Battleworld:  1,
        Bchannel:     1,
        Bip:          result.IP,
        Bport:        result.Port,
        Matchtype:    3,
        World:        1,
        Channel:       1,
        Users:        result.Users,
        Detail:       result.Detail,
        Error:        0,
    }
    sess.Send(resp)
}

// ControlGroupHandler 控制队伍处理器
func (h *PartyHandler) ControlGroupHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.ControlGroupRequest)
    if !ok {
        return
    }

    err := h.partyService.ControlGroup(context.Background(), sess.RoleID, req.Action, req.Targetguid)
    if err != nil {
        h.sendError(sess, req, 1, "failed to control group")
        return
    }

    resp := &dnfv1.ControlGroupResponse{
        Error: 0,
    }
    sess.Send(resp)
}

// MultiPlaySyncDungeonHandler 多人游戏同步副本处理器
func (h *PartyHandler) MultiPlaySyncDungeonHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MultiPlaySyncDungeonRequest)
    if !ok {
        return
    }

    err := h.partyService.SyncDungeon(context.Background(), sess.RoleID, req.Stageid, req.Progress)
    if err != nil {
        h.sendError(sess, req, 1, "failed to sync dungeon")
        return
    }

    resp := &dnfv1.MultiPlaySyncDungeonResponse{
        Error: 0,
    }
    sess.Send(resp)
}

// VoteKickOutUserHandler 投票踢出用户处理器
func (h *PartyHandler) VoteKickOutUserHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.VoteKickOutUserRequest)
    if !ok {
        return
    }

    err := h.partyService.VoteKickOut(context.Background(), sess.RoleID, req.Targetguid)
    if err != nil {
        h.sendError(sess, req, 1, "failed to vote kick out")
        return
    }

    resp := &dnfv1.VoteKickOutUserResponse{
        Error: 0,
    }
    sess.Send(resp)
}

func (h *PartyHandler) sendError(sess *network.Session, req proto.Message, code uint32, message string) {
    // 根据请求类型发送错误响应
    switch req.(type) {
    case *dnfv1.SearchPartyListRequest:
        resp := &dnfv1.SearchPartyListResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.StartMultiPlayRequest:
        resp := &dnfv1.StartMultiPlayResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    default:
        // 通用错误处理
    }
}
```

## 实现步骤

### 步骤 1: 创建 ProtoBuf 定义
1. 创建 `proto/dnf/v1/party.proto`
2. 定义所有组队相关的消息
3. 运行 `buf generate` 生成 Go 代码

### 步骤 2: 创建数据模型
1. 创建 `internal/db/models/party.go`
2. 定义 Party 和 PartyMember 模型
3. 运行数据库迁移

### 步骤 3: 实现 Handler
1. 创建 `internal/game/handlers/party.go`
2. 实现所有组队相关的处理器
3. 注册消息路由

### 步骤 4: 实现 Service
1. 创建 `internal/game/party_service/party.go`
2. 实现业务逻辑
3. 集成数据库操作

### 步骤 5: 编写测试用例
1. 创建 `tests/party_test.go`
2. 编写所有功能的测试用例
3. 运行测试验证

### 步骤 6: 集成到主服务器
1. 在 `cmd/server/main.go` 中注册 Handler
2. 更新消息注册表
3. 测试完整流程

## 注意事项

1. **队伍管理**: 正确管理队伍创建、加入、离开
2. **权限控制**: 队长有特殊权限
3. **状态同步**: 队伍成员状态需要同步
4. **副本集成**: 组队系统与副本系统紧密集成
5. **投票机制**: 踢人需要投票机制
6. **错误处理**: 完善的错误处理和日志记录
