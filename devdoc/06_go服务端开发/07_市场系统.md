# 市场系统设计文档

## 概述

市场系统是玩家之间进行物品交易的核心功能，支持玩家上架物品、购买物品、搜索物品等操作。

## Java 代码分析

### 核心控制器
- **文件位置**: `src/main/java/com/dnfm/game/market/MarketController.java`
- **处理器数量**: 0 个（当前为空类，待实现）

### 核心功能

市场系统目前为空类，需要实现以下功能：

#### 1. 市场列表查询
- **功能**: 查询市场中的物品列表
- **参数**:
  - 页码
  - 每页数量
  - 物品类型
  - 等级范围
  - 价格范围
- **返回内容**:
  - 物品列表
  - 总数量

#### 2. 物品上架
- **功能**: 玩家将物品上架到市场
- **参数**:
  - 物品 GUID
  - 物品数量
  - 价格
  - 货币类型
- **返回内容**:
  - 上架结果
  - 市场物品 ID

#### 3. 物品下架
- **功能**: 玩家下架自己的物品
- **参数**:
  - 市场物品 ID
- **返回内容**:
  - 下架结果

#### 4. 物品购买
- **功能**: 玩家购买市场中的物品
- **参数**:
  - 市场物品 ID
  - 购买数量
- **返回内容**:
  - 购买结果
  - 物品信息

#### 5. 市场搜索
- **功能**: 搜索市场中的物品
- **参数**:
  - 物品名称
  - 物品类型
  - 等级范围
  - 价格范围
- **返回内容**:
  - 搜索结果列表

#### 6. 我的上架列表
- **功能**: 查询玩家自己上架的物品
- **参数**:
  - 页码
  - 每页数量
- **返回内容**:
  - 上架物品列表
  - 总数量

## Go 实现方案

### 1. ProtoBuf 消息定义

#### market.proto
```protobuf
syntax = "proto3";

package dnf.v1;

option go_package = "gen/dnf/v1";

import "dnf/v1/common.proto";

// 市场物品信息
message MarketItem {
    uint64 id = 1;
    uint64 seller_guid = 2;
    string seller_name = 3;
    uint64 item_guid = 4;
    uint32 item_index = 5;
    uint32 item_count = 6;
    bool bind = 7;
    uint32 quality = 8;
    uint32 level = 9;
    uint64 price = 10;
    uint32 currency_type = 11;
    uint64 create_time = 12;
    uint64 expire_time = 13;
}

// 市场列表请求
message MarketListRequest {
    uint32 page = 1;
    uint32 page_size = 2;
    uint32 item_type = 3;
    uint32 min_level = 4;
    uint32 max_level = 5;
    uint64 min_price = 6;
    uint64 max_price = 7;
}

// 市场列表响应
message MarketListResponse {
    repeated MarketItem items = 1;
    uint32 total = 2;
    uint32 error = 3;
    string message = 4;
}

// 物品上架请求
message MarketAddRequest {
    uint64 item_guid = 1;
    uint32 item_count = 2;
    uint64 price = 3;
    uint32 currency_type = 4;
}

// 物品上架响应
message MarketAddResponse {
    uint64 market_id = 1;
    uint32 error = 2;
    string message = 3;
}

// 物品下架请求
message MarketRemoveRequest {
    uint64 market_id = 1;
}

// 物品下架响应
message MarketRemoveResponse {
    uint32 error = 2;
    string message = 3;
}

// 物品购买请求
message MarketBuyRequest {
    uint64 market_id = 1;
    uint32 buy_count = 2;
}

// 物品购买响应
message MarketBuyResponse {
    MarketItem item = 1;
    uint32 error = 2;
    string message = 3;
}

// 市场搜索请求
message MarketSearchRequest {
    string item_name = 1;
    uint32 item_type = 2;
    uint32 min_level = 3;
    uint32 max_level = 4;
    uint64 min_price = 5;
    uint64 max_price = 6;
    uint32 page = 7;
    uint32 page_size = 8;
}

// 市场搜索响应
message MarketSearchResponse {
    repeated MarketItem items = 1;
    uint32 total = 2;
    uint32 error = 3;
    string message = 4;
}

// 我的上架列表请求
message MarketMyListRequest {
    uint32 page = 1;
    uint32 page_size = 2;
}

// 我的上架列表响应
message MarketMyListResponse {
    repeated MarketItem items = 1;
    uint32 total = 2;
    uint32 error = 3;
    string message = 4;
}
```

### 2. 数据模型设计

#### models/market.go
```go
package models

import (
    "time"
    "gorm.io/gorm"
)

// MarketItem 市场物品
type MarketItem struct {
    ID           uint64    `gorm:"primaryKey;column:id" json:"id"`
    SellerGUID   uint64    `gorm:"column:sellerGuid;index" json:"seller_guid"`
    SellerName   string    `gorm:"column:sellerName;size:50" json:"seller_name"`
    ItemGUID     uint64    `gorm:"column:itemGuid;uniqueIndex" json:"item_guid"`
    ItemIndex    uint32    `gorm:"column:itemIndex;index" json:"item_index"`
    ItemCount    uint32    `gorm:"column:itemCount" json:"item_count"`
    Bind         bool      `gorm:"column:bind" json:"bind"`
    Quality      uint32    `gorm:"column:quality" json:"quality"`
    Level        uint32    `gorm:"column:level;index" json:"level"`
    Price        uint64    `gorm:"column:price;index" json:"price"`
    CurrencyType uint32    `gorm:"column:currencyType" json:"currency_type"`
    Status       uint32    `gorm:"column:status;default:0" json:"status"`
    CreateTime   time.Time `gorm:"column:createTime" json:"create_time"`
    ExpireTime   time.Time `gorm:"column:expireTime;index" json:"expire_time"`
    UpdateTime   time.Time `gorm:"column:updateTime" json:"update_time"`
}

func (MarketItem) TableName() string {
    return "t_market_item"
}

// MarketRecord 市场交易记录
type MarketRecord struct {
    ID          uint64    `gorm:"primaryKey;column:id" json:"id"`
    MarketID    uint64    `gorm:"column:marketId;index" json:"market_id"`
    SellerGUID  uint64    `gorm:"column:sellerGuid;index" json:"seller_guid"`
    BuyerGUID   uint64    `gorm:"column:buyerGuid;index" json:"buyer_guid"`
    ItemGUID    uint64    `gorm:"column:itemGuid" json:"item_guid"`
    ItemIndex   uint32    `gorm:"column:itemIndex" json:"item_index"`
    ItemCount   uint32    `gorm:"column:itemCount" json:"item_count"`
    Price       uint64    `gorm:"column:price" json:"price"`
    CurrencyType uint32   `gorm:"column:currencyType" json:"currency_type"`
    Tax         uint64    `gorm:"column:tax" json:"tax"`
    TradeTime   time.Time `gorm:"column:tradeTime" json:"trade_time"`
    CreateTime  time.Time `gorm:"column:createTime" json:"create_time"`
}

func (MarketRecord) TableName() string {
    return "t_market_record"
}
```

### 3. Handler 实现

#### handlers/market.go
```go
package handlers

import (
    "context"

    "github.com/pixb/DnfGameServer/dnf-go-server/internal/game/market_service"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/network"
    dnfv1 "github.com/pixb/DnfGameServer/dnf-go-server/proto/gen/dnf/v1"
    "google.golang.org/protobuf/proto"
)

type MarketHandler struct {
    marketService *market_service.MarketService
}

func NewMarketHandler(marketService *market_service.MarketService) *MarketHandler {
    return &MarketHandler{
        marketService: marketService,
    }
}

// MarketListHandler 市场列表处理器
func (h *MarketHandler) MarketListHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MarketListRequest)
    if !ok {
        return
    }

    items, total, err := h.marketService.GetMarketList(context.Background(), req.Page, req.PageSize, req.ItemType, req.MinLevel, req.MaxLevel, req.MinPrice, req.MaxPrice)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get market list")
        return
    }

    resp := &dnfv1.MarketListResponse{
        Items:  items,
        Total:  total,
        Error:  0,
    }
    sess.Send(resp)
}

// MarketAddHandler 物品上架处理器
func (h *MarketHandler) MarketAddHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MarketAddRequest)
    if !ok {
        return
    }

    marketID, err := h.marketService.AddItemToMarket(context.Background(), sess.RoleID, req.ItemGuid, req.ItemCount, req.Price, req.CurrencyType)
    if err != nil {
        h.sendError(sess, req, 1, "failed to add item to market")
        return
    }

    resp := &dnfv1.MarketAddResponse{
        MarketId: marketID,
        Error:    0,
    }
    sess.Send(resp)
}

// MarketRemoveHandler 物品下架处理器
func (h *MarketHandler) MarketRemoveHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MarketRemoveRequest)
    if !ok {
        return
    }

    err := h.marketService.RemoveItemFromMarket(context.Background(), sess.RoleID, req.MarketId)
    if err != nil {
        h.sendError(sess, req, 1, "failed to remove item from market")
        return
    }

    resp := &dnfv1.MarketRemoveResponse{
        Error: 0,
    }
    sess.Send(resp)
}

// MarketBuyHandler 物品购买处理器
func (h *MarketHandler) MarketBuyHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MarketBuyRequest)
    if !ok {
        return
    }

    item, err := h.marketService.BuyItemFromMarket(context.Background(), sess.RoleID, req.MarketId, req.BuyCount)
    if err != nil {
        h.sendError(sess, req, 1, "failed to buy item from market")
        return
    }

    resp := &dnfv1.MarketBuyResponse{
        Item:  item,
        Error: 0,
    }
    sess.Send(resp)
}

// MarketSearchHandler 市场搜索处理器
func (h *MarketHandler) MarketSearchHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MarketSearchRequest)
    if !ok {
        return
    }

    items, total, err := h.marketService.SearchMarket(context.Background(), req.ItemName, req.ItemType, req.MinLevel, req.MaxLevel, req.MinPrice, req.MaxPrice, req.Page, req.PageSize)
    if err != nil {
        h.sendError(sess, req, 1, "failed to search market")
        return
    }

    resp := &dnfv1.MarketSearchResponse{
        Items:  items,
        Total:  total,
        Error:  0,
    }
    sess.Send(resp)
}

// MarketMyListHandler 我的上架列表处理器
func (h *MarketHandler) MarketMyListHandler(sess *network.Session, msg proto.Message) {
    req, ok := msg.(*dnfv1.MarketMyListRequest)
    if !ok {
        return
    }

    items, total, err := h.marketService.GetMyMarketList(context.Background(), sess.RoleID, req.Page, req.PageSize)
    if err != nil {
        h.sendError(sess, req, 1, "failed to get my market list")
        return
    }

    resp := &dnfv1.MarketMyListResponse{
        Items:  items,
        Total:  total,
        Error:  0,
    }
    sess.Send(resp)
}

func (h *MarketHandler) sendError(sess *network.Session, req proto.Message, code uint32, message string) {
    switch req.(type) {
    case *dnfv1.MarketListRequest:
        resp := &dnfv1.MarketListResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.MarketAddRequest:
        resp := &dnfv1.MarketAddResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.MarketRemoveRequest:
        resp := &dnfv1.MarketRemoveResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.MarketBuyRequest:
        resp := &dnfv1.MarketBuyResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.MarketSearchRequest:
        resp := &dnfv1.MarketSearchResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    case *dnfv1.MarketMyListRequest:
        resp := &dnfv1.MarketMyListResponse{
            Error:   code,
            Message: message,
        }
        sess.Send(resp)
    }
}
```

### 4. Service 实现

#### market_service/market.go
```go
package market_service

import (
    "context"
    "time"

    "github.com/pixb/DnfGameServer/dnf-go-server/store"
    "github.com/pixb/DnfGameServer/dnf-go-server/internal/db/models"
    dnfv1 "github.com/pixb/DnfGameServer/dnf-go-server/proto/gen/dnf/v1"
)

type MarketService struct {
    store *store.Store
}

func NewMarketService(store *store.Store) *MarketService {
    return &MarketService{
        store: store,
    }
}

// GetMarketList 获取市场列表
func (s *MarketService) GetMarketList(ctx context.Context, page, pageSize, itemType, minLevel, maxLevel uint32, minPrice, maxPrice uint64) ([]*dnfv1.MarketItem, uint32, error) {
    offset := (page - 1) * pageSize

    items, total, err := s.store.GetMarketItems(ctx, &store.FindMarketItem{
        ItemType:   itemType,
        MinLevel:   minLevel,
        MaxLevel:   maxLevel,
        MinPrice:   minPrice,
        MaxPrice:   maxPrice,
        Status:     0,
    }, offset, pageSize)
    if err != nil {
        return nil, 0, err
    }

    return items, uint32(total), nil
}

// AddItemToMarket 物品上架
func (s *MarketService) AddItemToMarket(ctx context.Context, roleID, itemGUID uint64, itemCount uint32, price uint64, currencyType uint32) (uint64, error) {
    // 1. 验证物品是否属于玩家
    bagItem, err := s.store.GetBagItem(ctx, itemGUID)
    if err != nil {
        return 0, err
    }

    if bagItem.RoleID != roleID {
        return 0, store.ErrNotFound
    }

    if bagItem.Count < itemCount {
        return 0, store.ErrInvalidParam
    }

    // 2. 从背包移除物品
    err = s.store.RemoveBagItem(ctx, itemGUID, itemCount)
    if err != nil {
        return 0, err
    }

    // 3. 添加到市场
    marketItem := &models.MarketItem{
        SellerGUID:   roleID,
        ItemGUID:     itemGUID,
        ItemIndex:    bagItem.ItemIndex,
        ItemCount:    itemCount,
        Bind:         bagItem.Bind,
        Quality:      bagItem.Quality,
        Level:        bagItem.Level,
        Price:        price,
        CurrencyType: currencyType,
        Status:       0,
        CreateTime:   time.Now(),
        ExpireTime:   time.Now().Add(7 * 24 * time.Hour),
        UpdateTime:   time.Now(),
    }

    err = s.store.CreateMarketItem(ctx, marketItem)
    if err != nil {
        return 0, err
    }

    return marketItem.ID, nil
}

// RemoveItemFromMarket 物品下架
func (s *MarketService) RemoveItemFromMarket(ctx context.Context, roleID, marketID uint64) error {
    // 1. 获取市场物品
    marketItem, err := s.store.GetMarketItem(ctx, marketID)
    if err != nil {
        return err
    }

    // 2. 验证是否是自己的物品
    if marketItem.SellerGUID != roleID {
        return store.ErrNotFound
    }

    // 3. 将物品返回到背包
    bagItem := &models.BagItem{
        RoleID:    roleID,
        ItemIndex: marketItem.ItemIndex,
        Count:     marketItem.ItemCount,
        Bind:      marketItem.Bind,
        Quality:   marketItem.Quality,
        Level:     marketItem.Level,
        CreateTime: time.Now(),
        UpdateTime: time.Now(),
    }

    err = s.store.CreateBagItem(ctx, bagItem)
    if err != nil {
        return err
    }

    // 4. 删除市场物品
    return s.store.DeleteMarketItem(ctx, marketID)
}

// BuyItemFromMarket 购买物品
func (s *MarketService) BuyItemFromMarket(ctx context.Context, buyerID, marketID uint64, buyCount uint32) (*dnfv1.MarketItem, error) {
    // 1. 获取市场物品
    marketItem, err := s.store.GetMarketItem(ctx, marketID)
    if err != nil {
        return nil, err
    }

    // 2. 验证数量
    if marketItem.ItemCount < buyCount {
        return nil, store.ErrInvalidParam
    }

    // 3. 扣除买家货币
    totalPrice := marketItem.Price * uint64(buyCount) / uint64(marketItem.ItemCount)
    err = s.store.DeductMoney(ctx, buyerID, totalPrice, marketItem.CurrencyType)
    if err != nil {
        return nil, err
    }

    // 4. 添加物品到买家背包
    bagItem := &models.BagItem{
        RoleID:    buyerID,
        ItemIndex: marketItem.ItemIndex,
        Count:     buyCount,
        Bind:      marketItem.Bind,
        Quality:   marketItem.Quality,
        Level:     marketItem.Level,
        CreateTime: time.Now(),
        UpdateTime: time.Now(),
    }

    err = s.store.CreateBagItem(ctx, bagItem)
    if err != nil {
        return nil, err
    }

    // 5. 计算税收
    tax := totalPrice * 5 / 100
    sellerPrice := totalPrice - tax

    // 6. 添加货币到卖家
    err = s.store.AddMoney(ctx, marketItem.SellerGUID, sellerPrice, marketItem.CurrencyType)
    if err != nil {
        return nil, err
    }

    // 7. 更新市场物品数量
    if marketItem.ItemCount == buyCount {
        err = s.store.DeleteMarketItem(ctx, marketID)
    } else {
        marketItem.ItemCount -= buyCount
        marketItem.UpdateTime = time.Now()
        err = s.store.UpdateMarketItem(ctx, marketItem)
    }
    if err != nil {
        return nil, err
    }

    // 8. 记录交易
    record := &models.MarketRecord{
        MarketID:     marketID,
        SellerGUID:   marketItem.SellerGUID,
        BuyerGUID:    buyerID,
        ItemGUID:     marketItem.ItemGUID,
        ItemIndex:    marketItem.ItemIndex,
        ItemCount:    buyCount,
        Price:        totalPrice,
        CurrencyType: marketItem.CurrencyType,
        Tax:          tax,
        TradeTime:    time.Now(),
        CreateTime:   time.Now(),
    }

    err = s.store.CreateMarketRecord(ctx, record)
    if err != nil {
        return nil, err
    }

    return &dnfv1.MarketItem{
        Id:           marketItem.ID,
        SellerGuid:   marketItem.SellerGUID,
        ItemGuid:     marketItem.ItemGUID,
        ItemIndex:    marketItem.ItemIndex,
        ItemCount:    buyCount,
        Price:        totalPrice,
        CurrencyType: marketItem.CurrencyType,
    }, nil
}

// SearchMarket 搜索市场
func (s *MarketService) SearchMarket(ctx context.Context, itemName string, itemType, minLevel, maxLevel uint32, minPrice, maxPrice uint64, page, pageSize uint32) ([]*dnfv1.MarketItem, uint32, error) {
    offset := (page - 1) * pageSize

    items, total, err := s.store.SearchMarketItems(ctx, itemName, itemType, minLevel, maxLevel, minPrice, maxPrice, offset, pageSize)
    if err != nil {
        return nil, 0, err
    }

    return items, uint32(total), nil
}

// GetMyMarketList 获取我的上架列表
func (s *MarketService) GetMyMarketList(ctx context.Context, roleID uint64, page, pageSize uint32) ([]*dnfv1.MarketItem, uint32, error) {
    offset := (page - 1) * pageSize

    items, total, err := s.store.GetMarketItems(ctx, &store.FindMarketItem{
        SellerGUID: &roleID,
        Status:     0,
    }, offset, pageSize)
    if err != nil {
        return nil, 0, err
    }

    return items, uint32(total), nil
}
```

## 实现步骤

### 步骤 1: 创建 ProtoBuf 定义
1. 创建 `proto/dnf/v1/market.proto`
2. 定义所有市场相关的消息
3. 运行 `buf generate` 生成 Go 代码

### 步骤 2: 创建数据模型
1. 创建 `internal/db/models/market.go`
2. 定义 MarketItem 和 MarketRecord 模型
3. 运行数据库迁移

### 步骤 3: 实现 Handler
1. 创建 `internal/game/handlers/market.go`
2. 实现所有市场相关的处理器
3. 注册消息路由

### 步骤 4: 实现 Service
1. 创建 `internal/game/market_service/market.go`
2. 实现业务逻辑
3. 集成数据库操作

### 步骤 5: 编写测试用例
1. 创建 `tests/market_test.go`
2. 编写所有功能的测试用例
3. 运行测试验证

### 步骤 6: 集成到主服务器
1. 在 `cmd/server/main.go` 中注册 Handler
2. 更新消息注册表
3. 测试完整流程

## 注意事项

1. **交易安全**: 确保交易过程的原子性和一致性
2. **货币验证**: 验证买家是否有足够的货币
3. **物品验证**: 验证物品的所有权和数量
4. **税收计算**: 正确计算交易税收
5. **过期处理**: 定期清理过期的市场物品
6. **并发控制**: 处理并发购买和下架的情况
7. **错误处理**: 完善的错误处理和日志记录
