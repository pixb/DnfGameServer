# PK系统数据库设计文档

## 1. 数据库概览

PK系统数据库设计主要用于存储玩家的PK相关数据，包括PK战斗记录、玩家PK数据、荣誉值、排行榜信息等。这些数据将支持PK系统的核心功能，如匹配、战斗计算、荣誉值管理和排行榜更新等。

## 2. 数据库表结构

### 2.1 PK记录表 (`t_pk_record`)

| 字段名 | 数据类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | `BIGINT` | `PRIMARY KEY AUTO_INCREMENT` | 记录ID |
| `winner_id` | `BIGINT` | `NOT NULL` | 胜利者角色ID |
| `loser_id` | `BIGINT` | `NOT NULL` | 失败者角色ID |
| `winner_honor_change` | `INT` | `NOT NULL` | 胜利者荣誉值变化 |
| `loser_honor_change` | `INT` | `NOT NULL` | 失败者荣誉值变化 |
| `duration` | `INT` | `NOT NULL` | 战斗持续时间（秒） |
| `winner_max_combo` | `INT` | `NOT NULL` | 胜利者最大连击数 |
| `loser_max_combo` | `INT` | `NOT NULL` | 失败者最大连击数 |
| `battle_time` | `DATETIME` | `NOT NULL` | 战斗时间 |
| `battle_result` | `VARCHAR(10)` | `NOT NULL` | 战斗结果（WIN, LOSE, DRAW） |
| `create_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP` | 创建时间 |

**索引设计**:
- 主键索引: `id`
- 普通索引: `winner_id`, `loser_id`
- 联合索引: `(winner_id, battle_time)`, `(loser_id, battle_time)`

### 2.2 玩家PK数据表 (`t_player_pk_data`)

| 字段名 | 数据类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `player_id` | `BIGINT` | `PRIMARY KEY` | 角色ID |
| `honor` | `INT` | `NOT NULL DEFAULT 0` | 荣誉值 |
| `honor_level` | `INT` | `NOT NULL DEFAULT 1` | 荣誉等级 |
| `total_battles` | `INT` | `NOT NULL DEFAULT 0` | 总战斗场次 |
| `wins` | `INT` | `NOT NULL DEFAULT 0` | 胜利场次 |
| `losses` | `INT` | `NOT NULL DEFAULT 0` | 失败场次 |
| `draws` | `INT` | `NOT NULL DEFAULT 0` | 平局场次 |
| `ranking` | `INT` | `NOT NULL DEFAULT 0` | 排名 |
| `update_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | 更新时间 |

**索引设计**:
- 主键索引: `player_id`
- 普通索引: `ranking`, `honor`
- 联合索引: `(honor, player_id)`

### 2.3 荣誉等级配置表 (`t_honor_level`)

| 字段名 | 数据类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | `INT` | `PRIMARY KEY AUTO_INCREMENT` | 等级ID |
| `level` | `INT` | `NOT NULL UNIQUE` | 荣誉等级 |
| `min_honor` | `INT` | `NOT NULL` | 最低荣誉值 |
| `max_honor` | `INT` | `NOT NULL` | 最高荣誉值 |
| `level_name` | `VARCHAR(20)` | `NOT NULL` | 等级名称 |
| `description` | `VARCHAR(100)` | `NOT NULL` | 等级描述 |
| `create_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP` | 创建时间 |
| `update_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | 更新时间 |

**索引设计**:
- 主键索引: `id`
- 普通索引: `level`, `min_honor`

### 2.4 PK匹配队列表 (`t_pk_queue`)

| 字段名 | 数据类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | `BIGINT` | `PRIMARY KEY AUTO_INCREMENT` | 队列ID |
| `player_id` | `BIGINT` | `NOT NULL UNIQUE` | 玩家角色ID |
| `level` | `INT` | `NOT NULL` | 玩家等级 |
| `match_value` | `INT` | `NOT NULL` | 匹配值 |
| `queue_time` | `DATETIME` | `NOT NULL` | 入队时间 |
| `status` | `VARCHAR(10)` | `NOT NULL` | 状态（QUEUED, MATCHED, CANCELLED） |
| `create_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP` | 创建时间 |
| `update_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | 更新时间 |

**索引设计**:
- 主键索引: `id`
- 普通索引: `player_id`, `status`
- 联合索引: `(status, level, match_value)`

### 2.5 PK战斗表 (`t_pk_battle`)

| 字段名 | 数据类型 | 约束 | 描述 |
| :--- | :--- | :--- | :--- |
| `id` | `VARCHAR(36)` | `PRIMARY KEY` | 战斗ID（UUID） |
| `player1_id` | `BIGINT` | `NOT NULL` | 玩家1角色ID |
| `player2_id` | `BIGINT` | `NOT NULL` | 玩家2角色ID |
| `start_time` | `DATETIME` | `NOT NULL` | 开始时间 |
| `end_time` | `DATETIME` | `NULL` | 结束时间 |
| `winner_id` | `BIGINT` | `NULL` | 胜利者角色ID |
| `status` | `VARCHAR(10)` | `NOT NULL` | 状态（PENDING, IN_PROGRESS, COMPLETED） |
| `create_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP` | 创建时间 |
| `update_time` | `DATETIME` | `NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP` | 更新时间 |

**索引设计**:
- 主键索引: `id`
- 普通索引: `player1_id`, `player2_id`, `status`
- 联合索引: `(player1_id, status)`, `(player2_id, status)`

## 3. 数据传输对象 (DTOs)

### 3.1 PK记录DTO

```go
// model/pk_record.go
type PKRecord struct {
    ID                 uint64    `gorm:"column:id;primaryKey;autoIncrement" json:"id"`
    WinnerID           uint64    `gorm:"column:winner_id;not null" json:"winnerId"`
    LoserID            uint64    `gorm:"column:loser_id;not null" json:"loserId"`
    WinnerHonorChange  int       `gorm:"column:winner_honor_change;not null" json:"winnerHonorChange"`
    LoserHonorChange   int       `gorm:"column:loser_honor_change;not null" json:"loserHonorChange"`
    Duration           int       `gorm:"column:duration;not null" json:"duration"`
    WinnerMaxCombo     int       `gorm:"column:winner_max_combo;not null" json:"winnerMaxCombo"`
    LoserMaxCombo      int       `gorm:"column:loser_max_combo;not null" json:"loserMaxCombo"`
    BattleTime         time.Time `gorm:"column:battle_time;not null" json:"battleTime"`
    BattleResult       string    `gorm:"column:battle_result;not null" json:"battleResult"`
    CreateTime         time.Time `gorm:"column:create_time;autoCreateTime" json:"createTime"`
}

func (PKRecord) TableName() string {
    return "t_pk_record"
}
```

### 3.2 玩家PK数据DTO

```go
// model/player_pk_data.go
type PlayerPKData struct {
    PlayerID     uint64    `gorm:"column:player_id;primaryKey" json:"playerId"`
    Honor        int       `gorm:"column:honor;not null;default:0" json:"honor"`
    HonorLevel   int       `gorm:"column:honor_level;not null;default:1" json:"honorLevel"`
    TotalBattles int       `gorm:"column:total_battles;not null;default:0" json:"totalBattles"`
    Wins         int       `gorm:"column:wins;not null;default:0" json:"wins"`
    Losses       int       `gorm:"column:losses;not null;default:0" json:"losses"`
    Draws        int       `gorm:"column:draws;not null;default:0" json:"draws"`
    Ranking      int       `gorm:"column:ranking;not null;default:0" json:"ranking"`
    UpdateTime   time.Time `gorm:"column:update_time;autoUpdateTime" json:"updateTime"`
}

func (PlayerPKData) TableName() string {
    return "t_player_pk_data"
}
```

### 3.3 荣誉等级DTO

```go
// model/honor_level.go
type HonorLevel struct {
    ID          int       `gorm:"column:id;primaryKey;autoIncrement" json:"id"`
    Level       int       `gorm:"column:level;not null;unique" json:"level"`
    MinHonor    int       `gorm:"column:min_honor;not null" json:"minHonor"`
    MaxHonor    int       `gorm:"column:max_honor;not null" json:"maxHonor"`
    LevelName   string    `gorm:"column:level_name;not null" json:"levelName"`
    Description string    `gorm:"column:description;not null" json:"description"`
    CreateTime  time.Time `gorm:"column:create_time;autoCreateTime" json:"createTime"`
    UpdateTime  time.Time `gorm:"column:update_time;autoUpdateTime" json:"updateTime"`
}

func (HonorLevel) TableName() string {
    return "t_honor_level"
}
```

### 3.4 PK匹配队列DTO

```go
// model/pk_queue.go
type PKQueue struct {
    ID        uint64    `gorm:"column:id;primaryKey;autoIncrement" json:"id"`
    PlayerID  uint64    `gorm:"column:player_id;not null;unique" json:"playerId"`
    Level     int       `gorm:"column:level;not null" json:"level"`
    MatchValue int      `gorm:"column:match_value;not null" json:"matchValue"`
    QueueTime time.Time `gorm:"column:queue_time;not null" json:"queueTime"`
    Status    string    `gorm:"column:status;not null" json:"status"`
    CreateTime time.Time `gorm:"column:create_time;autoCreateTime" json:"createTime"`
    UpdateTime time.Time `gorm:"column:update_time;autoUpdateTime" json:"updateTime"`
}

func (PKQueue) TableName() string {
    return "t_pk_queue"
}
```

### 3.5 PK战斗DTO

```go
// model/pk_battle.go
type PKBattle struct {
    ID        string    `gorm:"column:id;primaryKey" json:"id"`
    Player1ID uint64    `gorm:"column:player1_id;not null" json:"player1Id"`
    Player2ID uint64    `gorm:"column:player2_id;not null" json:"player2Id"`
    StartTime time.Time `gorm:"column:start_time;not null" json:"startTime"`
    EndTime   *time.Time `gorm:"column:end_time" json:"endTime"`
    WinnerID  *uint64   `gorm:"column:winner_id" json:"winnerId"`
    Status    string    `gorm:"column:status;not null" json:"status"`
    CreateTime time.Time `gorm:"column:create_time;autoCreateTime" json:"createTime"`
    UpdateTime time.Time `gorm:"column:update_time;autoUpdateTime" json:"updateTime"`
}

func (PKBattle) TableName() string {
    return "t_pk_battle"
}
```

## 4. 数据库操作

### 4.1 PK记录操作

#### 4.1.1 保存PK记录

```go
// repository/pk_record_repo.go
func (r *PKRecordRepository) SaveRecord(record *model.PKRecord) error {
    return r.db.Create(record).Error
}
```

#### 4.1.2 获取玩家PK记录

```go
// repository/pk_record_repo.go
func (r *PKRecordRepository) GetPlayerRecords(playerID uint64, limit, offset int) ([]model.PKRecord, error) {
    var records []model.PKRecord
    err := r.db.Where("winner_id = ? OR loser_id = ?", playerID, playerID).
        Order("battle_time DESC").
        Limit(limit).
        Offset(offset).
        Find(&records).Error
    return records, err
}
```

### 4.2 玩家PK数据操作

#### 4.2.1 获取玩家PK数据

```go
// repository/player_pk_repo.go
func (r *PlayerPKRepository) GetPlayerPKData(playerID uint64) (*model.PlayerPKData, error) {
    var data model.PlayerPKData
    err := r.db.Where("player_id = ?", playerID).First(&data).Error
    if err == gorm.ErrRecordNotFound {
        // 如果不存在，创建默认数据
        data = model.PlayerPKData{
            PlayerID:     playerID,
            Honor:        0,
            HonorLevel:   1,
            TotalBattles: 0,
            Wins:         0,
            Losses:       0,
            Draws:        0,
            Ranking:      0,
        }
        err = r.db.Create(&data).Error
    }
    return &data, err
}
```

#### 4.2.2 更新玩家PK数据

```go
// repository/player_pk_repo.go
func (r *PlayerPKRepository) UpdatePlayerPKData(data *model.PlayerPKData) error {
    return r.db.Save(data).Error
}
```

### 4.3 排行榜操作

#### 4.3.1 获取排行榜

```go
// repository/ranking_repo.go
func (r *RankingRepository) GetTopPlayers(limit int) ([]model.PlayerPKData, error) {
    var players []model.PlayerPKData
    err := r.db.Order("honor DESC, player_id ASC").
        Limit(limit).
        Find(&players).Error
    return players, err
}
```

#### 4.3.2 更新玩家排名

```go
// repository/ranking_repo.go
func (r *RankingRepository) UpdatePlayerRanking(playerID uint64) (int, error) {
    // 计算排名
    var rank int64
    err := r.db.Model(&model.PlayerPKData{}).
        Where("honor > (SELECT honor FROM t_player_pk_data WHERE player_id = ?)", playerID).
        Count(&rank).Error
    if err != nil {
        return 0, err
    }
    
    // 更新排名
    newRank := int(rank) + 1
    err = r.db.Model(&model.PlayerPKData{}).
        Where("player_id = ?", playerID).
        Update("ranking", newRank).Error
    
    return newRank, err
}
```

### 4.4 匹配队列操作

#### 4.4.1 添加到匹配队列

```go
// repository/queue_repo.go
func (r *QueueRepository) AddToQueue(queue *model.PKQueue) error {
    return r.db.Create(queue).Error
}
```

#### 4.4.2 从匹配队列移除

```go
// repository/queue_repo.go
func (r *QueueRepository) RemoveFromQueue(playerID uint64) error {
    return r.db.Where("player_id = ?", playerID).Delete(&model.PKQueue{}).Error
}
```

#### 4.4.3 获取匹配队列玩家

```go
// repository/queue_repo.go
func (r *QueueRepository) GetQueuePlayers(levelMin, levelMax int) ([]model.PKQueue, error) {
    var players []model.PKQueue
    err := r.db.Where("status = ? AND level BETWEEN ? AND ?", "QUEUED", levelMin, levelMax).
        Order("queue_time ASC").
        Find(&players).Error
    return players, err
}
```

## 5. 数据库优化策略

1. **索引优化**:
   - 为频繁查询的字段建立索引，如`winner_id`、`loser_id`、`player_id`等
   - 为排序和范围查询的字段建立索引，如`battle_time`、`honor`等
   - 合理使用联合索引，提高多字段查询的效率

2. **分区策略**:
   - 对PK记录表(`t_pk_record`)按时间进行分区，如按年、月或季度分区
   - 对玩家PK数据表(`t_player_pk_data`)按等级段进行分区

3. **缓存策略**:
   - 使用Redis缓存热点数据，如排行榜、玩家PK数据等
   - 缓存匹配队列，减少数据库压力
   - 设置合理的缓存过期时间，保证数据一致性

4. **查询优化**:
   - 使用分页查询，避免一次性查询大量数据
   - 合理使用`JOIN`操作，避免过多的关联查询
   - 使用`EXPLAIN`分析查询执行计划，优化慢查询

5. **写入优化**:
   - 使用批量插入，减少数据库连接次数
   - 合理使用事务，保证数据一致性
   - 对频繁更新的字段，考虑使用乐观锁

6. **数据库参数优化**:
   - 调整`innodb_buffer_pool_size`，提高缓存命中率
   - 调整`innodb_log_file_size`，提高写入性能
   - 调整`max_connections`，支持更多并发连接

7. **定期维护**:
   - 定期清理过期数据，如旧的PK记录
   - 定期重建索引，提高索引效率
   - 定期备份数据库，保证数据安全

## 6. 数据安全

1. **数据加密**:
   - 对敏感数据进行加密存储
   - 使用HTTPS加密传输数据

2. **访问控制**:
   - 严格控制数据库用户权限
   - 使用参数化查询，防止SQL注入

3. **数据备份**:
   - 定期进行全量备份
   - 定期进行增量备份
   - 建立备份恢复测试机制

4. **数据审计**:
   - 记录所有数据库操作日志
   - 定期审计数据库操作

5. **容灾方案**:
   - 建立主从复制架构
   - 实现异地备份
   - 制定灾难恢复计划