# TC010_重复登录处理

## 测试用例概述

| 项目 | 内容 |
|------|------|
| 测试用例ID | TC010 |
| 测试用例名称 | 重复登录处理 |
| 所属模块 | 进入游戏系统 |
| 测试类型: 异常测试 |
| 优先级 | 高 |
| 预计执行时间 | 3分钟 |

## 测试目的

验证玩家在已登录的情况下再次登录时，系统能正确处理重复登录请求，包括踢掉旧连接、允许新连接等。

## 前置条件

### 测试环境要求
1. Java服务端已启动
2. MySQL数据库已连接
3. 测试数据库已初始化
4. 日志记录已开启

### 测试数据准备
1. 测试账号已注册
   - openid: `test_openid_010`
   - 账号状态: 正常
   - 账号类型: 普通账号

2. 测试角色已创建
   - 角色GUID: 1001
   - 角色名称: TestPlayer1
   - 角色职业: 战士
   - 角色等级: 10
   - 角色状态: 正常

3. 角色已选择并进入游戏
   - 角色状态: 已选择
   - 玩家已登录获取authKey
   - 玩家已进入游戏

### 依赖服务状态
1. 认证服务正常
2. 数据库服务正常
3. 网络连接正常

## 测试步骤

### 步骤1: 准备测试环境
**操作内容**:
1. 检查Java服务端是否启动
   - 命令: `ps aux | grep java`
   - 预期: Java进程存在

2. 检查数据库连接
   - 命令: `mysql -u root -p -e "SHOW DATABASES;"`
   - 预期: 数据库列表正常

3. 准备测试账号和角色
   - 创建测试账号（如果不存在）
   - 创建测试角色（如果不存在）
   - 选择角色
   - 进入游戏

**输入参数**:
```sql
-- 创建测试账号
INSERT INTO t_account (openid, accountID, createTime, status) VALUES ('test_openid_010', 10010, NOW(), 1);

-- 创建测试角色
INSERT INTO t_character (charguid, accountID, name, job, level, createTime, status) 
VALUES (1001, 10010, 'TestPlayer1', 1, 10, NOW(), 1);
```

**预期输出**:
- 服务端状态: 运行中
- 数据库状态: 连接正常
- 测试账号: 已创建
- 测试角色: 已创建
- 角色状态: 已选择并进入游戏

**实际输出**:
- 待测试

### 步骤2: 第一次登录获取authKey
**操作内容**:
1. 构造登录请求
   - openid: `test_openid_010`
   - 设备ID: `device_test_010`
   - 设备类型: Android
   - 客户端版本: 1.0.0

2. 发送登录请求
   - 服务器地址: 127.0.0.1
   - 服务器端口: 8080
   - 连接超时: 5000ms

3. 接收登录响应
   - 验证错误码为0
   - 获取authKey
   - 获取accountID
   - 保存authKey（用于后续验证）

**输入参数**:
```java
REQ_LOGIN req = new REQ_LOGIN();
req.setOpenid("test_openid_010");
req.setDeviceId("device_test_010");
req.setDeviceType(1);
req.setClientVersion("1.0.0");
```

**预期输出**:
- 错误码: 0
- authKey: 非空
- accountID: 10010
- 连接状态: 已建立

**实际输出**:
- 待测试

### 步骤3: 第一次选择角色
**操作内容**:
1. 构造选择角色请求
   - authKey: 从第一次登录响应获取
   - accountID: 从第一次登录响应获取
   - charguid: 1001

2. 发送选择角色请求
   - 服务器地址: 127.0.0.1
   - 服务器端口: 8080

3. 接收选择角色响应
   - 验证错误码为0
   - 验证角色信息

**输入参数**:
```java
REQ_SELECT_CHARACTER req = new REQ_SELECT_CHARACTER();
req.setAuthKey(authKey);
req.setAccountID(accountID);
req.setCharguid(1001);
```

**预期输出**:
- 错误码: 0
- 角色信息: 非空

**实际输出**:
- 待测试

### 步骤4: 第一次进入游戏
**操作内容**:
1. 构造进入游戏请求
   - authKey: 从第一次登录响应获取
   - accountID: 从第一次登录响应获取
   - charguid: 1001

2. 发送进入游戏请求
   - 服务器地址: 127.0.0.1
   - 服务器端口: 8080

3. 接收进入游戏响应
   - 验证错误码为0
   - 验证游戏数据

4. 保持连接
   - 不关闭连接
   - 保持连接活跃

**输入参数**:
```java
REQ_ENTER_GAME req = new REQ_ENTER_GAME();
req.setAuthKey(authKey);
req.setAccountID(accountID);
req.setCharguid(1001);
```

**预期输出**:
- 错误码: 0
- 游戏数据: 非空
- 连接状态: 已建立并保持

**实际输出**:
- 待测试

### 步骤5: 第二次登录（重复登录）
**操作内容**:
1. 构造第二次登录请求
   - openid: `test_openid_010`（与第一次相同）
   - 设备ID: `device_test_010_2`（不同的设备ID）
   - 设备类型: Android
   - 客户端版本: 1.0.0

2. 发送第二次登录请求
   - 服务器地址: 127.0.0.1
   - 服务器端口: 8080
   - 连接超时: 5000ms

3. 接收第二次登录响应
   - 验证错误码为0（允许重复登录）
   - 获取新的authKey
   - 获取accountID

**输入参数**:
```java
REQ_LOGIN req = new REQ_LOGIN();
req.setOpenid("test_openid_010");
req.setDeviceId("device_test_010_2");
req.setDeviceType(1);
req.setClientVersion("1.0.0");
```

**预期输出**:
- 错误码: 0（允许重复登录）
- authKey: 非空（新的authKey）
- accountID: 10010
- 连接状态: 已建立

**实际输出**:
- 待测试

### 步骤6: 验证旧连接被踢掉
**操作内容**:
1. 尝试使用旧连接发送请求
   - 使用第一次登录的authKey
   - 发送心跳请求或其他请求

2. 验证旧连接状态
   - 预期: 连接已断开或返回错误
   - 说明: 旧连接应该被服务器踢掉

3. 验证错误码
   - 预期错误码: 非0
   - 说明: 旧连接应该返回错误

**输入参数**:
```java
// 使用旧连接发送请求
REQ_HEARTBEAT req = new REQ_HEARTBEAT();
req.setAuthKey(oldAuthKey);
```

**预期输出**:
- 旧连接状态: 已断开或返回错误
- 错误码: 非0
- 说明: 旧连接已被踢掉

**实际输出**:
- 待测试

### 步骤7: 第二次选择角色
**操作内容**:
1. 构造第二次选择角色请求
   - authKey: 从第二次登录响应获取
   - accountID: 从第二次登录响应获取
   - charguid: 1001

2. 发送第二次选择角色请求
   - 服务器地址: 127.0.0.1
   - 服务器端口: 8080

3. 接收第二次选择角色响应
   - 验证错误码为0
   - 验证角色信息

**输入参数**:
```java
REQ_SELECT_CHARACTER req = new REQ_SELECT_CHARACTER();
req.setAuthKey(newAuthKey);
req.setAccountID(accountID);
req.setCharguid(1001);
```

**预期输出**:
- 错误码: 0
- 角色信息: 非空

**实际输出**:
- 待测试

### 步骤8: 第二次进入游戏
**操作内容**:
1. 构造第二次进入游戏请求
   - authKey: 从第二次登录响应获取
   - accountID: 从第二次登录响应获取
   - charguid: 1001

2. 发送第二次进入游戏请求
   - 服务器地址: 127.0.0.1
   - 服务器端口: 8080

3. 接收第二次进入游戏响应
   - 验证错误码为0
   - 验证游戏数据

**输入参数**:
```java
REQ_ENTER_GAME req = new REQ_ENTER_GAME();
req.setAuthKey(newAuthKey);
req.setAccountID(accountID);
req.setCharguid(1001);
```

**预期输出**:
- 错误码: 0
- 游戏数据: 非空
- 连接状态: 已建立

**实际输出**:
- 待测试

### 步骤9: 验证数据库记录
**操作内容**:
1. 查询角色记录
   - 表名: t_character
   - 查询条件: charguid = 1001

2. 验证角色状态
   - 检查字段: status
   - 预期值: 2（游戏中）
   - 说明: 角色应该仍然在游戏中

3. 验证最后登录时间
   - 检查字段: lastLoginTime
   - 预期值: 最近1分钟内
   - 说明: 第二次登录应该更新最后登录时间

**输入参数**:
```sql
SELECT status, lastLoginTime FROM t_character WHERE charguid = 1001;
```

**预期输出**:
- 角色状态: 2（游戏中）
- 最后登录时间: 最近1分钟内

**实际输出**:
- 待测试

### 步骤10: 验证日志记录
**操作内容**:
1. 检查服务器日志
   - 日志文件: logs/game.log
   - 搜索关键字: test_openid_010
   - 验证日志级别: INFO或WARN

2. 验证日志内容
   - 应该记录第一次登录事件
   - 应该记录第二次登录事件（重复登录）
   - 应该记录踢掉旧连接事件
   - 应该记录角色GUID
   - 应该记录角色名称

**输入参数**:
```bash
grep "test_openid_010" logs/game.log | grep "login"
```

**预期输出**:
- 日志记录: 存在
- 日志级别: INFO或WARN
- 日志内容: 包含登录和踢掉旧连接信息
- 角色GUID: 1001
- 角色名称: TestPlayer1

**实际输出**:
- 待测试

### 步骤11: 清理测试数据
**操作内容**:
1. 关闭所有连接
   - 关闭旧连接
   - 关闭新连接

2. 删除角色记录
   - 表名: t_character
   - 删除条件: accountID = 10010

3. 删除账号记录
   - 表名: t_account
   - 删除条件: accountID = 10010

4. 释放资源
   - 记录日志

**输入参数**:
```sql
DELETE FROM t_character WHERE accountID = 10010;
DELETE FROM t_account WHERE accountID = 10010;
```

**预期输出**:
- 所有连接: 已关闭
- 角色记录: 已删除
- 账号记录: 已删除
- 日志记录: 已记录

**实际输出**:
- 待测试

## 预期结果

### 成功情况
1. 第一次登录请求发送成功
2. 收到第一次登录响应，获取到authKey
3. 第一次选择角色请求发送成功
4. 收到第一次选择角色响应
5. 第一次进入游戏请求发送成功
6. 收到第一次进入游戏响应
7. 第二次登录请求发送成功
8. 收到第二次登录响应（允许重复登录）
9. 旧连接被踢掉
10. 第二次选择角色请求发送成功
11. 收到第二次选择角色响应
12. 第二次进入游戏请求发送成功
13. 收到第二次进入游戏响应
14. 角色状态仍然为游戏中
15. 日志记录了所有登录和踢掉旧连接事件

### 失败情况
1. 连接失败
2. 请求超时
3. 响应解析失败
4. 第二次登录失败（错误码非0）
5. 旧连接未被踢掉
6. 第二次选择角色失败
7. 第二次进入游戏失败
8. 角色状态异常

### 边界情况
1. 同一设备重复登录
2. 不同设备重复登录
3. 快速连续登录
4. 登录后立即重复登录
5. 登录后长时间不操作再重复登录
6. 多个客户端同时登录
7. 网络延迟导致重复登录
8. 服务器负载高时重复登录

## 实际结果

### 测试执行记录

| 项目 | 内容 |
|------|------|
| 测试日期 | 待测试 |
| 测试人员 | 待测试 |
| 测试环境 | 待测试 |
| 执行时间 | 待测试 |

### 测试步骤执行情况

| 步骤 | 状态 | 执行时间 | 备注 |
|------|------|---------|------|
| 步骤1: 准备测试环境 | ⏳ 待执行 | - | - |
| 步骤2: 第一次登录获取authKey | ⏳ 待执行 | - | - |
| 步骤3: 第一次选择角色 | ⏳ 待执行 | - | - |
| 步骤4: 第一次进入游戏 | ⏳ 待执行 | - | - |
| 步骤5: 第二次登录（重复登录） | ⏳ 待执行 | - | - |
| 步骤6: 验证旧连接被踢掉 | ⏳ 待执行 | - | - |
| 步骤7: 第二次选择角色 | ⏳ 待执行 | - | - |
| 步骤8: 第二次进入游戏 | ⏳ 待执行 | - | - |
| 步骤9: 验证数据库记录 | ⏳ 待执行 | - | - |
| 步骤10: 验证日志记录 | ⏳ 待执行 | - | - |
| 步骤11: 清理测试数据 | ⏳ 待执行 | - | - |

### 测试结果验证

| 验证项 | 预期结果 | 实际结果 | 状态 |
|--------|----------|----------|------|
| 第一次登录成功 | 成功 | 待测试 | ⏳ |
| 第一次进入游戏成功 | 成功 | 待测试 | ⏳ |
| 第二次登录成功 | 成功 | 待测试 | ⏳ |
| 旧连接被踢掉 | 已踢掉 | 待测试 | ⏳ |
| 第二次进入游戏成功 | 成功 | 待测试 | ⏳ |
| 角色状态为2 | 2 | 待测试 | ⏳ |
| 日志记录存在 | 存在 | 待测试 | ⏳ |

### 测试状态
- 总体状态: ⏳ 待测试
- 通过步骤: 0/11
- 失败步骤: 0/11
- 测试结论: 待测试

## 问题记录

### 发现的问题

| 问题ID | 问题描述 | 严重程度 | 状态 | 修复建议 |
|--------|----------|----------|------|----------|
| - | - | - | - | - |

### 已知问题

| 问题ID | 问题描述 | 影响 | 临时方案 |
|--------|----------|------|----------|
| - | - | - | - |

## 注意事项

1. **测试数据隔离**: 每次测试前必须准备独立的测试数据
2. **连接管理**: 注意管理多个连接，确保正确关闭
3. **旧连接验证**: 要验证旧连接是否真的被踢掉
4. **数据验证**: 要验证数据库中的实际数据
5. **日志记录**: 详细记录测试过程和结果
6. **性能监控**: 记录每个步骤的执行时间
7. **资源清理**: 测试完成后必须清理所有测试数据
8. **异常处理**: 测试过程中要注意异常情况
9. **重复登录策略**: 确保重复登录策略正确实现
10. **边界测试**: 注意各种重复登录的边界情况

## 参考资源

### Java代码
- Controller: `src/main/java/com/dnfm/game/auth/AuthController.java`
- Service: `src/main/java/com/dnfm/game/auth/service/AuthService.java`
- Model: `src/main/java/com/dnfm/game/auth/model/LoginInfo.java`

### Protobuf定义
- 请求: `REQ_LOGIN`
- 响应: `RES_LOGIN`

### 数据库表
- t_account: 账号表
- t_character: 角色表

### 测试工具
- JUnit: https://junit.org/junit4/
- Mockito: https://site.mockito.org/

### 错误码定义
- 1001: 认证失败
- 1002: 账号不存在
- 1003: 账号被封禁
- 1004: 重复登录
- 其他错误码请参考错误码定义文档
