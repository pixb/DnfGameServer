# 核心组件

## 一、消息基类 (Message)

**位置**：`com.dnfm.mina.protobuf.Message`

### 1.1 类定义

```java
public abstract class Message implements Serializable {
    public Integer transId = null;

    @JsonIgnore
    public int getModule() {
        MessageMeta annotation = this.getClass().getAnnotation(MessageMeta.class);
        return annotation != null ? annotation.module() : 0;
    }
}
```

### 1.2 职责

- 所有协议消息的基类
- 提供事务ID（transId）字段
- 通过@MessageMeta注解获取模块号
- 实现Serializable接口，支持序列化

### 1.3 使用示例

```java
// 创建消息对象
LOGIN.REQ req = new LOGIN.REQ();
req.transId = 12345;

// 获取模块号
int module = req.getModule(); // 返回 10000
```

## 二、消息元数据注解 (@MessageMeta)

**位置**：`com.dnfm.mina.annotation.MessageMeta`

### 2.1 注解定义

```java
@Documented
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MessageMeta {
    int module() default 0;  // 模块号
    int cmd() default 0;      // 命令号
}
```

### 2.2 作用

- 标识消息的模块号和命令号
- 用于消息路由和分发
- 运行时保留，支持反射获取

### 2.3 使用示例

```java
@MessageMeta(module = 10000, cmd = 1)
public class LOGIN {
    public static class REQ {
        // 请求字段
    }

    public static class RES {
        // 响应字段
    }
}
```

## 三、Protobuf字段注解 (@Protobuf)

### 3.1 注解定义

```java
@Documented
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Protobuf {
    FieldType fieldType() default FieldType.OBJECT;
    int order() default 0;
    boolean required() default false;
}
```

### 3.2 支持的类型

| FieldType | 说明 | Java类型 |
|-----------|------|---------|
| `INT32` | 32位整数 | `Integer` |
| `UINT32` | 无符号32位整数 | `Integer` |
| `INT64` | 64位整数 | `Long` |
| `UINT64` | 无符号64位整数 | `Long` |
| `FLOAT` | 单精度浮点 | `Float` |
| `DOUBLE` | 双精度浮点 | `Double` |
| `STRING` | 字符串 | `String` |
| `BOOL` | 布尔值 | `Boolean` |
| `OBJECT` | 对象类型 | 自定义类 |

### 3.3 使用示例

```java
@Protobuf(fieldType = FieldType.INT32, order = 1, required = false)
public Integer error;

@Protobuf(fieldType = FieldType.UINT64, order = 2, required = false)
public Long userId;

@Protobuf(fieldType = FieldType.STRING, order = 3, required = false)
public String name;
```

## 四、消息工厂 (MessageFactory)

**位置**：`com.dnfm.mina.message.MessageFactory`

### 4.1 核心功能

1. **消息注册**：扫描protobuf包下的所有Message子类
2. **消息映射**：建立module_cmd与消息类的双向映射
3. **消息查找**：根据module和cmd获取对应的消息类

### 4.2 关键方法

```java
// 初始化消息池
public void initMessagePool(String scanPath)

// 根据module和cmd获取消息类
public Class<?> getMessage(int module, int cmd)

// 根据消息类获取消息ID
public String getMessageId(Class<?> clazz)
```

### 4.3 消息ID格式

格式：`{module}_{cmd}`

示例：
- `10000_1` → LOGIN.REQ
- `10000_2` → LOGIN.RES
- `10001_1` → CHARACTER_INFO.REQ

### 4.4 注册流程

```java
// 1. 扫描protobuf包
Set<Class<?>> messages = ClassScanner.listAllSubclasses(
    "com.dnfm.mina.protobuf",
    Message.class
);

// 2. 遍历消息类
for (Class<?> clazz : messages) {
    // 3. 获取@MessageMeta注解
    MessageMeta meta = clazz.getAnnotation(MessageMeta.class);

    // 4. 构建消息ID
    String key = module + "_" + cmd;

    // 5. 注册到消息工厂
    id2Clazz.put(key, clazz);
    clazz2Id.put(clazz, key);
}
```

## 五、序列化助手 (SerializerHelper)

**位置**：`com.dnfm.mina.codec.SerializerHelper`

### 5.1 核心功能

1. **编码**：将Java对象转换为protobuf字节数组
2. **解码**：将protobuf字节数组转换为Java对象
3. **Codec管理**：使用ProtobufProxy创建编解码器

### 5.2 关键方法

```java
// 编码消息
public static byte[] protobufEncode(Message message)

// 解码消息
public static Message protobufDecode(short module, short cmd, byte[] body)

// 编码对象
public static byte[] protobufEncodeObject(Object obj)

// 解码对象
public static Object protobufDecodeObject(Class<?> objClazz, byte[] body)
```

### 5.3 使用示例

```java
// 编码
LOGIN.REQ req = new LOGIN.REQ();
req.userId = 123456L;
byte[] data = SerializerHelper.protobufEncode(req);

// 解码
Message msg = SerializerHelper.protobufDecode(10000, 1, data);
```

## 六、编码器 (DNFEncoder)

**位置**：`com.dnfm.mina.codec.DNFEncoder`

### 6.1 职责

- 将Message对象编码为网络字节流
- 添加消息头信息
- 对消息体进行加密

### 6.2 编码流程

```
Message对象
    ↓
protobufEncode() → protobuf字节数组
    ↓
Enc.encrypt() → 加密字节数组
    ↓
添加消息头 (8字节)
    ↓
IoBuffer (网络字节流)
```

### 6.3 消息头格式

**格式**：8字节，小端序

```
┌────────┬────────┬─────┬──────┬──────────┐
│ 总长度  │ 模块号  │ 序号 │ 事务ID│ body长度 │
│ 2字节  │ 2字节   │ 1字节│ 1字节 │  2字节   │
└────────┴────────┴─────┴──────┴──────────┘
```

**字段说明**：
- **总长度**：整个消息的长度（包括消息头）
- **模块号**：消息所属的模块号
- **序号**：消息序列号，用于加密
- **事务ID**：事务标识，用于请求响应匹配
- **body长度**：消息体的长度

## 七、解码器 (DNFDecoder)

**位置**：`com.dnfm.mina.codec.DNFDecoder`

### 7.1 职责

- 从网络字节流中解析消息
- 验证消息完整性
- 解密消息体
- 反序列化为Message对象

### 7.2 解码流程

```
IoBuffer (网络字节流)
    ↓
解析消息头 (8字节)
    ↓
提取消息体
    ↓
Enc.decrypt2() → 解密字节数组
    ↓
protobufDecode() → Message对象
    ↓
输出到协议处理器
```

### 7.3 错误处理

```java
try {
    Message msg = SerializerHelper.protobufDecode(module, cmd, decBody);
    protocolDecoderOutput.write(msg);
} catch (Exception e) {
    logger.error("DECODE_ERR=={}=={}", moduleId, ioBuffer.getHexDump());
}
```

## 八、编解码工厂 (MessageCodecFactory)

**位置**：`com.dnfm.mina.codec.MessageCodecFactory`

### 8.1 职责

- 实现MINA的ProtocolCodecFactory接口
- 提供编码器和解码器实例

### 8.2 类定义

```java
public class MessageCodecFactory implements ProtocolCodecFactory {
    private final DNFDecoder decoder = new DNFDecoder();
    private final DNFEncoder encoder = new DNFEncoder();

    public ProtocolEncoder getEncoder(IoSession session) {
        return this.encoder;
    }

    public ProtocolDecoder getDecoder(IoSession session) {
        return this.decoder;
    }
}
```

## 九、消息加密 (Enc)

**位置**：`com.dnfm.mina.codec.Enc`

### 9.1 功能

- 对消息体进行加密传输
- 防止消息被篡改和窃听
- 使用序列号(seq)作为加密参数

### 9.2 关键方法

```java
// 加密
public static byte[] encrypt(byte seq, byte[] data)

// 解密
public static byte[] decrypt2(byte seq, byte[] data)
```

### 9.3 使用示例

```java
// 加密
byte[] plainData = SerializerHelper.protobufEncode(req);
byte[] encData = Enc.encrypt(seq, plainData);

// 解密
byte[] decData = Enc.decrypt2(seq, encData);
Message msg = SerializerHelper.protobufDecode(module, cmd, decData);
```
