# 消息类型

## 一、消息命名规范

| 前缀 | 含义 | 示例 |
|------|------|------|
| `REQ/RES` | 请求/响应消息对 | LOGIN.REQ, LOGIN.RES |
| `PT_` | 数据结构类 | PT_CHARACTER, PT_ITEM |
| `ENUM_` | 枚举类型 | ENUM_ROOM_TYPE, ENUM_TEAM |
| `NOTIFY_` | 通知消息 | NOTIFY_PARTY_INFO |
| `RES_` | 响应消息 | RES_SKILL_INFO |
| `REQ_` | 请求消息 | REQ_SKILL_INFO |

## 二、消息模块划分

### 2.1 核心模块

#### 登录认证
- **LOGIN**：登录请求/响应
- **AUTH_INFO**：认证信息
- **CHECK_AUTH**：检查认证
- **GET_SESSION**：获取会话

#### 会话管理
- **HEARTBEAT**：心跳消息
- **LOGOUT**：退出登录
- **EXIT**：退出游戏
- **EXIT_CHARACTER**：退出角色

#### 角色管理
- **CHARACTER_INFO**：角色信息
- **PT_CHARACTER**：角色数据结构
- **PLAYER_DATA**：玩家数据

### 2.2 游戏模块

#### 副本系统
- **RES_START_DUNGEON**：开始副本响应
- **RES_STAGE_INFO**：关卡信息响应
- **DUNGEON_PLAYER**：副本玩家信息

#### 技能系统
- **RES_SKILL_LIST**：技能列表响应
- **RES_SKILL_INFO**：技能信息响应
- **RES_SKILL_SET**：技能设置响应

#### 物品系统
- **SendItem_Info**：发送物品信息
- **PT_ITEM**：物品数据结构
- **RES_USE_COIN**：使用金币响应

#### 任务系统
- **RES_UPDATE_QUEST**：更新任务响应
- **RES_TUTORIAL_LIST**：教程列表响应

### 2.3 社交模块

#### 组队系统
- **NOTIFY_PARTY_INFO**：队伍信息通知
- **NOTIFY_PARTY_JOIN**：加入队伍通知

#### 聊天系统
- **CHAT_BASE**：聊天基础消息
- **SEND_CHAT**：发送聊天
- **ENTER_TOWN_CHAT**：进入城镇聊天

#### 公会系统
- **ENUM_GUILD_***：公会相关枚举
- **NOTIFY_GUILD_***：公会通知

### 2.4 其他模块

#### 商城系统
- **RES_SHOP_LIMIT_RESET**：商城限制重置响应
- **PT_CERA_SHOP_***：商城数据结构

#### 结婚系统
- **RES_WEDDING_***：婚礼相关响应
- **ENUM_WEDDING_***：婚礼相关枚举

#### 竞技系统
- **RES_START_MULTI_PLAY**：开始多人游戏响应
- **RES_PVP_***：PVP相关响应

## 三、消息示例

### 3.1 登录消息 (LOGIN)

#### 3.1.1 请求消息

```java
@MessageMeta(module = 10000, cmd = 1)
public class LOGIN {
    public static class REQ {
        @Protobuf(fieldType = FieldType.UINT64, order = 1, required = false)
        public Long userId;

        @Protobuf(fieldType = FieldType.UINT32, order = 2, required = false)
        public Integer roomId;

        @Protobuf(fieldType = FieldType.UINT64, order = 3, required = false)
        public Long accessToken;
    }
}
```

**字段说明**：
- `userId`：用户ID，64位无符号整数
- `roomId`：房间ID，32位无符号整数
- `accessToken`：访问令牌，64位无符号整数

#### 3.1.2 响应消息

```java
public static class RES {
    @Protobuf(fieldType = FieldType.INT32, order = 1, required = false)
    public Integer error;

    @Protobuf(fieldType = FieldType.INT32, order = 2, required = false)
    public Integer playerId;

    @Protobuf(fieldType = FieldType.STRING, order = 3, required = false)
    public String udpHost;

    @Protobuf(fieldType = FieldType.INT32, order = 4, required = false)
    public Integer udpPort;
}
```

**字段说明**：
- `error`：错误码，0表示成功
- `playerId`：玩家ID
- `udpHost`：UDP服务器地址
- `udpPort`：UDP服务器端口

### 3.2 角色数据 (PT_CHARACTER)

```java
@MessageMeta(module = 10001, cmd = 1)
public class PT_CHARACTER {
    @Protobuf(fieldType = FieldType.UINT64, order = 1, required = false)
    public Long charguid;

    @Protobuf(fieldType = FieldType.INT32, order = 5, required = false)
    public Integer job;

    @Protobuf(fieldType = FieldType.INT32, order = 6, required = false)
    public Integer level;

    @Protobuf(fieldType = FieldType.STRING, order = 7, required = false)
    public String name;

    @Protobuf(fieldType = FieldType.INT32, order = 8, required = false)
    public Integer fatigue;
}
```

**字段说明**：
- `charguid`：角色GUID，64位无符号整数
- `job`：职业类型，32位整数
- `level`：角色等级，32位整数
- `name`：角色名称，字符串
- `fatigue`：疲劳值，32位整数

### 3.3 技能列表 (RES_SKILL_LIST)

```java
@MessageMeta(module = 12000, cmd = 1)
public class RES_SKILL_LIST {
    @Protobuf(fieldType = FieldType.INT32, order = 1, required = false)
    public Integer error;

    @Protobuf(fieldType = FieldType.OBJECT, order = 2, required = false)
    public PT_SKILL_INFO skill_info;
}
```

### 3.4 物品信息 (PT_ITEM)

```java
public class PT_ITEM {
    @Protobuf(fieldType = FieldType.INT32, order = 1, required = false)
    public Integer item_id;

    @Protobuf(fieldType = FieldType.INT32, order = 2, required = false)
    public Integer count;

    @Protobuf(fieldType = FieldType.INT32, order = 3, required = false)
    public Integer quality;

    @Protobuf(fieldType = FieldType.INT32, order = 4, required = false)
    public Integer level;
}
```

**字段说明**：
- `item_id`：物品ID
- `count`：物品数量
- `quality`：物品品质
- `level`：物品等级

## 四、消息处理流程

### 4.1 客户端发送消息流程

```
1. 客户端创建消息对象
   LOGIN.REQ req = new LOGIN.REQ();
   req.userId = 123456L;
   req.roomId = 100;
   req.accessToken = 789L;

2. 序列化
   byte[] body = SerializerHelper.protobufEncode(req);

3. 加密
   byte[] encBody = Enc.encrypt(seq, body);

4. 组装消息头
   totalLen = 8 + encBody.length;
   moduleId = 10000;

5. 发送到服务器
   socket.send(buffer);
```

### 4.2 服务器接收消息流程

```
1. MINA接收字节流
   IoBuffer buffer = session.read();

2. DNFDecoder解码
   - 解析消息头
   - 验证消息完整性
   - 提取消息体

3. 解密消息体
   byte[] decBody = Enc.decrypt2(seq, encBody);

4. 反序列化
   Message msg = SerializerHelper.protobufDecode(module, cmd, decBody);

5. 消息分发
   MessageDispatcher.dispatch(msg);

6. 业务处理
   CmdExecutor.execute(msg);
```

### 4.3 服务器发送响应流程

```
1. 业务处理完成，创建响应
   LOGIN.RES res = new LOGIN.RES();
   res.error = 0;
   res.playerId = 1001;

2. 序列化
   byte[] body = SerializerHelper.protobufEncode(res);

3. 加密
   byte[] encBody = Enc.encrypt(seq, body);

4. 组装消息头
   totalLen = 8 + encBody.length;

5. 发送到客户端
   session.write(buffer);
```

## 五、消息注册机制

### 5.1 启动时注册流程

```java
// 1. 扫描protobuf包
Set<Class<?>> messages = ClassScanner.listAllSubclasses(
    "com.dnfm.mina.protobuf",
    Message.class
);

// 2. 遍历消息类
for (Class<?> clazz : messages) {
    // 3. 获取@MessageMeta注解
    MessageMeta meta = clazz.getAnnotation(MessageMeta.class);

    // 4. 构建消息ID
    String key = module + "_" + cmd;

    // 5. 注册到消息工厂
    id2Clazz.put(key, clazz);
    clazz2Id.put(clazz, key);
}
```

### 5.2 消息查找机制

```java
// 根据module和cmd查找消息类
public Class<?> getMessage(int module, int cmd) {
    String key = buildKey(module, cmd);
    return id2Clazz.get(key);
}

// 根据消息类查找消息ID
public String getMessageId(Class<?> clazz) {
    return clazz2Id.get(clazz);
}
```

## 六、统计信息

### 6.1 协议文件统计

- **总文件数**：约100+个Java文件
- **@Protobuf注解数**：558个
- **@MessageMeta注解数**：100个
- **消息类数量**：100+个

### 6.2 消息类型分布

| 类型 | 数量 | 占比 |
|------|------|------|
| REQ/RES消息对 | 约50对 | 50% |
| PT_数据结构 | 约30个 | 30% |
| ENUM_枚举 | 约15个 | 15% |
| NOTIFY_通知 | 约5个 | 5% |

## 七、开发指南

### 7.1 创建新消息

#### 7.1.1 创建消息类

```java
@MessageMeta(module = 10000, cmd = 100)
public class NEW_MESSAGE {
    public static class REQ {
        @Protobuf(fieldType = FieldType.INT32, order = 1, required = false)
        public Integer param1;

        @Protobuf(fieldType = FieldType.STRING, order = 2, required = false)
        public String param2;
    }

    public static class RES {
        @Protobuf(fieldType = FieldType.INT32, order = 1, required = false)
        public Integer error;

        @Protobuf(fieldType = FieldType.STRING, order = 2, required = false)
        public String result;
    }
}
```

#### 7.1.2 创建消息处理器

```java
@CmdMapping(module = 10000, cmd = 100)
public class NewMessageHandler implements CmdExecutor {
    @Override
    public void execute(Message message, IoSession session) {
        NEW_MESSAGE.REQ req = (NEW_MESSAGE.REQ) message;
        // 处理业务逻辑
    }
}
```

#### 7.1.3 发送响应

```java
NEW_MESSAGE.RES res = new NEW_MESSAGE.RES();
res.error = 0;
res.result = "success";
session.write(res);
```

### 7.2 调试技巧

#### 7.2.1 查看消息日志

```java
// 在DNFEncoder和DNFDecoder中查看消息日志
logger.error("SENDMSG=={}=={}=={}", module, className, json);
logger.error("RECVMSG=={}=={}=={}", module, className, json);
```

#### 7.2.2 查看十六进制数据

```java
String hexStr = ioBuffer.getHexDump();
logger.error("HEX=={}", hexStr);
```

#### 7.2.3 使用MessageFactory.main方法

```java
// 生成消息ID映射表
MessageFactory.main(args);
```
