# JProtobuf渐进式迁移实现方案

## 核心思想

通过**双模式运行**实现渐进式迁移，新旧协议共存，通过配置切换，支持灰度发布。

## 实现步骤

### 第一步：创建标准Protobuf编解码器

#### 1.1 创建标准Protobuf解码器

创建`StandardProtobufDecoder.java`：

```java
package com.dnfm.mina.codec;

import com.dnfm.game.utils.ByteBuffUtil;
import com.dnfm.mina.protobuf.generated.*;
import org.apache.mina.core.buffer.IoBuffer;
import org.apache.mina.core.session.IoSession;
import org.apache.mina.filter.codec.CumulativeProtocolDecoder;
import org.apache.mina.filter.codec.ProtocolDecoderOutput;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class StandardProtobufDecoder extends CumulativeProtocolDecoder {
    static final int MIN_PACKET_LEN = 8;
    Logger logger = LoggerFactory.getLogger(StandardProtobufDecoder.class);

    protected boolean doDecode(IoSession ioSession, IoBuffer ioBuffer, ProtocolDecoderOutput protocolDecoderOutput) throws Exception {
        if (ioBuffer.remaining() < 8) {
            return false;
        } else {
            ioBuffer.mark();
            ioBuffer = ioBuffer.order(ByteOrder.LITTLE_ENDIAN);
            
            if (ioBuffer.remaining() < 8) {
                this.logger.error("小于MIN_PACKET_LEN");
                ioBuffer.reset();
                return false;
            } else {
                int totalLen = ByteBuffUtil.readUnsignedShort(ioBuffer);
                int remaining = ioBuffer.remaining();
                
                if (remaining < totalLen - 2) {
                    ioBuffer.reset();
                    return false;
                } else {
                    int moduleId = ByteBuffUtil.readUnsignedShort(ioBuffer);
                    byte seq = ByteBuffUtil.readByte(ioBuffer);
                    Integer transactionId = Integer.valueOf(ByteBuffUtil.readByte(ioBuffer));
                    ByteBuffUtil.readUnsignedShort(ioBuffer); // 跳过保留字段
                    
                    if (totalLen > 8) {
                        byte[] body = new byte[totalLen - 8];
                        ioBuffer.get(body);
                        
                        try {
                            Message msg = decodeMessage(moduleId, body);
                            if (transactionId != 0) {
                                msg.transId = transactionId;
                            }
                            
                            this.logger.info("StandardProtobuf RECVMSG=={}=={}", moduleId, msg.getClass().getSimpleName());
                            protocolDecoderOutput.write(msg);
                        } catch (Exception e) {
                            this.logger.error("StandardProtobuf DECODE_ERR=={}=={}", moduleId, e.getMessage());
                        }
                    } else {
                        // 空消息体，创建空消息
                        Message msg = decodeMessage(moduleId, new byte[0]);
                        if (transactionId != 0) {
                            msg.transId = transactionId;
                        }
                        protocolDecoderOutput.write(msg);
                    }
                    
                    return true;
                }
            }
        }
    }
    
    private Message decodeMessage(int moduleId, byte[] body) throws Exception {
        // 根据moduleId映射到标准Protobuf消息类型
        switch (moduleId) {
            case 10000: // 登录请求
                return LoginRequest.parseFrom(body);
            case 10001: // 登录响应
                return LoginResponse.parseFrom(body);
            // 添加更多消息类型的映射
            default:
                throw new Exception("Unknown module ID: " + moduleId);
        }
    }
}
```

#### 1.2 创建标准Protobuf编码器

创建`StandardProtobufEncoder.java`：

```java
package com.dnfm.mina.codec;

import com.dnfm.game.utils.ByteBuffUtil;
import com.dnfm.mina.protobuf.Message;
import org.apache.mina.core.buffer.IoBuffer;
import org.apache.mina.core.session.IoSession;
import org.apache.mina.filter.codec.ProtocolEncoder;
import org.apache.mina.filter.codec.ProtocolEncoderOutput;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class StandardProtobufEncoder implements ProtocolEncoder {
    Logger logger = LoggerFactory.getLogger(StandardProtobufEncoder.class);

    public void encode(IoSession ioSession, Object message, ProtocolEncoderOutput protocolEncoderOutput) throws Exception {
        if (!(message instanceof Message)) {
            return;
        }

        Message msg = (Message) message;
        int moduleId = msg.getModule();
        
        // 使用标准Protobuf序列化消息体
        byte[] body = encodeMessage(moduleId, msg);
        
        // 构建消息头（不加密，不压缩）
        int totalLen = body.length + 8;
        
        IoBuffer buffer = IoBuffer.allocate(totalLen);
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        buffer.putShort((short) totalLen);
        buffer.putShort((short) moduleId);
        buffer.put((byte) 1); // seq
        buffer.put((byte) (msg.transId != null ? msg.transId : 0));
        buffer.putShort((short) 0); // reserved
        buffer.put(body);
        buffer.flip();
        
        this.logger.info("StandardProtobuf SENDMSG=={}=={}", moduleId, msg.getClass().getSimpleName());
        protocolEncoderOutput.write(buffer);
    }
    
    private byte[] encodeMessage(int moduleId, Message msg) throws Exception {
        // 根据moduleId映射到标准Protobuf消息类型
        switch (moduleId) {
            case 10000: // 登录请求
                return ((com.dnfm.mina.protobuf.generated.LoginRequest) msg).toByteArray();
            case 10001: // 登录响应
                return ((com.dnfm.mina.protobuf.generated.LoginResponse) msg).toByteArray();
            // 添加更多消息类型的映射
            default:
                throw new Exception("Unknown module ID: " + moduleId);
        }
    }
}
```

### 第二步：修改编解码器工厂，支持双模式

修改`MessageCodecFactory.java`：

```java
package com.dnfm.mina.codec;

import org.apache.mina.core.session.IoSession;
import org.apache.mina.filter.codec.ProtocolCodecFactory;
import org.apache.mina.filter.codec.ProtocolDecoder;
import org.apache.mina.filter.codec.ProtocolEncoder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class MessageCodecFactory implements ProtocolCodecFactory {
    private final DNFDecoder jprotobufDecoder;
    private final DNFEncoder jprotobufEncoder;
    private final StandardProtobufDecoder standardProtobufDecoder;
    private final StandardProtobufEncoder standardProtobufEncoder;
    
    @Value("${protobuf.mode:jprotobuf}")
    private String protobufMode;
    
    public MessageCodecFactory() {
        this.jprotobufDecoder = new DNFDecoder();
        this.jprotobufEncoder = new DNFEncoder();
        this.standardProtobufDecoder = new StandardProtobufDecoder();
        this.standardProtobufEncoder = new StandardProtobufEncoder();
    }

    public ProtocolEncoder getEncoder(IoSession session) throws Exception {
        if ("standard".equals(protobufMode)) {
            return this.standardProtobufEncoder;
        } else {
            return this.jprotobufEncoder;
        }
    }

    public ProtocolDecoder getDecoder(IoSession session) throws Exception {
        if ("standard".equals(protobufMode)) {
            return this.standardProtobufDecoder;
        } else {
            return this.jprotobufDecoder;
        }
    }
}
```

### 第三步：添加配置项

在`application.properties`中添加：

```properties
# Protobuf模式：jprotobuf（默认）或 standard（新标准Protobuf）
protobuf.mode=jprotobuf
```

### 第四步：创建适配器类

创建适配器，将标准Protobuf消息转换为业务逻辑可用的格式：

```java
package com.dnfm.mina.protobuf.adapter;

import com.dnfm.mina.protobuf.REQ_LOGIN;
import com.dnfm.mina.protobuf.generated.LoginRequest;

public class ProtobufAdapter {
    public static REQ_LOGIN toOldLoginRequest(LoginRequest newRequest) {
        REQ_LOGIN oldRequest = new REQ_LOGIN();
        oldRequest.openid = newRequest.getOpenid();
        oldRequest.type = (int) newRequest.getType();
        oldRequest.token = newRequest.getToken();
        oldRequest.platID = (int) newRequest.getPlatID();
        oldRequest.clientIP = newRequest.getClientIP();
        oldRequest.version = newRequest.getVersion();
        oldRequest.friendopenid = newRequest.getFriendopenid();
        oldRequest.cancelunregist = (int) newRequest.getCancelunregist();
        oldRequest.countrycode = newRequest.getCountrycode();
        oldRequest.toyplatid = newRequest.getToyplatid();
        oldRequest.agetype = newRequest.getAgetype();
        return oldRequest;
    }
    
    public static LoginRequest toNewLoginRequest(REQ_LOGIN oldRequest) {
        LoginRequest.Builder builder = LoginRequest.newBuilder();
        builder.setOpenid(oldRequest.openid);
        builder.setType(oldRequest.type);
        builder.setToken(oldRequest.token);
        builder.setPlatID(oldRequest.platID);
        builder.setClientIP(oldRequest.clientIP);
        builder.setVersion(oldRequest.version);
        builder.setFriendopenid(oldRequest.friendopenid);
        builder.setCancelunregist(oldRequest.cancelunregist);
        builder.setCountrycode(oldRequest.countrycode);
        builder.setToyplatid(oldRequest.toyplatid);
        builder.setAgetype(oldRequest.agetype);
        return builder.build();
    }
}
```

### 第五步：修改Controller，支持双模式

修改`EnterGameController.java`中的登录处理方法：

```java
@RequestMapping
public void ReqLogin(IoSession session, Object reqLogin) {
    REQ_LOGIN loginRequest;
    
    // 根据配置项判断使用哪种协议
    if (reqLogin instanceof com.dnfm.mina.protobuf.generated.LoginRequest) {
        // 新标准Protobuf
        com.dnfm.mina.protobuf.generated.LoginRequest newRequest = 
            (com.dnfm.mina.protobuf.generated.LoginRequest) reqLogin;
        loginRequest = ProtobufAdapter.toOldLoginRequest(newRequest);
    } else {
        // 旧JProtobuf
        loginRequest = (REQ_LOGIN) reqLogin;
    }
    
    // 原有的业务逻辑不变
    Integer agetype = loginRequest.agetype;
    String clientIP = loginRequest.clientIP;
    String countrycode = loginRequest.countrycode;
    String openid = loginRequest.openid;
    Integer platID = loginRequest.platID;
    String token = loginRequest.token;
    Integer toyplatid = loginRequest.toyplatid;
    int type = loginRequest.type;
    String version = loginRequest.version;
    
    // ... 原有的业务逻辑 ...
}
```

## 渐进式测试流程

### 阶段1：双模式验证（第1天）

1. **配置使用JProtobuf**
   ```properties
   protobuf.mode=jprotobuf
   ```
   - 启动Java服务端
   - 使用旧客户端测试
   - 验证功能正常

2. **配置使用标准Protobuf**
   ```properties
   protobuf.mode=standard
   ```
   - 启动Java服务端
   - 使用Go客户端测试
   - 验证功能正常

### 阶段2：灰度发布（第2-3天）

1. **实现按用户比例切换**
   - 添加用户ID哈希逻辑
   - 根据哈希值决定使用哪种协议
   - 监控两种协议的性能和错误率

2. **小范围灰度**
   - 10%用户使用标准Protobuf
   - 90%用户使用JProtobuf
   - 监控24小时，观察错误率

3. **扩大灰度范围**
   - 50%用户使用标准Protobuf
   - 50%用户使用JProtobuf
   - 监控24小时，观察错误率

### 阶段3：完全切换（第4-5天）

1. **100%切换到标准Protobuf**
   ```properties
   protobuf.mode=standard
   ```
   - 启动Java服务端
   - 所有用户使用标准Protobuf
   - 监控24小时，观察错误率

2. **移除JProtobuf依赖**
   - 删除JProtobuf编解码器
   - 删除适配器类
   - 删除JProtobuf依赖
   - 清理旧代码

## 测试检查清单

### 双模式验证

- [ ] 配置使用JProtobuf，启动Java服务端
- [ ] 使用旧客户端测试，验证功能正常
- [ ] 配置使用标准Protobuf，启动Java服务端
- [ ] 使用Go客户端测试，验证功能正常
- [ ] 对比两种模式的性能差异
- [ ] 记录测试结果

### 灰度发布

- [ ] 实现按用户比例切换逻辑
- [ ] 小范围灰度（10%），监控24小时
- [ ] 扩大灰度范围（50%），监控24小时
- [ ] 100%切换到标准Protobuf
- [ ] 监控24小时，观察错误率
- [ ] 记录灰度发布结果

### 完全切换

- [ ] 移除JProtobuf编解码器
- [ ] 移除适配器类
- [ ] 移除JProtobuf依赖
- [ ] 清理旧代码
- [ ] 更新文档
- [ ] 记录迁移结果

## 优势

1. **零停机迁移**：通过双模式运行，无需停机
2. **风险可控**：可以随时回滚到旧协议
3. **渐进式验证**：每个阶段都可以验证功能正常
4. **灰度发布**：可以按用户比例逐步切换
5. **性能对比**：可以对比两种协议的性能差异

## 注意事项

1. **数据一致性**：确保新旧协议生成的数据格式一致
2. **性能监控**：密切监控两种协议的性能差异
3. **错误处理**：确保错误日志清晰，便于排查问题
4. **回滚机制**：准备好回滚方案，确保可以快速切换回旧协议
5. **文档更新**：及时更新文档，记录迁移过程和结果

## 总结

通过双模式运行和灰度发布，我们可以实现JProtobuf到标准Protobuf的渐进式迁移，确保迁移过程的稳定性和可靠性。
