# 测试与验证

## 渐进式测试原则

**重要**：本文档描述的是完整的测试流程，但在实际迁移中，请务必遵循以下原则：

1. **每个文件转换后立即测试**，不要等待所有文件转换完成再测试
2. **测试通过后再迁移下一个文件**，避免累积错误
3. **保持新旧代码共存**，通过配置快速切换
4. **记录测试结果**，便于追踪和回滚
5. **出现问题立即回滚**，不要继续迁移

## 测试流程

```
选择文件 → 转换.proto → 生成代码 → 单元测试 → 集成测试 → 通过？ → 是 → 迁移下一个文件
                                                      ↓
                                                    否 → 回滚并修复
```

## 一、单元测试

### 1.1 消息转换测试

```java
import org.junit.Test;
import static org.junit.Assert.*;

public class MessageConversionTest {

    @Test
    public void testLoginMessageConversion() {
        // 创建原始JProtobuf消息
        LOGIN.REQ originalReq = new LOGIN.REQ();
        originalReq.userId = 123456L;
        originalReq.roomId = 100;
        originalReq.accessToken = 789L;

        // 转换为标准protobuf
        byte[] bytes = StandardProtobufSerializer.encode(originalReq);

        // 从标准protobuf解码
        Message decoded = StandardProtobufSerializer.decode(10000, 1, bytes);

        // 验证数据一致性
        assertNotNull(decoded);
        assertEquals(originalReq.userId, ((LOGIN.REQ) decoded).userId);
        assertEquals(originalReq.roomId, ((LOGIN.REQ) decoded).roomId);
        assertEquals(originalReq.accessToken, ((LOGIN.REQ) decoded).accessToken);
    }

    @Test
    public void testCharacterMessageConversion() {
        // 创建原始JProtobuf消息
        PT_CHARACTER originalChar = new PT_CHARACTER();
        originalChar.charguid = 123456L;
        originalChar.job = 1;
        originalChar.level = 50;
        originalChar.name = "TestPlayer";

        // 转换为标准protobuf
        byte[] bytes = StandardProtobufSerializer.encode(originalChar);

        // 从标准protobuf解码
        Message decoded = StandardProtobufSerializer.decode(10001, 1, bytes);

        // 验证数据一致性
        assertNotNull(decoded);
        assertEquals(originalChar.charguid, ((PT_CHARACTER) decoded).charguid);
        assertEquals(originalChar.job, ((PT_CHARACTER) decoded).job);
        assertEquals(originalChar.level, ((PT_CHARACTER) decoded).level);
        assertEquals(originalChar.name, ((PT_CHARACTER) decoded).name);
    }
}
```

### 1.2 序列化测试

```java
@Test
public void testSerialization() {
    // 测试序列化和反序列化
    AuthProto.LoginRequest request = AuthProto.LoginRequest.newBuilder()
        .setOpenid("user123")
        .setType(1)
        .setToken("abc123")
        .build();

    // 序列化
    byte[] data = request.toByteArray();

    // 反序列化
    AuthProto.LoginRequest parsed = AuthProto.LoginRequest.parseFrom(data);

    // 验证数据一致性
    assertEquals(request.getOpenid(), parsed.getOpenid());
    assertEquals(request.getType(), parsed.getType());
    assertEquals(request.getToken(), parsed.getToken());
}
```

### 1.3 边界值测试

```java
@Test
public void testBoundaryValues() {
    // 测试边界值
    AuthProto.LoginRequest request = AuthProto.LoginRequest.newBuilder()
        .setOpenid("")  // 空字符串
        .setType(0)  // 最小值
        .setToken("a".repeat(1000))  // 长字符串
        .build();

    // 序列化和反序列化
    byte[] data = request.toByteArray();
    AuthProto.LoginRequest parsed = AuthProto.LoginRequest.parseFrom(data);

    // 验证数据一致性
    assertEquals(request.getOpenid(), parsed.getOpenid());
    assertEquals(request.getType(), parsed.getType());
    assertEquals(request.getToken(), parsed.getToken());
}
```

## 二、集成测试

### 2.1 网络通信测试

```java
@Test
public void testNetworkCommunication() throws Exception {
    // 启动服务器
    GameServer server = new GameServer();
    server.start();

    try {
        // 连接客户端
        Socket client = new Socket("localhost", 20001);

        // 发送标准protobuf消息
        AuthProto.LoginRequest req = AuthProto.LoginRequest.newBuilder()
            .setOpenid("user123")
            .setType(1)
            .setToken("abc123")
            .build();

        byte[] data = req.toByteArray();
        // 添加消息头
        byte[] packet = buildPacket(10000, 1, data);

        // 发送数据
        client.getOutputStream().write(packet);
        client.getOutputStream().flush();

        // 接收响应
        byte[] response = readResponse(client);
        AuthProto.LoginResponse res = AuthProto.LoginResponse.parseFrom(response);

        // 验证响应
        assertEquals(0, res.getError());
        assertNotNull(res.getAuthKey());

        // 关闭连接
        client.close();
    } finally {
        // 关闭服务器
        server.stop();
    }
}

private byte[] buildPacket(int module, int cmd, byte[] body) {
    byte seq = 0;
    byte transId = 0;
    int totalLen = 8 + body.length;

    ByteBuffer buffer = ByteBuffer.allocate(totalLen);
    buffer.order(ByteOrder.LITTLE_ENDIAN);

    buffer.putShort((short) totalLen);
    buffer.putShort((short) module);
    buffer.put(seq);
    buffer.put(transId);
    buffer.putShort((short) body.length);
    buffer.put(body);

    return buffer.array();
}

private byte[] readResponse(Socket client) throws IOException {
    // 读取消息头
    byte[] header = new byte[8];
    client.getInputStream().read(header);

    ByteBuffer buffer = ByteBuffer.wrap(header);
    buffer.order(ByteOrder.LITTLE_ENDIAN);

    int totalLen = buffer.getShort() & 0xFFFF;
    int bodyLen = buffer.getShort(6) & 0xFFFF;

    // 读取消息体
    byte[] body = new byte[bodyLen];
    client.getInputStream().read(body);

    return body;
}
```

### 2.2 端到端测试

```java
@Test
public void testEndToEnd() throws Exception {
    // 启动服务器
    GameServer server = new GameServer();
    server.start();

    try {
        // 连接客户端
        Socket client = new Socket("localhost", 20001);

        // 发送登录请求
        sendLoginRequest(client, "user123", "abc123");

        // 接收登录响应
        AuthProto.LoginResponse loginRes = receiveLoginResponse(client);
        assertEquals(0, loginRes.getError());

        // 发送角色列表请求
        sendCharacterListRequest(client);

        // 接收角色列表响应
        CharacterProto.CharacterListResponse charListRes = receiveCharacterListResponse(client);
        assertEquals(0, charListRes.getError());
        assertTrue(charListRes.getCharactersCount() > 0);

        // 关闭连接
        client.close();
    } finally {
        // 关闭服务器
        server.stop();
    }
}
```

### 2.3 并发测试

```java
@Test
public void testConcurrentRequests() throws Exception {
    // 启动服务器
    GameServer server = new GameServer();
    server.start();

    try {
        // 创建多个客户端连接
        List<Socket> clients = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            Socket client = new Socket("localhost", 20001);
            clients.add(client);
        }

        // 并发发送请求
        ExecutorService executor = Executors.newFixedThreadPool(10);
        List<Future<?>> futures = new ArrayList<>();

        for (int i = 0; i < 10; i++) {
            final int index = i;
            Future<?> future = executor.submit(() -> {
                try {
                    sendLoginRequest(clients.get(index), "user" + index, "token" + index);
                    receiveLoginResponse(clients.get(index));
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
            futures.add(future);
        }

        // 等待所有请求完成
        for (Future<?> future : futures) {
            future.get();
        }

        // 关闭所有连接
        for (Socket client : clients) {
            client.close();
        }

        executor.shutdown();
    } finally {
        // 关闭服务器
        server.stop();
    }
}
```

## 三、性能测试

### 3.1 序列化性能对比

```java
@Test
public void testSerializationPerformance() {
    int iterations = 10000;

    // 测试JProtobuf性能
    long jprotobufStart = System.currentTimeMillis();
    for (int i = 0; i < iterations; i++) {
        LOGIN.REQ req = new LOGIN.REQ();
        req.userId = 123456L;
        req.roomId = 100;
        req.accessToken = 789L;
        byte[] bytes = SerializerHelper.protobufEncode(req);
    }
    long jprotobufEnd = System.currentTimeMillis();

    // 测试标准protobuf性能
    long protobufStart = System.currentTimeMillis();
    for (int i = 0; i < iterations; i++) {
        AuthProto.LoginRequest req = AuthProto.LoginRequest.newBuilder()
            .setOpenid("user123")
            .setType(1)
            .setToken("abc123")
            .build();
        byte[] bytes = req.toByteArray();
    }
    long protobufEnd = System.currentTimeMillis();

    // 输出结果
    System.out.println("JProtobuf: " + (jprotobufEnd - jprotobufStart) + "ms");
    System.out.println("Protobuf: " + (protobufEnd - protobufStart) + "ms");
    System.out.println("性能提升: " + ((jprotobufEnd - jprotobufStart) - (protobufEnd - protobufStart)) + "ms");

    // 验证性能不下降
    assertTrue((protobufEnd - protobufStart) <= (jprotobufEnd - jprotobufStart));
}
```

### 3.2 反序列化性能对比

```java
@Test
public void testDeserializationPerformance() {
    int iterations = 10000;

    // 准备测试数据
    LOGIN.REQ originalReq = new LOGIN.REQ();
    originalReq.userId = 123456L;
    originalReq.roomId = 100;
    originalReq.accessToken = 789L;
    byte[] jprotobufData = SerializerHelper.protobufEncode(originalReq);

    AuthProto.LoginRequest protoReq = AuthProto.LoginRequest.newBuilder()
        .setOpenid("user123")
        .setType(1)
        .setToken("abc123")
        .build();
    byte[] protobufData = protoReq.toByteArray();

    // 测试JProtobuf性能
    long jprotobufStart = System.currentTimeMillis();
    for (int i = 0; i < iterations; i++) {
        LOGIN.REQ req = (LOGIN.REQ) SerializerHelper.protobufDecode(10000, 1, jprotobufData);
    }
    long jprotobufEnd = System.currentTimeMillis();

    // 测试标准protobuf性能
    long protobufStart = System.currentTimeMillis();
    for (int i = 0; i < iterations; i++) {
        AuthProto.LoginRequest req = AuthProto.LoginRequest.parseFrom(protobufData);
    }
    long protobufEnd = System.currentTimeMillis();

    // 输出结果
    System.out.println("JProtobuf: " + (jprotobufEnd - jprotobufStart) + "ms");
    System.out.println("Protobuf: " + (protobufEnd - protobufStart) + "ms");
    System.out.println("性能提升: " + ((jprotobufEnd - jprotobufStart) - (protobufEnd - protobufStart)) + "ms");

    // 验证性能不下降
    assertTrue((protobufEnd - protobufStart) <= (jprotobufEnd - jprotobufStart));
}
```

### 3.3 内存使用测试

```java
@Test
public void testMemoryUsage() {
    // 测试内存使用
    Runtime runtime = Runtime.getRuntime();

    // 创建大量消息对象
    List<AuthProto.LoginRequest> requests = new ArrayList<>();
    for (int i = 0; i < 10000; i++) {
        AuthProto.LoginRequest req = AuthProto.LoginRequest.newBuilder()
            .setOpenid("user" + i)
            .setType(1)
            .setToken("token" + i)
            .build();
        requests.add(req);
    }

    // 获取内存使用
    long usedMemory = runtime.totalMemory() - runtime.freeMemory();
    System.out.println("内存使用: " + (usedMemory / 1024 / 1024) + " MB");

    // 验证内存使用合理
    assertTrue(usedMemory < 100 * 1024 * 1024);  // 小于100MB
}
```

## 四、兼容性测试

### 4.1 向后兼容性测试

```java
@Test
public void testBackwardCompatibility() {
    // 测试旧客户端能否解析新消息
    AuthProto.LoginRequest newReq = AuthProto.LoginRequest.newBuilder()
        .setOpenid("user123")
        .setType(1)
        .setToken("abc123")
        .setPlatId(1)  // 新增字段
        .setClientIp("127.0.0.1")  // 新增字段
        .build();

    // 序列化
    byte[] data = newReq.toByteArray();

    // 旧客户端解析（忽略未知字段）
    AuthProto.LoginRequest oldReq = AuthProto.LoginRequest.parseFrom(data);

    // 验证核心字段一致
    assertEquals(newReq.getOpenid(), oldReq.getOpenid());
    assertEquals(newReq.getType(), oldReq.getType());
    assertEquals(newReq.getToken(), oldReq.getToken());
}
```

### 4.2 向前兼容性测试

```java
@Test
public void testForwardCompatibility() {
    // 测试新客户端能否解析旧消息
    AuthProto.LoginRequest oldReq = AuthProto.LoginRequest.newBuilder()
        .setOpenid("user123")
        .setType(1)
        .setToken("abc123")
        .build();

    // 序列化
    byte[] data = oldReq.toByteArray();

    // 新客户端解析
    AuthProto.LoginRequest newReq = AuthProto.LoginRequest.parseFrom(data);

    // 验证数据一致
    assertEquals(oldReq.getOpenid(), newReq.getOpenid());
    assertEquals(oldReq.getType(), newReq.getType());
    assertEquals(oldReq.getToken(), newReq.getToken());
}
```

### 4.3 多版本共存测试

```java
@Test
public void testMultiVersionCoexistence() {
    // 测试新旧协议能否共存
    // 使用JProtobuf发送消息
    LOGIN.REQ jprotobufReq = new LOGIN.REQ();
    jprotobufReq.userId = 123456L;
    byte[] jprotobufData = SerializerHelper.protobufEncode(jprotobufReq);

    // 使用标准protobuf发送消息
    AuthProto.LoginRequest protoReq = AuthProto.LoginRequest.newBuilder()
        .setOpenid("user123")
        .setType(1)
        .setToken("abc123")
        .build();
    byte[] protoData = protoReq.toByteArray();

    // 验证两者都能正常工作
    assertNotNull(jprotobufData);
    assertNotNull(protoData);
}
```

## 五、渐进式迁移

### 5.1 双模式运行

```java
public class HybridSerializer {
    private static final boolean USE_STANDARD_PROTOBUF = true;  // 配置开关

    public static byte[] encode(Message message) {
        if (USE_STANDARD_PROTOBUF) {
            return StandardProtobufSerializer.encode(message);
        } else {
            return SerializerHelper.protobufEncode(message);
        }
    }

    public static Message decode(int module, int cmd, byte[] data) {
        if (USE_STANDARD_PROTOBUF) {
            return StandardProtobufSerializer.decode(module, cmd, data);
        } else {
            return SerializerHelper.protobufDecode(module, cmd, data);
        }
    }
}
```

### 5.2 分模块迁移

```java
public class ModuleMigrationConfig {
    private static final Set<String> MIGRATED_MODULES = new HashSet<>();
    static {
        MIGRATED_MODULES.add("LOGIN");
        MIGRATED_MODULES.add("AUTH_INFO");
        MIGRATED_MODULES.add("CHARACTER_INFO");
        // TODO: 逐步添加其他模块
    }

    public static boolean isMigrated(String moduleName) {
        return MIGRATED_MODULES.contains(moduleName);
    }
}
```

### 5.3 灰度发布

```java
public class GradualRelease {
    private static final double MIGRATION_RATIO = 0.1;  // 10%的用户使用新协议

    public static boolean useNewProtocol(String userId) {
        // 根据userId决定是否使用新协议
        int hash = userId.hashCode();
        return Math.abs(hash % 100) < (MIGRATION_RATIO * 100);
    }
}
```
