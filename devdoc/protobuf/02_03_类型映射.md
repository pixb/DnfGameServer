# 类型映射

## 一、基本类型映射

### 1.1 JProtobuf到标准Protobuf映射表

| JProtobuf | 标准Protobuf | Java类型 | 说明 |
|-----------|--------------|----------|------|
| `FieldType.INT32` | `int32` | `Integer` | 32位有符号整数 |
| `FieldType.UINT32` | `uint32` | `Integer` | 32位无符号整数 |
| `FieldType.INT64` | `int64` | `Long` | 64位有符号整数 |
| `FieldType.UINT64` | `uint64` | `Long` | 64位无符号整数 |
| `FieldType.FLOAT` | `float` | `Float` | 单精度浮点数 |
| `FieldType.DOUBLE` | `double` | `Double` | 双精度浮点数 |
| `FieldType.BOOL` | `bool` | `Boolean` | 布尔值 |
| `FieldType.STRING` | `string` | `String` | 字符串 |
| `FieldType.BYTES` | `bytes` | `byte[]` | 字节数组 |
| `FieldType.OBJECT` | `message` | 自定义类 | 自定义消息类型 |

### 1.2 类型选择建议

#### 1.2.1 整数类型

**使用int32的情况**：
- 数值范围在-2^31到2^31-1之间
- 不需要无符号支持
- 节省存储空间

**使用uint32的情况**：
- 数值范围在0到2^32-1之间
- 需要无符号支持
- ID、计数器等

**使用int64的情况**：
- 数值范围在-2^63到2^63-1之间
- 时间戳、大ID等

**使用uint64的情况**：
- 数值范围在0到2^64-1之间
- 需要无符号支持
- 大ID、GUID等

#### 1.2.2 浮点类型

**使用float的情况**：
- 精度要求不高
- 坐标、角度等

**使用double的情况**：
- 精度要求高
- 金钱、经验值等

## 二、集合类型映射

### 2.1 集合类型映射表

| JProtobuf | 标准Protobuf | 说明 | 示例 |
|-----------|--------------|------|------|
| `List<T>` | `repeated T` | 重复字段 | `repeated int32 items = 1;` |
| `Map<K, V>` | `map<K, V>` | 映射字段 | `map<int32, string> data = 2;` |
| `Optional<T>` | `optional T` | 可选字段（proto3中已废弃） | `optional string name = 3;` |

### 2.2 repeated字段示例

**JProtobuf**：
```java
@Protobuf(fieldType = FieldType.OBJECT, order = 1, required = false)
public List<PT_ITEM> items;
```

**标准Protobuf**：
```protobuf
repeated PT_ITEM items = 1;
```

### 2.3 map字段示例

**JProtobuf**：
```java
@Protobuf(fieldType = FieldType.OBJECT, order = 2, required = false)
public Map<Integer, String> attributes;
```

**标准Protobuf**：
```protobuf
map<int32, string> attributes = 2;
```

### 2.4 集合类型注意事项

1. **repeated字段**
   - 不能为null，默认为空列表
   - 序列化时忽略null值
   - 反序列化时总是返回非null列表

2. **map字段**
   - 不能为null，默认为空map
   - key类型必须是标量类型（int32、string等）
   - value类型可以是任意类型

3. **optional字段**
   - proto3中已废弃
   - 建议使用proto2的optional语法
   - 或者在业务层处理null值

## 三、枚举类型映射

### 3.1 枚举类型对比

#### 3.1.1 JProtobuf枚举

```java
public enum ENUM_ROOM_TYPE {
    NORMAL(0),
    DUNGEON(1),
    RAID(2);

    private int value;

    ENUM_ROOM_TYPE(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}
```

#### 3.1.2 标准Protobuf枚举

```protobuf
enum ENUM_ROOM_TYPE {
    NORMAL = 0;
    DUNGEON = 1;
    RAID = 2;
}
```

### 3.2 枚举类型映射规则

| JProtobuf | 标准Protobuf | 说明 |
|-----------|--------------|------|
| 枚举名称 | 枚举名称 | 保持一致 |
| 枚举值 | 枚举值 | 保持一致 |
| value字段 | 直接使用 | 不需要value字段 |

### 3.3 枚举类型注意事项

1. **枚举值必须从0开始**
   - 第一个枚举值必须是0
   - 0值作为默认值

2. **枚举值不能重复**
   - 每个枚举值必须唯一
   - 避免使用魔法数字

3. **枚举值不能删除**
   - 删除枚举值会破坏兼容性
   - 使用`reserved`标记已删除的值

4. **枚举命名规范**
   - 使用UPPER_CASE命名
   - 使用下划线分隔单词
   - 添加前缀避免冲突

### 3.4 枚举类型示例

**JProtobuf**：
```java
public enum ENUM_JOB {
    SWORDMAN(0),
    FIGHTER(1),
    MAGE(2),
    GUNNER(3),
    THIEF(4);

    private int value;

    ENUM_JOB(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}
```

**标准Protobuf**：
```protobuf
enum ENUM_JOB {
    SWORDMAN = 0;
    FIGHTER = 1;
    MAGE = 2;
    GUNNER = 3;
    THIEF = 4;
}
```

## 四、消息类型映射

### 4.1 消息类型对比

#### 4.1.1 JProtobuf消息

```java
@MessageMeta(module = 10000, cmd = 1)
public class LOGIN {
    public static class REQ {
        @Protobuf(fieldType = FieldType.UINT64, order = 1, required = false)
        public Long userId;

        @Protobuf(fieldType = FieldType.UINT32, order = 2, required = false)
        public Integer roomId;

        @Protobuf(fieldType = FieldType.UINT64, order = 3, required = false)
        public Long accessToken;
    }
}
```

#### 4.1.2 标准Protobuf消息

```protobuf
// 登录请求 (module=10000, cmd=1)
message LOGIN_REQ {
  uint64 userId = 1;
  uint32 roomId = 2;
  uint64 accessToken = 3;
}
```

### 4.2 消息类型映射规则

| JProtobuf | 标准Protobuf | 说明 |
|-----------|--------------|------|
| `@MessageMeta(module, cmd)` | 注释说明 | 使用注释标注module和cmd |
| `REQ`内部类 | `REQ`后缀 | 请求消息 |
| `RES`内部类 | `RES`后缀 | 响应消息 |
| `PT_`前缀 | 直接使用 | 数据结构 |
| `ENUM_`前缀 | 直接使用 | 枚举类型 |

### 4.3 消息类型注意事项

1. **消息命名规范**
   - 使用大写字母
   - 使用下划线分隔单词
   - 添加REQ/RES后缀区分请求响应

2. **字段序号**
   - 必须从1开始
   - 不能重复
   - 不能修改已有字段的序号

3. **字段命名**
   - 使用snake_case
   - 避免使用保留字
   - 保持与Java字段对应

## 五、特殊类型处理

### 5.1 嵌套消息

**JProtobuf**：
```java
@Protobuf(fieldType = FieldType.OBJECT, order = 1, required = false)
public PT_CHARACTER character;
```

**标准Protobuf**：
```protobuf
PT_CHARACTER character = 1;
```

### 5.2 oneof字段

**JProtobuf**：
```java
// JProtobuf不支持oneof
```

**标准Protobuf**：
```protobuf
oneof equipment {
  Weapon weapon = 1;
  Armor armor = 2;
  Accessory accessory = 3;
}
```

### 5.3 默认值

**JProtobuf**：
```java
@Protobuf(fieldType = FieldType.INT32, order = 1, required = false)
public Integer level = 1;  // 默认值
```

**标准Protobuf**：
```protobuf
int32 level = 1 [default = 1];  // 默认值
```

### 5.4 保留字段

**标准Protobuf**：
```protobuf
message Character {
  reserved 5, 7, 10 to 12;
  reserved "old_field", "another_old_field";

  int64 char_guid = 1;
  string name = 2;
  int32 level = 3;
}
```

**说明**：
- `reserved`用于标记已删除的字段
- 防止新字段使用相同的序号
- 保持向后兼容性
