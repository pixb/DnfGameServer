# 批次10迁移计划：物品相关消息

## 一、迁移范围

### 1.1 消息类型

| ModuleID | 消息类型 | 功能描述 | 状态 |
| :--- | :--- | :--- | :--- |
| 14006 | 物品强化 | 强化装备物品 | ✅ 待迁移 |
| 14017 | 物品使用 | 使用各种物品 | ✅ 待迁移 |
| 14000 | 物品列表 | 查看背包物品 | ✅ 待迁移 |
| 14001 | 物品移动 | 移动物品位置 | ✅ 待迁移 |
| 14002 | 物品丢弃 | 丢弃物品 | ✅ 待迁移 |
| 14003 | 物品拆分 | 拆分堆叠物品 | ✅ 待迁移 |

### 1.2 涉及文件

#### Java文件
- `REQ_ITEM_USE.java` (ModuleID: 14017)
- `REQ_ITEM_REINFORCE.java` (ModuleID: 14006)
- `REQ_ITEM_LIST.java` (ModuleID: 14000, 假设存在)
- `REQ_ITEM_MOVE.java` (ModuleID: 14001, 假设存在)
- `REQ_ITEM_DROP.java` (ModuleID: 14002, 假设存在)
- `REQ_ITEM_SPLIT.java` (ModuleID: 14003, 假设存在)

#### 响应文件
- `RES_ITEM_USE.java`
- `RES_ITEM_REINFORCE.java`
- `RES_ITEM_LIST.java`
- `RES_ITEM_MOVE.java`
- `RES_ITEM_DROP.java`
- `RES_ITEM_SPLIT.java`

## 二、迁移步骤

### 2.1 分析阶段

1. **确认消息结构**：分析每个物品相关消息的字段结构
2. **确定ModuleID**：验证每个消息的ModuleID和CMD值
3. **识别依赖关系**：检查是否依赖其他数据结构

### 2.2 规划阶段

1. **创建proto文件**：创建`item.proto`文件定义物品相关消息
2. **定义消息格式**：为每个物品消息创建请求和响应结构
3. **设计数据结构**：定义物品相关的数据结构

### 2.3 执行阶段

1. **生成Go代码**：使用buf生成Go代码
2. **生成Java代码**：使用buf生成Java代码
3. **编写测试用例**：为每个消息编写单元测试
4. **扩展编解码器**：修改StandardProtobufDecoder和StandardProtobufEncoder

### 2.4 验证阶段

1. **运行单元测试**：确保所有测试通过
2. **编译Java项目**：验证Java代码编译成功
3. **跨语言测试**：验证Java和Go之间的通信

## 三、数据结构设计

### 3.1 核心数据结构

#### 物品消息

| 消息名称 | 字段 | 类型 | 描述 |
| :--- | :--- | :--- | :--- |
| ItemUseRequest | index | int32 | 物品索引 |
| ItemUseRequest | count | int32 | 使用数量 |
| ItemUseRequest | bind | bool | 是否绑定 |
| ItemUseRequest | guid | uint64 | 物品GUID |
| ItemUseRequest | type | int32 | 物品类型 |
| ItemUseRequest | input | string | 输入内容 |
| ItemUseRequest | selectitemindex | int32 | 选择物品索引 |
| ItemUseRequest | quest | repeated PT_QUEST | 任务列表 |
| ItemUseResponse | error | int32 | 错误码 |
| ItemUseResponse | result | int32 | 结果 |

| 消息名称 | 字段 | 类型 | 描述 |
| :--- | :--- | :--- | :--- |
| ItemReinforceRequest | type | int32 | 强化类型 |
| ItemReinforceRequest | guid | uint64 | 物品GUID |
| ItemReinforceRequest | talisman | int32 |  talisman |
| ItemReinforceRequest | customtype | int32 | 自定义类型 |
| ItemReinforceRequest | noticharlist | repeated uint64 | 通知角色列表 |
| ItemReinforceResponse | error | int32 | 错误码 |
| ItemReinforceResponse | result | int32 | 强化结果 |

| 消息名称 | 字段 | 类型 | 描述 |
| :--- | :--- | :--- | :--- |
| ItemListRequest | type | int32 | 物品类型 |
| ItemListRequest | page | int32 | 页码 |
| ItemListResponse | error | int32 | 错误码 |
| ItemListResponse | items | repeated ItemInfo | 物品列表 |

| 消息名称 | 字段 | 类型 | 描述 |
| :--- | :--- | :--- | :--- |
| ItemMoveRequest | fromIndex | int32 | 源索引 |
| ItemMoveRequest | toIndex | int32 | 目标索引 |
| ItemMoveRequest | count | int32 | 移动数量 |
| ItemMoveRequest | guid | uint64 | 物品GUID |
| ItemMoveResponse | error | int32 | 错误码 |
| ItemMoveResponse | success | bool | 是否成功 |

| 消息名称 | 字段 | 类型 | 描述 |
| :--- | :--- | :--- | :--- |
| ItemDropRequest | index | int32 | 物品索引 |
| ItemDropRequest | count | int32 | 丢弃数量 |
| ItemDropRequest | guid | uint64 | 物品GUID |
| ItemDropResponse | error | int32 | 错误码 |
| ItemDropResponse | success | bool | 是否成功 |

| 消息名称 | 字段 | 类型 | 描述 |
| :--- | :--- | :--- | :--- |
| ItemSplitRequest | index | int32 | 物品索引 |
| ItemSplitRequest | count | int32 | 拆分数量 |
| ItemSplitRequest | guid | uint64 | 物品GUID |
| ItemSplitResponse | error | int32 | 错误码 |
| ItemSplitResponse | success | bool | 是否成功 |

### 3.2 依赖数据结构

#### PT_QUEST (简化版)

| 字段 | 类型 | 描述 |
| :--- | :--- | :--- |
| id | int32 | 任务ID |
| progress | int32 | 任务进度 |

#### ItemInfo (简化版)

| 字段 | 类型 | 描述 |
| :--- | :--- | :--- |
| index | int32 | 物品索引 |
| guid | uint64 | 物品GUID |
| id | int32 | 物品ID |
| count | int32 | 物品数量 |
| bind | bool | 是否绑定 |
|强化等级 | int32 | 强化等级 |

## 三、proto文件设计

### 3.1 文件结构

```
proto/
└── dnf/
    └── v1/
        ├── item.proto        # 物品相关消息
        └── common.proto      # 公共数据结构
```

### 3.2 item.proto

```protobuf
syntax = "proto3";

package dnf.v1;

import "dnf/v1/common.proto";

// Go代码生成选项
option go_package = "github.com/pixb/DnfGameServer/dnf-go-client/gen/dnf/v1;dnfv1";

// Java代码生成选项
option java_multiple_files = true;
option java_package = "com.dnfm.mina.protobuf.generated";
option java_outer_classname = "ItemProto";

// 物品使用请求
message ItemUseRequest {
  int32 index = 1;
  int32 count = 2;
  bool bind = 3;
  uint64 guid = 4;
  int32 type = 5;
  string input = 6;
  int32 selectitemindex = 7;
  repeated PT_QUEST quest = 8;
}

// 物品使用响应
message ItemUseResponse {
  int32 error = 1;
  int32 result = 2;
}

// 物品强化请求
message ItemReinforceRequest {
  int32 type = 1;
  uint64 guid = 2;
  int32 talisman = 3;
  int32 customtype = 4;
  repeated uint64 noticharlist = 5;
}

// 物品强化响应
message ItemReinforceResponse {
  int32 error = 1;
  int32 result = 2;
}

// 物品列表请求
message ItemListRequest {
  int32 type = 1;
  int32 page = 2;
}

// 物品列表响应
message ItemListResponse {
  int32 error = 1;
  repeated ItemInfo items = 2;
}

// 物品移动请求
message ItemMoveRequest {
  int32 fromIndex = 1;
  int32 toIndex = 2;
  int32 count = 3;
  uint64 guid = 4;
}

// 物品移动响应
message ItemMoveResponse {
  int32 error = 1;
  bool success = 2;
}

// 物品丢弃请求
message ItemDropRequest {
  int32 index = 1;
  int32 count = 2;
  uint64 guid = 3;
}

// 物品丢弃响应
message ItemDropResponse {
  int32 error = 1;
  bool success = 2;
}

// 物品拆分请求
message ItemSplitRequest {
  int32 index = 1;
  int32 count = 2;
  uint64 guid = 3;
}

// 物品拆分响应
message ItemSplitResponse {
  int32 error = 1;
  bool success = 2;
}

// 任务信息（简化版）
message PT_QUEST {
  int32 id = 1;
  int32 progress = 2;
}

// 物品信息（简化版）
message ItemInfo {
  int32 index = 1;
  uint64 guid = 2;
  int32 id = 3;
  int32 count = 4;
  bool bind = 5;
  int32 reinforceLevel = 6;
}
```

## 四、编解码器扩展

### 4.1 StandardProtobufDecoder.java

需要添加以下case分支：

```java
case 14006:
    return adaptItemReinforceRequest(body);
case 14017:
    return adaptItemUseRequest(body);
case 14000:
    return adaptItemListRequest(body);
case 14001:
    return adaptItemMoveRequest(body);
case 14002:
    return adaptItemDropRequest(body);
case 14003:
    return adaptItemSplitRequest(body);
```

### 4.2 StandardProtobufEncoder.java

需要添加以下case分支：

```java
case 14006:
    return adaptItemReinforceResponse(msg);
case 14017:
    return adaptItemUseResponse(msg);
case 14000:
    return adaptItemListResponse(msg);
case 14001:
    return adaptItemMoveResponse(msg);
case 14002:
    return adaptItemDropResponse(msg);
case 14003:
    return adaptItemSplitResponse(msg);
```

## 五、测试计划

### 5.1 单元测试

- `TestBatch10ItemUse`：测试物品使用消息
- `TestBatch10ItemReinforce`：测试物品强化消息
- `TestBatch10ItemList`：测试物品列表消息
- `TestBatch10ItemMove`：测试物品移动消息
- `TestBatch10ItemDrop`：测试物品丢弃消息
- `TestBatch10ItemSplit`：测试物品拆分消息

### 5.2 编解码器测试

创建 `batch10_codec.go` 测试文件，验证：
- 所有物品相关消息的序列化和反序列化
- 网络包构建（包含ModuleID、CMD、序列号等）
- 复杂数据结构的处理（嵌套消息、重复字段等）

## 六、预期成果

1. **proto文件**：`item.proto`，定义所有物品相关消息
2. **生成代码**：Go和Java代码，用于跨语言通信
3. **测试文件**：单元测试和编解码器测试
4. **编解码器扩展**：支持物品相关消息的编解码
5. **测试验证**：所有测试通过，编解码器功能正常

## 七、风险评估

### 7.1 潜在风险

1. **数据结构复杂性**：物品信息可能包含复杂的嵌套结构
2. **依赖关系**：可能依赖其他未迁移的数据结构
3. **字段映射错误**：Java和Protobuf类型映射可能存在差异
4. **测试覆盖不足**：可能遗漏某些边界情况

### 7.2 缓解措施

1. **使用简化版本**：对于复杂数据结构，使用只包含关键字段的简化版本
2. **逐步迁移**：先迁移核心消息，再处理依赖项
3. **严格类型检查**：确保Java和Protobuf类型正确映射
4. **全面测试**：为每个消息编写详细的单元测试

## 八、迁移时间估计

| 阶段 | 预计时间 |
| :--- | :--- |
| 分析阶段 | 30分钟 |
| 规划阶段 | 30分钟 |
| 创建proto文件 | 1小时 |
| 生成代码 | 30分钟 |
| 编写测试用例 | 1小时 |
| 扩展编解码器 | 1小时 |
| 运行测试验证 | 30分钟 |
| 文档更新 | 30分钟 |

**总计**：约6小时

## 九、迁移顺序

1. 创建 `item.proto` 文件
2. 生成Go和Java代码
3. 编写单元测试
4. 扩展StandardProtobufDecoder
5. 扩展StandardProtobufEncoder
6. 运行单元测试
7. 创建编解码器测试
8. 运行编解码器测试
9. 编译Java项目
10. 更新文档

## 十、成功标准

1. ✅ 所有物品相关消息都已迁移到标准Protobuf
2. ✅ 生成的Go和Java代码编译通过
3. ✅ 所有单元测试通过
4. ✅ 编解码器测试验证通过
5. ✅ Java项目编译成功
6. ✅ 文档更新完成

---

**迁移负责人**：系统
**计划日期**：2026-02-09
**预计完成日期**：2026-02-09
