# 代码生成与集成

## 渐进式迁移原则

**重要**：本文档描述的是完整的代码生成和集成流程，但在实际迁移中，请务必遵循以下原则：

1. **每次只迁移1-2个文件**，不要一次性迁移所有文件
2. **每个文件转换后立即测试**，确保功能正确
3. **保持新旧代码共存**，通过配置切换
4. **逐步扩大迁移范围**，避免一次性改动过大
5. **保留回退方案**，出现问题可以快速恢复

## 一、生成代码

### 1.1 安装protoc

#### 1.1.1 Windows

```bash
# 下载protoc
# 访问 https://github.com/protocolbuffers/protobuf/releases
# 下载对应版本的protoc-win64.zip

# 解压并添加到PATH
# 将protoc.exe所在目录添加到系统PATH环境变量
```

#### 1.1.2 Linux/Mac

```bash
# 使用包管理器安装
brew install protobuf  # Mac
apt install protobuf-compiler  # Ubuntu
yum install protobuf-compiler  # CentOS

# 验证安装
protoc --version
```

### 1.2 生成Java代码

#### 1.2.1 命令行生成

```bash
# 创建输出目录
mkdir -p gen/java

# 生成Java代码
protoc --java_out=gen/java proto/generated/common/*.proto
```

#### 1.2.2 Maven插件生成

```xml
<build>
    <plugins>
        <!-- Protobuf Maven插件 -->
        <plugin>
            <groupId>org.xolstice.maven.plugins</groupId>
            <artifactId>protobuf-maven-plugin</artifactId>
            <version>0.6.1</version>
            <configuration>
                <protoSourceRoot>${project.basedir}/proto/generated</protoSourceRoot>
                <outputDirectory>target/generated-sources/protobuf/java</outputDirectory>
            </configuration>
            <executions>
                <execution>
                    <goals>
                        <goal>compile</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

#### 1.2.3 Buf工具生成

```bash
# 安装buf
# 访问 https://buf.build/docs/installation

# 生成代码
cd proto
buf generate
```

### 1.3 生成其他语言代码

#### 1.3.1 Go代码

```bash
# 生成Go代码
protoc --go_out=gen/go proto/generated/common/*.proto

# 或使用buf
cd proto
buf generate --template go
```

#### 1.3.2 Python代码

```bash
# 生成Python代码
protoc --python_out=gen/python proto/generated/common/*.proto

# 或使用buf
cd proto
buf generate --template python
```

#### 1.3.3 TypeScript代码

```bash
# 生成TypeScript代码
protoc --ts_out=gen/ts proto/generated/common/*.proto

# 或使用buf
cd proto
buf generate --template ts
```

## 二、集成到Java项目

### 2.1 添加依赖

```xml
<dependencies>
    <!-- 标准protobuf依赖 -->
    <dependency>
        <groupId>com.google.protobuf</groupId>
        <artifactId>protobuf-java</artifactId>
        <version>3.21.12</version>
    </dependency>

    <!-- gRPC依赖（可选） -->
    <dependency>
        <groupId>io.grpc</groupId>
        <artifactId>grpc-netty-shaded</artifactId>
        <version>1.50.0</version>
    </dependency>
</dependencies>
```

### 2.2 复制生成的代码

```bash
# 复制生成的Java代码到项目
cp -r proto/gen/java/dnf/v1/*.java src/main/java/com/dnfm/mina/protobuf/generated/
```

### 2.3 修改编解码器

#### 2.3.1 创建标准Protobuf序列化器

```java
package com.dnfm.mina.codec;

import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.MessageLite;
import com.google.protobuf.Parser;
import com.dnfm.mina.protobuf.Message;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class StandardProtobufSerializer {
    private static final Logger logger = LoggerFactory.getLogger(StandardProtobufSerializer.class);

    /**
     * 编码Message对象
     */
    public static byte[] encode(Message message) {
        try {
            // 将Message转换为标准protobuf消息
            MessageLite protobufMessage = convertToProtobufMessage(message);
            return protobufMessage.toByteArray();
        } catch (Exception e) {
            logger.error("编码消息失败", e);
            return null;
        }
    }

    /**
     * 解码字节数组为Message对象
     */
    public static Message decode(int module, int cmd, byte[] data) {
        try {
            // 根据module和cmd获取对应的Parser
            Parser<? extends MessageLite> parser = ProtobufParserRegistry.getParser(module, cmd);

            if (parser == null) {
                logger.warn("未找到对应的Parser: module={}, cmd={}", module, cmd);
                return null;
            }

            // 解析protobuf消息
            MessageLite protobufMessage = parser.parseFrom(data);

            // 转换为自定义Message对象
            return convertFromProtobufMessage(protobufMessage);
        } catch (InvalidProtocolBufferException e) {
            logger.error("解码消息失败: module={}, cmd={}", module, cmd, e);
            return null;
        }
    }

    /**
     * 将自定义Message转换为标准protobuf消息
     */
    private static MessageLite convertToProtobufMessage(Message message) {
        // TODO: 实现转换逻辑
        // 可以使用反射或手动映射
        return null;
    }

    /**
     * 将标准protobuf消息转换为自定义Message
     */
    private static Message convertFromProtobufMessage(MessageLite protobufMessage) {
        // TODO: 实现转换逻辑
        // 可以使用反射或手动映射
        return null;
    }
}
```

#### 2.3.2 创建Parser注册表

```java
package com.dnfm.mina.codec;

import com.google.protobuf.Parser;
import dnf.v1.AuthProto;
import dnf.v1.CharacterProto;
import java.util.HashMap;
import java.util.Map;

public class ProtobufParserRegistry {
    private static final Map<String, Parser<? extends com.google.protobuf.MessageLite>> PARSER_MAP = new HashMap<>();

    static {
        // 注册所有消息的Parser
        // LOGIN_REQ
        PARSER_MAP.put("10000_1", AuthProto.LoginRequest.getDefaultInstance().getParserForType());
        // LOGIN_RES
        PARSER_MAP.put("10000_2", AuthProto.LoginResponse.getDefaultInstance().getParserForType());

        // CHARACTER_LIST_REQ
        PARSER_MAP.put("10002_1", CharacterProto.CharacterListRequest.getDefaultInstance().getParserForType());
        // CHARACTER_LIST_RES
        PARSER_MAP.put("10002_2", CharacterProto.CharacterListResponse.getDefaultInstance().getParserForType());

        // TODO: 注册其他消息的Parser
    }

    public static Parser<? extends com.google.protobuf.MessageLite> getParser(int module, int cmd) {
        String key = module + "_" + cmd;
        return PARSER_MAP.get(key);
    }

    public static void registerParser(String key, Parser<? extends com.google.protobuf.MessageLite> parser) {
        PARSER_MAP.put(key, parser);
    }
}
```

### 2.4 修改DNFEncoder

```java
package com.dnfm.mina.codec;

import com.dnfm.mina.protobuf.Message;
import org.apache.mina.core.buffer.IoBuffer;
import org.apache.mina.core.session.IoSession;
import org.apache.mina.filter.codec.ProtocolEncoder;
import org.apache.mina.filter.codec.ProtocolEncoderOutput;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class StandardDNFEncoder implements ProtocolEncoder {
    private static final Logger logger = LoggerFactory.getLogger(StandardDNFEncoder.class);

    @Override
    public void encode(IoSession session, Object message, ProtocolEncoderOutput out) throws Exception {
        if (!(message instanceof Message)) {
            logger.error("不支持的消息类型: {}", message.getClass().getName());
            return;
        }

        Message msg = (Message) message;

        try {
            // 使用标准protobuf序列化
            byte[] body = StandardProtobufSerializer.encode(msg);

            if (body == null) {
                logger.error("序列化失败: {}", msg.getClass().getName());
                return;
            }

            // 加密消息体
            byte seq = getSeq(session);
            byte[] encBody = Enc.encrypt(seq, body);

            // 组装消息头
            int totalLen = 8 + encBody.length;
            int moduleId = msg.getModule();
            int cmd = msg.getCmd();
            Integer transId = msg.transId;
            int bodyLen = encBody.length;

            // 写入IoBuffer
            IoBuffer buffer = IoBuffer.allocate(totalLen);
            buffer.order(ByteOrder.LITTLE_ENDIAN);

            // 消息头（8字节）
            buffer.putShort((short) totalLen);
            buffer.putShort((short) moduleId);
            buffer.put(seq);
            buffer.put(transId != null ? transId.byteValue() : 0);
            buffer.putShort((short) bodyLen);

            // 消息体
            buffer.put(encBody);

            buffer.flip();
            out.write(buffer);
        } catch (Exception e) {
            logger.error("编码消息失败: {}", msg.getClass().getName(), e);
        }
    }

    private byte getSeq(IoSession session) {
        // 获取会话的序列号
        return (byte) session.getAttribute("seq");
    }
}
```

### 2.5 修改DNFDecoder

```java
package com.dnfm.mina.codec;

import com.dnfm.mina.protobuf.Message;
import org.apache.mina.core.buffer.IoBuffer;
import org.apache.mina.core.session.IoSession;
import org.apache.mina.filter.codec.ProtocolDecoder;
import org.apache.mina.filter.codec.ProtocolDecoderOutput;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class StandardDNFDecoder implements ProtocolDecoder {
    private static final Logger logger = LoggerFactory.getLogger(StandardDNFDecoder.class);

    @Override
    public void decode(IoSession session, IoBuffer in, ProtocolDecoderOutput out) throws Exception {
        // 检查是否有足够的数据读取消息头
        if (in.remaining() < 8) {
            return;  // 等待更多数据
        }

        // 标记当前位置
        in.mark();

        // 读取消息头
        int totalLen = in.getShort() & 0xFFFF;
        int moduleId = in.getShort() & 0xFFFF;
        byte seq = in.get();
        byte transId = in.get();
        int bodyLen = in.getShort() & 0xFFFF;

        // 检查是否有足够的数据读取消息体
        if (in.remaining() < bodyLen) {
            in.reset();  // 回到标记位置
            return;  // 等待更多数据
        }

        // 读取消息体
        byte[] encBody = new byte[bodyLen];
        in.get(encBody);

        // 解密消息体
        byte[] decBody = Enc.decrypt2(seq, encBody);

        // 提取cmd（从moduleId中提取）
        int cmd = extractCmd(moduleId);

        // 使用标准protobuf反序列化
        Message msg = StandardProtobufSerializer.decode(moduleId, cmd, decBody);

        if (msg != null) {
            msg.transId = (int) transId;
            out.write(msg);
        } else {
            logger.error("解码失败: moduleId={}, cmd={}", moduleId, cmd);
        }
    }

    private int extractCmd(int moduleId) {
        // 从moduleId中提取cmd
        // 这里需要根据实际的moduleId格式来实现
        return 0;
    }
}
```

## 三、使用生成的代码

### 3.1 创建消息

```java
import dnf.v1.AuthProto;

// 创建登录请求
AuthProto.LoginRequest request = AuthProto.LoginRequest.newBuilder()
    .setOpenid("user123")
    .setType(1)
    .setToken("abc123")
    .setPlatId(1)
    .build();

// 序列化
byte[] data = request.toByteArray();

// 反序列化
AuthProto.LoginRequest parsed = AuthProto.LoginRequest.parseFrom(data);
```

### 3.2 发送消息

```java
// 创建请求
AuthProto.LoginRequest request = AuthProto.LoginRequest.newBuilder()
    .setOpenid("user123")
    .build();

// 序列化
byte[] body = request.toByteArray();

// 加密
byte seq = getSeq(session);
byte[] encBody = Enc.encrypt(seq, body);

// 组装消息头
int totalLen = 8 + encBody.length;
IoBuffer buffer = IoBuffer.allocate(totalLen);
buffer.putShort((short) totalLen);
buffer.putShort((short) 10000);
buffer.put(seq);
buffer.put((byte) 0);
buffer.putShort((short) encBody.length);
buffer.put(encBody);

// 发送
session.write(buffer);
```

### 3.3 接收消息

```java
// 从网络接收数据
byte[] data = receiveFromNetwork();

// 解密
byte[] decBody = Enc.decrypt2(seq, data);

// 反序列化
AuthProto.LoginResponse response = AuthProto.LoginResponse.parseFrom(decBody);

// 处理响应
if (response.getError() == 0) {
    // 成功
    String authKey = response.getAuthKey();
    // ...
} else {
    // 失败
    logger.error("登录失败: error={}", response.getError());
}
```

## 四、构建和部署

### 4.1 Maven构建

```bash
# 清理
mvn clean

# 编译
mvn compile

# 打包
mvn package

# 跳过测试
mvn package -DskipTests
```

### 4.2 运行测试

```bash
# 运行所有测试
mvn test

# 运行特定测试
mvn test -Dtest=LoginTest

# 运行特定测试类
mvn test -Dtest=LoginTest#testLogin
```

### 4.3 部署

```bash
# 复制JAR到服务器
scp target/dnf-game-server.jar user@server:/path/to/deploy/

# 重启服务
ssh user@server "systemctl restart dnf-game-server"
```
